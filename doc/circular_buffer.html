<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

    <title>Templated Circular Buffer Container</title>
  </head>
  <body bgcolor="#ffffff">
    <table id="title" border="0">
      <tr>
<td>
                    <h1>Templated Circular Buffer Container</h1>
                    <h1>circular_buffer&lt;T, Alloc&gt;</h1>
                </td>
                <td><a href="../../../"><IMG height=86 alt=Boost src="../../../c++boost.gif" width=277 border=0></a></td>
            </tr>
    </table>
    <h2>Contents</h2>
    <A href="#description">Description</A><br>
    <A href="#simpleexample">Simple Example</A><br>
    <A href="#synopsis">Synopsis</A><br>
    <A href="#rationale">Rationale</A><br>
    <A href="#header">Header files</A><br>
    <A href="#model">Modeled concepts</A><br>
    <A href="#parameters">Template Parameters</A><br>
    <A href="#types">Public Types</A><br>
    <A href="#constructors">Constructors &amp; Destructor</A><br>
    <A href="#methods">Public Member Functions</A><br>
    <A href="#functions">Standalone Functions</A><br>
    <A href="#semantics">Semantics</A><br>
    <A href="#caveats">Caveats</A><br>
    <A href="#debug">Debug Support</A><br>
    <A href="#example">Example</A><br>
    <A href="#notes">Notes</A><br>
    <A href="#see">See also</A><br>
    <A href="#ideas">Ideas for Future Improvements</A><br>
    <A href="#ack">Acknowledgments</A>
    <table id="table_figure" border="0" align="right">
      <tr>
<td><IMG height=332 alt="Circular Buffer" src="circular_buffer.png" width=300 ></td>
              </tr>
      <tr>
<td width="300">
                      <table id="table_figure_desc" align="right" border="0" cellpadding="5"><tr>
<td valign="top"><b>Figure:</b></td>
                              <td valign="top">The circular buffer (for someone known as ring or cyclic buffer).</td>
                          </tr></table>
</td>
              </tr>
    </table>
    <h2>
      <a name="description">Description</a>
    </h2>
    <p>The <code>circular_buffer</code> container provides fixed capacity storage with
            constant time insertion and removal of elements at each end of a circular
            buffer. When the capacity of the <code>circular_buffer</code> is exhausted,
            inserted elements will cause elements at the opposite end to be overwritten (see the Figure).
            The <code>circular_buffer</code> only allocates memory when
            created, when the capacity is adjusted explicitly, or as necessary to
            accommodate a resizing or assign operation. (There is also a <code><A href="circular_buffer_space_optimized.html">circular_buffer_space_optimized</A>
            </code>available. It is an adaptor of the <code>circular_buffer</code>
            which does not allocate memory at once when created rather it allocates memory as needed.)
        </p>
    <h2>
      <a name="simpleexample">Simple Example</a>
    </h2>
    <p>A brief example using the <code>circular_buffer</code>:
        </p>
    <pre>   #include &lt;boost/circular_buffer.hpp&gt;

   int main(int argc, char* argv[]) {

      // Create a circular buffer with capacity for 3 integers.
      boost::circular_buffer&lt;int&gt; cb(3);

      cb.push_back(1);  // Insert the first element.
      cb.push_back(2);  // Insert the second element.
      cb.push_back(3);  // Insert the third element.

      // The buffer is full now, pushing subsequent
      // elements will overwrite the front-most elements.

      cb.push_back(4);  // Overwrite 1 with 4.
      cb.push_back(5);  // Overwrite 2 with 5.

      // The buffer now contains 3, 4 and 5.
      int a = cb[0];  // a == 3
      int b = cb[1];  // b == 4
      int c = cb[2];  // c == 5

      // Elements can be popped from either the front or back.

      cb.pop_back();  // 5 is removed.
      cb.pop_front(); // 3 is removed.

      int d = cb[0];  // d == 4

      return 0;
   }</pre>
    <h2>
      <a name="synopsis">Synopsis</a>
    </h2>
    <div id="srcdoc_synopsis">
      <table id="table_synopsis" border="0" cellpadding="10">
        <tr>
          <td>
            <pre>
namespace boost {

template &lt;class&nbsp;<A href="#templateparam_T">T</A>, class&nbsp;<A href="#templateparam_Alloc">Alloc</A>&gt;
class circular_buffer
{
public:
&nbsp;&nbsp;&nbsp;typedef&nbsp;Alloc&nbsp;<A href="#classboost_1_1circular__buffer_1w0">allocator_type</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;<i>implementation-defined</i>&nbsp;<A href="#classboost_1_1circular__buffer_1w1">const_iterator</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;typename Alloc::const_pointer&nbsp;<A href="#classboost_1_1circular__buffer_1w2">const_pointer</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;typename Alloc::const_reference&nbsp;<A href="#classboost_1_1circular__buffer_1w3">const_reference</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;<i>implementation-defined</i>&nbsp;<A href="#classboost_1_1circular__buffer_1w4">const_reverse_iterator</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;typename Alloc::difference_type&nbsp;<A href="#classboost_1_1circular__buffer_1w5">difference_type</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;<i>implementation-defined</i>&nbsp;<A href="#classboost_1_1circular__buffer_1w6">iterator</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;typename Alloc::pointer&nbsp;<A href="#classboost_1_1circular__buffer_1w8">pointer</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;typename Alloc::reference&nbsp;<A href="#classboost_1_1circular__buffer_1w9">reference</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;<i>implementation-defined</i>&nbsp;<A href="#classboost_1_1circular__buffer_1w11">reverse_iterator</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;typename Alloc::size_type&nbsp;<A href="#classboost_1_1circular__buffer_1w12">size_type</A>;
&nbsp;&nbsp;&nbsp;typedef&nbsp;typename Alloc::value_type&nbsp;<A href="#classboost_1_1circular__buffer_1w13">value_type</A>;

&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;InputIterator&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#classboost_1_1circular__buffer_1a9">circular_buffer</A>(size_type&nbsp;capacity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputIterator&nbsp;first, InputIterator&nbsp;last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;allocator_type&amp;&nbsp;alloc = allocator_type());
&nbsp;&nbsp;&nbsp;<A href="#classboost_1_1circular__buffer_1a10">circular_buffer</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;cb);
&nbsp;&nbsp;&nbsp;<A href="#classboost_1_1circular__buffer_1a11">circular_buffer</A>(size_type&nbsp;capacity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value_type&nbsp;item, const&nbsp;allocator_type&amp;&nbsp;alloc = allocator_type());
&nbsp;&nbsp;&nbsp;explicit <A href="#classboost_1_1circular__buffer_1a12">circular_buffer</A>(size_type&nbsp;capacity, const&nbsp;allocator_type&amp;&nbsp;alloc = allocator_type());
&nbsp;&nbsp;&nbsp;<A href="#classboost_1_1circular__buffer_1a51">~circular_buffer</A>();

&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;InputIterator&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a0">assign</A>(InputIterator&nbsp;first, InputIterator&nbsp;last);
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a1">assign</A>(size_type&nbsp;n, value_type&nbsp;item);
&nbsp;&nbsp;&nbsp;value_type&nbsp;<A href="#classboost_1_1circular__buffer_1a2">at</A>(size_type&nbsp;index) const;
&nbsp;&nbsp;&nbsp;reference&nbsp;<A href="#classboost_1_1circular__buffer_1a3">at</A>(size_type&nbsp;index);
&nbsp;&nbsp;&nbsp;value_type&nbsp;<A href="#classboost_1_1circular__buffer_1a4">back</A>() const;
&nbsp;&nbsp;&nbsp;reference&nbsp;<A href="#classboost_1_1circular__buffer_1a5">back</A>();
&nbsp;&nbsp;&nbsp;const_iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a6">begin</A>() const;
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a7">begin</A>();
&nbsp;&nbsp;&nbsp;size_type&nbsp;<A href="#classboost_1_1circular__buffer_1a8">capacity</A>() const;
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a13">clear</A>();
&nbsp;&nbsp;&nbsp;pointer&nbsp;<A href="#classboost_1_1circular__buffer_1a14">data</A>();
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#classboost_1_1circular__buffer_1a15">empty</A>() const;
&nbsp;&nbsp;&nbsp;const_iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a16">end</A>() const;
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a17">end</A>();
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a18">erase</A>(iterator&nbsp;first, iterator&nbsp;last);
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a19">erase</A>(iterator&nbsp;pos);
&nbsp;&nbsp;&nbsp;value_type&nbsp;<A href="#classboost_1_1circular__buffer_1a20">front</A>() const;
&nbsp;&nbsp;&nbsp;reference&nbsp;<A href="#classboost_1_1circular__buffer_1a21">front</A>();
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#classboost_1_1circular__buffer_1a22">full</A>() const;
&nbsp;&nbsp;&nbsp;allocator_type&amp;&nbsp;<A href="#classboost_1_1circular__buffer_1a23">get_allocator</A>();
&nbsp;&nbsp;&nbsp;allocator_type&nbsp;<A href="#classboost_1_1circular__buffer_1a24">get_allocator</A>() const;
&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;InputIterator&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a25">insert</A>(iterator&nbsp;pos, InputIterator&nbsp;first, InputIterator&nbsp;last);
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a26">insert</A>(iterator&nbsp;pos, size_type&nbsp;n, value_type&nbsp;item);
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a27">insert</A>(iterator&nbsp;pos);
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a28">insert</A>(iterator&nbsp;pos, value_type&nbsp;item);
&nbsp;&nbsp;&nbsp;size_type&nbsp;<A href="#classboost_1_1circular__buffer_1a29">max_size</A>() const;
&nbsp;&nbsp;&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;<A href="#classboost_1_1circular__buffer_1a30">operator=</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;cb);
&nbsp;&nbsp;&nbsp;value_type&nbsp;<A href="#classboost_1_1circular__buffer_1a31">operator[]</A>(size_type&nbsp;index) const;
&nbsp;&nbsp;&nbsp;reference&nbsp;<A href="#classboost_1_1circular__buffer_1a32">operator[]</A>(size_type&nbsp;index);
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a33">pop_back</A>();
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a34">pop_front</A>();
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a35">push_back</A>();
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a36">push_back</A>(value_type&nbsp;item);
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a37">push_front</A>();
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a38">push_front</A>(value_type&nbsp;item);
&nbsp;&nbsp;&nbsp;const_reverse_iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a39">rbegin</A>() const;
&nbsp;&nbsp;&nbsp;reverse_iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a40">rbegin</A>();
&nbsp;&nbsp;&nbsp;const_reverse_iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a41">rend</A>() const;
&nbsp;&nbsp;&nbsp;reverse_iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a42">rend</A>();
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a43">resize</A>(size_type&nbsp;new_size, value_type&nbsp;item = T(), bool&nbsp;remove_front = true);
&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;InputIterator&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a44">rinsert</A>(iterator&nbsp;pos, InputIterator&nbsp;first, InputIterator&nbsp;last);
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a45">rinsert</A>(iterator&nbsp;pos, size_type&nbsp;n, value_type&nbsp;item);
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a46">rinsert</A>(iterator&nbsp;pos);
&nbsp;&nbsp;&nbsp;iterator&nbsp;<A href="#classboost_1_1circular__buffer_1a47">rinsert</A>(iterator&nbsp;pos, value_type&nbsp;item);
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a48">set_capacity</A>(size_type&nbsp;new_capacity, bool&nbsp;remove_front = true);
&nbsp;&nbsp;&nbsp;size_type&nbsp;<A href="#classboost_1_1circular__buffer_1a49">size</A>() const;
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#classboost_1_1circular__buffer_1a50">swap</A>(circular_buffer&amp;&nbsp;cb);
};

template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#namespaceboost_1a9">operator!=</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);
template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#namespaceboost_1a8">operator&lt;</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);
template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#namespaceboost_1a11">operator&lt;=</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);
template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#namespaceboost_1a7">operator==</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);
template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#namespaceboost_1a10">operator&gt;</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);
template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;
&nbsp;&nbsp;&nbsp;bool&nbsp;<A href="#namespaceboost_1a12">operator&gt;=</A>(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);
template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;
&nbsp;&nbsp;&nbsp;void&nbsp;<A href="#namespaceboost_1a13">swap</A>(circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);

} // namespace boost
</pre>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="rationale">Rationale</a>
    </h2>
    <p>A contiguous region of memory utilized as a circular buffer has several unique
            and useful characteristics:
        </p>
    <ol>
<li>
            Fixed memory use and no implicit or unexpected memory
  allocation.

<li>
            Fast constant-time insertion and removal of elements
  from the front and back.

<li>
            Fast constant-time random access of elements.

<li>
                Suitability for real-time and performance critical applications.
            </li>
        </ol>
    <p>The <code>circular_buffer</code> container provides a similar interface to <code>std::vector</code>,
            <code>std::deque</code> and <code>std::list</code> including <code>push</code>, <code>
                pop</code>, <code>insert</code>, <code>erase</code>, iterators and
            compatibility with <code>std</code> algorithms.
        </p>
    <p>Possible applications of the <code>circular_buffer</code> include:
        </p>
    <ul>
<li>
            Storage of the most recently received samples,
  overwriting the oldest as new samples arrive.

<li>
            Efficient fixed capacity FIFO (First In, First Out)
  queue.

<li>
            Efficient fixed capacity LIFO (Last In, First Out) queue.
            </li>
        </ul>
    <p>The design of the <code>circular_buffer</code> container is guided by the
            following principles:
        </p>
    <ol>
<li>
                Maximum <em>efficiency</em> for
  envisaged applications.
      <li>
                Suitable for <em>general purpose</em> use.
      <li>
                <em>Interoperable</em> with other <code>std</code> containers and algorithms.
      <li>
                The behaviour of the buffer as <em>intuitive</em> as possible.
      <li>
                Suitable for <em>specialization</em> by means of adaptors. (The <code><A href="circular_buffer_space_optimized.html">circular_buffer_space_optimized</A>
            </code>is such an example of the adaptor.)
      <li>
                Guarantee of <em>basic exception safety</em>.</li>
    </ol>
    <h2>
      <a name="header">Header files</a>
    </h2>
    <p>
            The <code>circular_buffer</code> is defined in the file
      <code><A href="../../../boost/circular_buffer.hpp">boost/circular_buffer.hpp</A></code>.
      There is also a forward declaration for the <code>circular_buffer</code> in the header file
      <code><A href="../../../boost/circular_buffer_fwd.hpp">boost/circular_buffer_fwd.hpp</A></code>.
        </p>
    <h2>
      <a name="model">Modeled concepts</a>
    </h2>
    <p><a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access
                Container</a>, <a href="http://www.sgi.com/tech/stl/FrontInsertionSequence.html">
                Front Insertion Sequence</a>, <a href="http://www.sgi.com/tech/stl/BackInsertionSequence.html">
                Back Insertion Sequence</a>, <a href="http://www.sgi.com/tech/stl/Assignable.html">
                Assignable</a> (SGI specific), <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">
                Equality Comparable</a>, <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">
                LessThan Comparable</a> (SGI specific)
        </p>
    <h2>
      <a name="parameters">Template Parameters</a>
    </h2>
    <div id="srcdoc_params">
      <table id="table_template_params" border="1">
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
        <tr>
          <td>
            <a name="templateparam_T">
              <code>T</code>
            </a>
          </td>
          <td>
The type of the elements stored in the circular buffer. </td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>
            <a name="templateparam_Alloc">
              <code>Alloc</code>
            </a>
          </td>
          <td>
The allocator type used for all internal memory management. </td>
          <td>
            <code>std::allocator&lt;T&gt; </code>
          </td>
        </tr>
      </table>
    </div>
    <br>
    <h2>
      <a name="types">Public Types</a>
    </h2>
    <div id="srcdoc_types">
      <table id="table_public_types" border="1">
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w0">
              <code>allocator_type</code>
            </a>
          </td>
          <td>
The type of the allocator used in the circular buffer.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w1">
              <code>const_iterator</code>
            </a>
          </td>
          <td>
Const (random access) iterator used to iterate through a circular buffer.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w2">
              <code>const_pointer</code>
            </a>
          </td>
          <td>
Const pointer to the element.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w3">
              <code>const_reference</code>
            </a>
          </td>
          <td>
Const reference to the element.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w4">
              <code>const_reverse_iterator</code>
            </a>
          </td>
          <td>
Const iterator used to iterate backwards through a circular buffer.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w5">
              <code>difference_type</code>
            </a>
          </td>
          <td>
Distance type.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w6">
              <code>iterator</code>
            </a>
          </td>
          <td>
Iterator (random access) used to iterate through a circular buffer.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w8">
              <code>pointer</code>
            </a>
          </td>
          <td>
Pointer to the element.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w9">
              <code>reference</code>
            </a>
          </td>
          <td>
Reference to the element.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w11">
              <code>reverse_iterator</code>
            </a>
          </td>
          <td>
Iterator used to iterate backwards through a circular buffer.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w12">
              <code>size_type</code>
            </a>
          </td>
          <td>
Size type.         </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1w13">
              <code>value_type</code>
            </a>
          </td>
          <td>
The type of the elements stored in the circular buffer.         </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="constructors">Constructors &amp; Destructor</a>
    </h2>
    <div id="srcdoc_constructors">
      <table id="table_constructors" border="1">
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a9"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;InputIterator&gt;<br>&nbsp;&nbsp;&nbsp;
    circular_buffer(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;capacity, <br>&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;InputIterator&nbsp;first, InputIterator&nbsp;last, <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;const&nbsp;<A href="#classboost_1_1circular__buffer_1w0">allocator_type</A>&amp;&nbsp;alloc =     allocator_type());</b>
            </code>
            <br>
            <table id="table_function_desc_id4487493">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4487613"><tr><td>
Create a circular buffer with a copy of a range.         </td></tr></table>
<table id="table_pre_desc_id4487624"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid range <code>[first, last)</code>. </td>
</tr></table>
<table id="table_post_desc_id4487634"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a8">capacity()</A> == capacity</code><br>
 If the number of items to copy from the range <code>[first, last)</code> is greater than the specified <code>capacity</code> then only elements from the range <code>[last - capacity, last)</code> will be copied. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a10"></a>
            <code>
              <b>circular_buffer(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;cb);</b>
            </code>
            <br>
            <table id="table_function_desc_id4487832">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4487885"><tr><td>
Copy constructor.         </td></tr></table>
<table id="table_post_desc_id4487895"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>*this ==      cb</code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a11"></a>
            <code>
              <b>circular_buffer(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;capacity, <br>&nbsp;&nbsp;&nbsp;
      <A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item, const&nbsp;<A href="#classboost_1_1circular__buffer_1w0">allocator_type</A>&amp;&nbsp;alloc =     allocator_type());</b>
            </code>
            <br>
            <table id="table_function_desc_id4488084">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4488182"><tr><td>
Create a full circular buffer with a given capacity and filled with copies of <code>item</code>.         </td></tr></table>
<table id="table_post_desc_id4488197"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A>
                  == capacity &amp;&amp; (*this)[0] ==   (*this)[1] == ... ==   (*this).<A href="#classboost_1_1circular__buffer_1a5">back()</A> == item</code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a12"></a>
            <code>
              <b>explicit circular_buffer(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;capacity, const&nbsp;<A href="#classboost_1_1circular__buffer_1w0">allocator_type</A>&amp;&nbsp;alloc =     allocator_type());</b>
            </code>
            <br>
            <table id="table_function_desc_id4488391">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4488472"><tr><td>
Create an empty circular buffer with a given capacity.         </td></tr></table>
<table id="table_post_desc_id4488483"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a8">capacity()</A> == capacity &amp;&amp; (*this).size == 0</code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a51"></a>
            <code>
              <b>~circular_buffer();</b>
            </code>
            <br>
            <table id="table_function_desc_id4496222">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4496257"><tr><td>
Destructor.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="methods">Public Member Functions</a>
    </h2>
    <div id="srcdoc_methods">
      <table id="table_methods" border="1">
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a0"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;InputIterator&gt;<br>&nbsp;&nbsp;&nbsp;
      void&nbsp;assign(InputIterator&nbsp;first, InputIterator&nbsp;last);</b>
            </code>
            <br>
            <table id="table_function_desc_id4485728">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4485807"><tr><td>
Assign a copy of range.         </td></tr></table>
<table id="table_pre_desc_id4485817"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid range <code>[first, last)</code>. </td>
</tr></table>
<table id="table_post_desc_id4485827"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> == std::distance(first, last)</code><br>
 If the number of items to be assigned exceeds the capacity of the circular buffer the capacity is set to that number otherwise is stays unchanged. </td>
</tr></table>
<table id="table_note_desc_id4485892"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a1"></a>
            <code>
              <b>void&nbsp;assign(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;n, <A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4485937">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4486011"><tr><td>
Assign <code>n</code> items into the circular buffer.         </td></tr></table>
<table id="table_post_desc_id4486024"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> == n &amp;&amp; (*this)[0] ==                 (*this)[1] == ... == (*this).<A href="#classboost_1_1circular__buffer_1a5">back()</A> == item</code><br>
 If the number of items to be assigned exceeds the capacity of the circular buffer the capacity is increased to <code>n</code> otherwise it stays unchanged. </td>
</tr></table>
<table id="table_note_desc_id4486100"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a2"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;at(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;index) const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4486169">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4486226"><tr><td>
Return the element at the <code>index</code> position.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a3"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w9">reference</A>&nbsp;at(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;index);</b>
            </code>
            <br>
            <table id="table_function_desc_id4486297">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4486353"><tr><td>
Return the element at the <code>index</code> position.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a4"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;back() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4486424">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4486465"><tr><td>
Return the last (rightmost) element.         </td></tr></table>
<table id="table_pre_desc_id4486475"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>!*(this).<A href="#classboost_1_1circular__buffer_1a15">empty()</A></code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a5"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w9">reference</A>&nbsp;back();</b>
            </code>
            <br>
            <table id="table_function_desc_id4486557">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4486597"><tr><td>
Return the last (rightmost) element.         </td></tr></table>
<table id="table_pre_desc_id4486608"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>!*(this).<A href="#classboost_1_1circular__buffer_1a15">empty()</A></code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a6"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w1">const_iterator</A>&nbsp;begin() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4486689">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4486729"><tr><td>
Return a const iterator pointing to the beginning of the circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a7"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;begin();</b>
            </code>
            <br>
            <table id="table_function_desc_id4486781">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4486821"><tr><td>
Return an iterator pointing to the beginning of the circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a8"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;capacity() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4487262">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4487307"><tr><td>
Return the capacity of the circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a13"></a>
            <code>
              <b>void&nbsp;clear();</b>
            </code>
            <br>
            <table id="table_function_desc_id4488625">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4488665"><tr><td>
Erase all the stored elements.         </td></tr></table>
<table id="table_post_desc_id4488676"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>(*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> == 0 </td>
</tr></table>
<table id="table_note_desc_id4488691"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a14"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w8">pointer</A>&nbsp;data();</b>
            </code>
            <br>
            <table id="table_function_desc_id4488782">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4488823"><tr><td>
Return pointer to data stored in the circular buffer as a continuous array of values.         </td></tr></table>
<table id="table_detailed_desc_id4488833"><tr><td>This method can be useful e.g. when passing the stored data into the legacy C API.



</td></tr></table>
<table id="table_post_desc_id4488836"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>&amp;(*this)[0] &lt; &amp;(*this)[1] &lt; ... &lt; &amp;(*this).<A href="#classboost_1_1circular__buffer_1a5">back()</A></code> </td>
</tr></table>
<table id="table_return_desc_id4488854"><tr>
<td valign="top"><b>Returns:</b></td>
<td>0 if empty. </td>
</tr></table>
<table id="table_note_desc_id4488897"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a15"></a>
            <code>
              <b>bool&nbsp;empty() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4489118">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4489153"><tr><td>
Is the circular buffer empty?         </td></tr></table>
<table id="table_return_desc_id4489163"><tr>
<td valign="top"><b>Returns:</b></td>
<td>
<code>true</code> if there are no elements stored in the circular buffer. <code>false</code> otherwise. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a16"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w1">const_iterator</A>&nbsp;end() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4489328">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4489369"><tr><td>
Return a const iterator pointing to the end of the circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a17"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;end();</b>
            </code>
            <br>
            <table id="table_function_desc_id4489396">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4489436"><tr><td>
Return an iterator pointing to the end of the circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a18"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;erase(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;first, <A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;last);</b>
            </code>
            <br>
            <table id="table_function_desc_id4489571">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4489651"><tr><td>
Erase the range <code>[first, last)</code>.         </td></tr></table>
<table id="table_pre_desc_id4489664"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid range <code>[first, last)</code>. <code>size_type old_size = (*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A></code> </td>
</tr></table>
<table id="table_post_desc_id4489687"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> == old_size - std::distance(first, last)</code><br>
 Removes the elements from the range <code>[first, last)</code>. </td>
</tr></table>
<table id="table_return_desc_id4489710"><tr>
<td valign="top"><b>Returns:</b></td>
<td>iterator to the first element remaining beyond the removed element or <code>(*this).<A href="#classboost_1_1circular__buffer_1a17">end()</A></code> if no such element exists. </td>
</tr></table>
<table id="table_note_desc_id4489730"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a19"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;erase(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos);</b>
            </code>
            <br>
            <table id="table_function_desc_id4489852">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4489915"><tr><td>
Erase the element at the given position.         </td></tr></table>
<table id="table_pre_desc_id4489926"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid <code>pos</code> iterator. <code>size_type old_size = (*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A></code> </td>
</tr></table>
<table id="table_post_desc_id4489948"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> == old_size - 1</code><br>
 Removes an element at the position <code>pos</code>. </td>
</tr></table>
<table id="table_return_desc_id4489971"><tr>
<td valign="top"><b>Returns:</b></td>
<td>iterator to the first element remaining beyond the removed element or <code>(*this).<A href="#classboost_1_1circular__buffer_1a17">end()</A></code> if no such element exists. </td>
</tr></table>
<table id="table_note_desc_id4489990"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a20"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;front() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4490138">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4490180"><tr><td>
Return the first (leftmost) element.         </td></tr></table>
<table id="table_pre_desc_id4490190"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>!*(this).<A href="#classboost_1_1circular__buffer_1a15">empty()</A></code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a21"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w9">reference</A>&nbsp;front();</b>
            </code>
            <br>
            <table id="table_function_desc_id4490248">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4490288"><tr><td>
Return the first (leftmost) element.         </td></tr></table>
<table id="table_pre_desc_id4490299"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>!*(this).<A href="#classboost_1_1circular__buffer_1a15">empty()</A></code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a22"></a>
            <code>
              <b>bool&nbsp;full() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4490357">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4490398"><tr><td>
Is the circular buffer full?         </td></tr></table>
<table id="table_return_desc_id4490408"><tr>
<td valign="top"><b>Returns:</b></td>
<td>
<code>true</code> if the number of elements stored in the circular buffer equals the capacity of the circular buffer. <code>false</code> otherwise. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a23"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w0">allocator_type</A>&amp;&nbsp;get_allocator();</b>
            </code>
            <br>
            <table id="table_function_desc_id4490533">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4490576"><tr><td>
Return the allocator.         </td></tr></table>
<table id="table_note_desc_id4490586"><tr>
<td valign="top"><b>Note:</b></td>
<td>This method was added in order to optimize obtaining of the allocator with a state, although use of stateful allocators in STL is discouraged. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a24"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w0">allocator_type</A>&nbsp;get_allocator() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4490624">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4490665"><tr><td>
Return the allocator.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a25"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;InputIterator&gt;<br>&nbsp;&nbsp;&nbsp;
    void&nbsp;insert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos,
      InputIterator&nbsp;first, InputIterator&nbsp;last);</b>
            </code>
            <br>
            <table id="table_function_desc_id4490716">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4490811"><tr><td>
Insert the range <code>[first, last)</code> before the given position.         </td></tr></table>
<table id="table_pre_desc_id4490825"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid <code>pos</code> iterator and valid range <code>[first, last)</code>. </td>
</tr></table>
<table id="table_post_desc_id4490839"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the beginning (left) of the circular buffer will be removed or not the whole range will be inserted or both. In case the whole range cannot be inserted it will be inserted just some elements from the end (right) of the range (see the example).<code><br>
 Example:<br>
 array to insert: int array[] = { 5, 6, 7, 8, 9 };<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, array, array + 5);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|5|6|7|8|9|3|4|)<br>
 RESULTING circular buffer |6|7|8|9|3|4| - capacity: 6, size: 6</code> </td>
</tr></table>
<table id="table_note_desc_id4490915"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a26"></a>
            <code>
              <b>void&nbsp;insert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos, <A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;n, <A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4490960">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4491050"><tr><td>
Insert <code>n</code> copies of the item before the given position.         </td></tr></table>
<table id="table_pre_desc_id4491064"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid <code>pos</code> iterator. </td>
</tr></table>
<table id="table_post_desc_id4491074"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the beginning (left) of the circular buffer will be removed or not all <code>n</code> elements will be inserted or both.<code><br>
 Example:<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, (size_t)5, 6);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|6|6|6|6|6|3|4|)<br>
 RESULTING circular buffer |6|6|6|6|3|4| - capacity: 6, size: 6</code> </td>
</tr></table>
<table id="table_note_desc_id4491148"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a27"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;insert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos);</b>
            </code>
            <br>
            <table id="table_function_desc_id4491220">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4491283"><tr><td>
Insert a new element with the default value before the given position.         </td></tr></table>
<table id="table_post_desc_id4491294"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code><A href="#classboost_1_1circular__buffer_1w13">value_type()</A></code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the first (leftmost) element will be removed. </td>
</tr></table>
<table id="table_return_desc_id4491317"><tr>
<td valign="top"><b>Returns:</b></td>
<td>iterator to the inserted element. </td>
</tr></table>
<table id="table_note_desc_id4491361"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a28"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;insert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos, <A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4491405">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4491485"><tr><td>
Insert the <code>item</code> before the given position.         </td></tr></table>
<table id="table_pre_desc_id4491499"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid <code>pos</code> iterator. </td>
</tr></table>
<table id="table_post_desc_id4491509"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>The <code>item</code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the first (leftmost) element will be removed. </td>
</tr></table>
<table id="table_return_desc_id4491526"><tr>
<td valign="top"><b>Returns:</b></td>
<td>iterator to the inserted element. </td>
</tr></table>
<table id="table_note_desc_id4491570"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a29"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;max_size() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4491767">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4491807"><tr><td>
Return the largest possible size (or capacity) of the circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a30"></a>
            <code>
              <b>circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;operator=(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;cb);</b>
            </code>
            <br>
            <table id="table_function_desc_id4491859">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4491921"><tr><td>
Assignment operator.         </td></tr></table>
<table id="table_post_desc_id4491932"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>*this ==      cb</code> </td>
</tr></table>
<table id="table_note_desc_id4491981"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a31"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;operator[](<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;index) const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4492132">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4492196"><tr><td>
Return the element at the <code>index</code> position.         </td></tr></table>
<table id="table_pre_desc_id4492210"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>*(this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> &gt; index</code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a32"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w9">reference</A>&nbsp;operator[](<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;index);</b>
            </code>
            <br>
            <table id="table_function_desc_id4492284">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4492347"><tr><td>
Return the element at the <code>index</code> position.         </td></tr></table>
<table id="table_pre_desc_id4492361"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>*(this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> &gt; index</code> </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a33"></a>
            <code>
              <b>void&nbsp;pop_back();</b>
            </code>
            <br>
            <table id="table_function_desc_id4492435">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4492475"><tr><td>
Remove the last (rightmost) element.         </td></tr></table>
<table id="table_pre_desc_id4492486"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>!*(this).<A href="#classboost_1_1circular__buffer_1a15">empty()</A></code> <code>iterator it = ((*this).<A href="#classboost_1_1circular__buffer_1a17">end()</A> - 1)</code> </td>
</tr></table>
<table id="table_post_desc_id4492515"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>((*this).<A href="#classboost_1_1circular__buffer_1a17">end()</A> - 1) != it</code> </td>
</tr></table>
<table id="table_note_desc_id4492533"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a34"></a>
            <code>
              <b>void&nbsp;pop_front();</b>
            </code>
            <br>
            <table id="table_function_desc_id4492628">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4492668"><tr><td>
Remove the first (leftmost) element.         </td></tr></table>
<table id="table_pre_desc_id4492679"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>!*(this).<A href="#classboost_1_1circular__buffer_1a15">empty()</A></code> <code>iterator it = (*this).<A href="#classboost_1_1circular__buffer_1a7">begin()</A></code> </td>
</tr></table>
<table id="table_post_desc_id4492707"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a7">begin()</A> != it</code> </td>
</tr></table>
<table id="table_note_desc_id4492724"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a35"></a>
            <code>
              <b>void&nbsp;push_back();</b>
            </code>
            <br>
            <table id="table_function_desc_id4492819">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4492860"><tr><td>
Insert a new element with the default value at the end.         </td></tr></table>
<table id="table_post_desc_id4492870"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a5">back()</A> == <A href="#classboost_1_1circular__buffer_1w13">value_type()</A></code><br>
 If the circular buffer is full, the first (leftmost) element will be removed. </td>
</tr></table>
<table id="table_note_desc_id4492918"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a36"></a>
            <code>
              <b>void&nbsp;push_back(<A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4492950">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493007"><tr><td>
Insert a new element at the end.         </td></tr></table>
<table id="table_post_desc_id4493018"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a5">back()</A> == item</code><br>
 If the circular buffer is full, the first (leftmost) element will be removed. </td>
</tr></table>
<table id="table_note_desc_id4493058"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a37"></a>
            <code>
              <b>void&nbsp;push_front();</b>
            </code>
            <br>
            <table id="table_function_desc_id4493188">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493228"><tr><td>
Insert a new element with the default value at the start.         </td></tr></table>
<table id="table_post_desc_id4493239"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a21">front()</A> == <A href="#classboost_1_1circular__buffer_1w13">value_type()</A></code><br>
 If the circular buffer is full, the last (rightmost) element will be removed. </td>
</tr></table>
<table id="table_note_desc_id4493287"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a38"></a>
            <code>
              <b>void&nbsp;push_front(<A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4493319">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493376"><tr><td>
Insert a new element at the start.         </td></tr></table>
<table id="table_post_desc_id4493386"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a21">front()</A> == item</code><br>
 If the circular buffer is full, the last (rightmost) element will be removed. </td>
</tr></table>
<table id="table_note_desc_id4493426"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a39"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w4">const_reverse_iterator</A>&nbsp;rbegin() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4493570">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493612"><tr><td>
Return a const reverse iterator pointing to the beginning of the reversed circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a40"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w11">reverse_iterator</A>&nbsp;rbegin();</b>
            </code>
            <br>
            <table id="table_function_desc_id4493652">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493692"><tr><td>
Return a reverse iterator pointing to the beginning of the reversed circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a41"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w4">const_reverse_iterator</A>&nbsp;rend() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4493732">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493773"><tr><td>
Return a const reverse iterator pointing to the end of the reversed circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a42"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w11">reverse_iterator</A>&nbsp;rend();</b>
            </code>
            <br>
            <table id="table_function_desc_id4493814">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493854"><tr><td>
Return a reverse iterator pointing to the end of the reversed circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a43"></a>
            <code>
              <b>void&nbsp;resize(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;new_size, <A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item = T(), bool&nbsp;remove_front = true);</b>
            </code>
            <br>
            <table id="table_function_desc_id4493894">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4493985"><tr><td>
Change the size of the circular buffer.         </td></tr></table>
<table id="table_post_desc_id4494058"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> == new_size</code><br>
 If the new size is greater than the current size, the rest of the circular buffer is filled with copies of <code>item</code>. In case the resulting size exceeds the current capacity the capacity is set to <code>new_size</code>. If the new size is lower than the current size then <code>((*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> - new_size)</code> elements will be removed according to the <code>remove_front</code> parameter. </td>
</tr></table>
<table id="table_note_desc_id4494146"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a44"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;InputIterator&gt;<br>&nbsp;&nbsp;&nbsp;
    void&nbsp;rinsert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos,
      InputIterator&nbsp;first, InputIterator&nbsp;last);</b>
            </code>
            <br>
            <table id="table_function_desc_id4494270">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4494365"><tr><td>
Insert the range <code>[first, last)</code> before the given position.         </td></tr></table>
<table id="table_pre_desc_id4494379"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid <code>pos</code> iterator and valid range <code>[first, last)</code>. </td>
</tr></table>
<table id="table_post_desc_id4494393"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the end (right) of the circular buffer will be removed or not the whole range will be inserted or both. In case the whole range cannot be inserted it will be inserted just some elements from the beginning (left) of the range (see the example).<code><br>
 Example:<br>
 array to insert: int array[] = { 5, 6, 7, 8, 9 };<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, array, array + 5);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|5|6|7|8|9|3|4|)<br>
 RESULTING circular buffer |1|2|5|6|7|8| - capacity: 6, size: 6</code> </td>
</tr></table>
<table id="table_note_desc_id4494470"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a45"></a>
            <code>
              <b>void&nbsp;rinsert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos, <A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;n, <A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4494514">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4494604"><tr><td>
Insert <code>n</code> copies of the item before the given position.         </td></tr></table>
<table id="table_pre_desc_id4494618"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid <code>pos</code> iterator. </td>
</tr></table>
<table id="table_post_desc_id4494628"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the end (right) of the circular buffer will be removed or not all <code>n</code> elements will be inserted or both.<code><br>
 Example:<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, (size_t)5, 6);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|6|6|6|6|6|3|4|)<br>
 RESULTING circular buffer |1|2|6|6|6|6| - capacity: 6, size: 6</code> </td>
</tr></table>
<table id="table_note_desc_id4494702"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a46"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;rinsert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos);</b>
            </code>
            <br>
            <table id="table_function_desc_id4494749">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4494811"><tr><td>
Insert a new element with the default value before the given position.         </td></tr></table>
<table id="table_post_desc_id4494822"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code><A href="#classboost_1_1circular__buffer_1w13">value_type()</A></code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the last (rightmost) element will be removed. </td>
</tr></table>
<table id="table_return_desc_id4494844"><tr>
<td valign="top"><b>Returns:</b></td>
<td>iterator to the inserted element. </td>
</tr></table>
<table id="table_note_desc_id4494888"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a47"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;rinsert(<A href="#classboost_1_1circular__buffer_1w6">iterator</A>&nbsp;pos, <A href="#classboost_1_1circular__buffer_1w13">value_type</A>&nbsp;item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4494932">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4495012"><tr><td>
Insert an <code>item</code> before the given position.         </td></tr></table>
<table id="table_pre_desc_id4495026"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>Valid <code>pos</code> iterator. </td>
</tr></table>
<table id="table_post_desc_id4495036"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>The <code>item</code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the last element (rightmost) will be removed. </td>
</tr></table>
<table id="table_return_desc_id4495054"><tr>
<td valign="top"><b>Returns:</b></td>
<td>iterator to the inserted element. </td>
</tr></table>
<table id="table_note_desc_id4495097"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a48"></a>
            <code>
              <b>void&nbsp;set_capacity(<A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;new_capacity, bool&nbsp;remove_front = true);</b>
            </code>
            <br>
            <table id="table_function_desc_id4495308">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4495380"><tr><td>
Change the capacity of the circular buffer.         </td></tr></table>
<table id="table_post_desc_id4495437"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<A href="#classboost_1_1circular__buffer_1a8">capacity()</A> == new_capacity</code><br>
 If the current number of elements stored in the circular buffer is greater than the desired new capacity then <code>((*this).<A href="#classboost_1_1circular__buffer_1a49">size()</A> - new_capacity)</code> elements will be removed according to the <code>remove_front</code> parameter. </td>
</tr></table>
<table id="table_note_desc_id4495516"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a49"></a>
            <code>
              <b><A href="#classboost_1_1circular__buffer_1w12">size_type</A>&nbsp;size() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4495733">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4495773"><tr><td>
Return the number of elements currently stored in the circular buffer.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer_1a50"></a>
            <code>
              <b>void&nbsp;swap(circular_buffer&amp;&nbsp;cb);</b>
            </code>
            <br>
            <table id="table_function_desc_id4496037">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4496088"><tr><td>
Swap the contents of two circular buffers.         </td></tr></table>
<table id="table_post_desc_id4496099"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>this</code> contains elements of <code>cb</code> and vice versa. </td>
</tr></table>
<table id="table_note_desc_id4496112"><tr>
<td valign="top"><b>Note:</b></td>
<td>For iterator invalidation see the <A href="../circular_buffer.html#invalidation">documentation</A>. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="functions">Standalone Functions</a>
    </h2>
    <div id="srcdoc_functions">
      <table id="table_functions" border="1">
        <tr>
          <td>
            <a name="namespaceboost_1a9"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;<br>&nbsp;&nbsp;&nbsp;
      bool&nbsp;operator!=(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);</b>
            </code>
            <br>
            <table id="table_function_desc_id4484748">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4481599"><tr><td>
Test two circular buffers for non-equality.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="namespaceboost_1a8"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;<br>&nbsp;&nbsp;&nbsp;
      bool&nbsp;operator&lt;(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);</b>
            </code>
            <br>
            <table id="table_function_desc_id4481779">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4505971"><tr><td>
Lexicographical comparison.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="namespaceboost_1a11"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;<br>&nbsp;&nbsp;&nbsp;
      bool&nbsp;operator&lt;=(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);</b>
            </code>
            <br>
            <table id="table_function_desc_id4506151">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4506255"><tr><td>
Lexicographical comparison.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="namespaceboost_1a7"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;<br>&nbsp;&nbsp;&nbsp;
      bool&nbsp;operator==(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);</b>
            </code>
            <br>
            <table id="table_function_desc_id4506434">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4506538"><tr><td>
Test two circular buffers for equality.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="namespaceboost_1a10"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;<br>&nbsp;&nbsp;&nbsp;
      bool&nbsp;operator&gt;(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);</b>
            </code>
            <br>
            <table id="table_function_desc_id4506717">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4506821"><tr><td>
Lexicographical comparison.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="namespaceboost_1a12"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;<br>&nbsp;&nbsp;&nbsp;
      bool&nbsp;operator&gt;=(const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, const&nbsp;circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);</b>
            </code>
            <br>
            <table id="table_function_desc_id4507001">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4507104"><tr><td>
Lexicographical comparison.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="namespaceboost_1a13"></a>
            <code>
              <b>
      template&nbsp;&lt;class&nbsp;T, class&nbsp;Alloc&gt;<br>&nbsp;&nbsp;&nbsp;
      void&nbsp;swap(circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;lhs, circular_buffer&lt;T,Alloc&gt;&amp;&nbsp;rhs);</b>
            </code>
            <br>
            <table id="table_function_desc_id4507284">
              <tr>
                <td>&nbsp;&nbsp;&nbsp;</td>
                <td>
<table id="table_detailed_desc_id4507384"><tr><td>
Swap the contents of two circular buffers.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="semantics">Semantics</a>
    </h2>
    <p>The behaviour of insertion for <code>circular_buffer</code> is as follows:
        </p>
    <ul>
<li>
                The capacity of a <code>circular_buffer</code> remains fixed unless adjusted
                via <code>set_capacity</code> or <code>resize</code>.

<li>
                <code>insert</code> will
  overwrite front elements as necessary.

<li>
                <code>rinsert</code> will overwrite back elements as necessary.
            </li>
        </ul>
    <p>The behaviour of resizing a <code>circular_buffer</code> is as follows:
        </p>
    <ul>
<li>
                The capacity will be adjusted to accommodate a <code>resize</code>. (The
                capacity can be only increased, not decreased.)
            </li>
        </ul>
    <p>The behaviour of assigning to a <code>circular_buffer</code> is as follows:
        </p>
    <ul>
<li>
                The capacity will be adjusted to accommodate an <code>assign</code>. (The
                capacity can be only increased, not decreased.)
            </li>
        </ul>
    <p><a name="invalidation"></a>The rules for iterator (and result of <code>data()</code>)
            invalidation for <code>circular_buffer</code> are as follows:
        </p>
    <ul>
<li>
                <code>insert</code> at the end of the <code>circular_buffer</code> (including <code>
                    push_back</code>) does not invalidate any iterator except
  the case the iterator points to the overwritten element.

<li>
                <code>rinsert</code> at the beginning of the <code>circular_buffer</code> (including
                <code>push_front</code>) does not invalidate any iterator
  except the case the iterator points to the overwritten element.

<li>
                <code>insert</code> in the middle of the <code>circular_buffer</code> invalidates
  iterators pointing to the elements at the insertion point and behind the
  insertion point. It also invalidates iterators pointing to the overwritten
  element(s).

<li>
                <code>rinsert</code> in the middle of the <code>circular_buffer</code> invalidates
  iterators pointing to the elements before the insertion point and iterators
  pointing to the overwritten element(s).

<li>
                <code>erase</code> at the end of the <code>circular_buffer</code> (including <code>pop_back</code>) invalidates only iterators pointing to
  the erased element(s).

<li>
                <code>pop_front</code>
  invalidates only iterators pointing to the erased element.

<li>
                <code>erase</code> at the beginning or in the middle of the <code>circular_buffer</code> invalidates iterators pointing to
  the erased element(s) and iterators pointing to the elements behind the erase
  point.

<li>
                <code>data</code>, <code>set_capacity</code>, <code>resize</code>, <code>operator=</code>,
                <code>assign</code>, <code>swap</code> and <code>clear</code> invalidate all
                iterators pointing to the <code>circular_buffer</code>.
            </li>
        </ul>
    <p>In addition to the preceding rules the iterators get also invalidated due to
            overwritting (e.g. iterator pointing to the front-most element gets invalidated
            when inserting into the full <code>circular_buffer</code>). They get
            invalidated in that sense they do not point to the same element as before but
            they do still point to the same <b>valid</b> place in the memory. If you want
            to rely on this feature you have to turn of the <A href="#debug">Debug Support</A>
            otherwise an assertion will report an error if such invalidated iterator is used.</p>
    <h2>
      <a name="caveats">Caveats</a>
    </h2>
    <p>The <code>circular_buffer</code> should not be used for storing pointers to
            dynamically allocated objects. When a <code>circular_buffer</code> becomes
            full, further insertion will overwrite the stored pointers - resulting in a <b>memory
                leak</b>. One recommend alternative is the use of smart pointers <A href="#1">[1]</A>.
            (Any container of <code>std::auto_ptr</code> is considered particularly
            hazardous. <A href="#2">[2]</A>)
        </p>
    <p>Elements inserted near the front of a full <code>circular_buffer</code> can be
            lost. According to the <A href="#semantics">semantics</A> of <code>insert</code>,
            insertion overwrites front-most items as necessary - possibly including
            elements currently being <b>inserted at the front</b> of the buffer.
            Conversely, <code>push_front</code> to a full <code>circular_buffer</code> is
            guaranteed to overwrite the back-most element.
        </p>
    <p>Elements inserted near the back of a full <code>circular_buffer</code> can be
            lost. According to the <A href="#semantics">semantics</A> of <code>rinsert</code>,
            insertion overwrites front-most items as necessary - possibly including
            elements currently being <b>inserted at the back</b> of the buffer. Conversely, <code>
                push_back</code> to a full <code>circular_buffer</code> is guaranteed to
            overwrite the front-most element.
        </p>
    <p>While internals of a <code>circular_buffer</code> are circular, iterators are <b>not</b>.
            Iterators of a <code>circular_buffer</code> are only valid for the range <code>[begin(),
                end()]</code>. E.g. iterators <code>(begin() - 1)</code> and <code>(end() + 1)</code>
            are invalid.
        </p>
    <h2>
      <a name="debug">Debug Support</a>
    </h2>
    <p>In order to help a programmer to avoid and find common bugs, the <code>circular_buffer</code>
            contains a kind of debug support.</p>
    <p>
            The <code>circular_buffer</code> maintains a list of valid iterators. As soon
            as any element gets destroyed all iterators pointing to this element are
            removed from this list and explicitly invalidated (an invalidation flag is
            set). The debug support also consists of many assertions (<a href="../../../libs/utility/assert.html"><code>BOOST_ASSERT</code></a>
            macros) which ensure the <code>circular_buffer</code> and its iterators are
            used in the correct manner at runtime. In case an invalid iterator is used the
            assertion will report an error. The connection of explicit iterator
            invalidation and assertions makes a very robust debug technique which catches
            most of the errors.</p>
    <p>Moreover, the uninitialized memory allocated by <code>circular_buffer</code> is
            filled with the value <code>0xcc</code> in the debug mode. This can help the
            programmer when debugging the code to recognize the initialized memory from the
            uninitialized. For details refer the <A href="../../../boost/circular_buffer/base.hpp">
                source code</A>.
        </p>
    <p>The debug support is enabled only in the debug mode (when the <code>NDEBUG</code>
            is not defined). It can also be explicitly disabled by defining <code>BOOST_DISABLE_CB_DEBUG</code>
            macro.</p>
    <h2>
      <a name="example">Example</a>
    </h2>
    <p>The following example includes various usage of the <code>circular_buffer</code>.
        </p>
    <pre>   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;numeric&gt;
   #include &lt;assert.h&gt;

   int main(int argc, char* argv[])
   {
      // create a circular buffer of capacity 3
      boost::circular_buffer&lt;int&gt; cb(3);

      // insert some elements into the circular buffer
      cb.push_back(1);
      cb.push_back(2);

      // assertions
      assert(cb[0] == 1);
      assert(cb[1] == 2);
      assert(!cb.full());
      assert(cb.size() == 2);
      assert(cb.capacity() == 3);

      // insert some other elements
      cb.push_back(3);
      cb.push_back(4);

      // evaluate the sum
      int sum = std::accumulate(cb.begin(), cb.end(), 0);

      // assertions
      assert(cb[0] == 2);
      assert(cb[1] == 3);
      assert(cb[2] == 4);
      assert(sum == 9);
      assert(cb.full());
      assert(cb.size() == 3);
      assert(cb.capacity() == 3);

      return 0;
   }
</pre>
    <p>The <code>circular_buffer</code> has a capacity of three <code>int</code>.
            Therefore, the size of the buffer will not exceed three. The <code><a href="http://www.sgi.com/tech/stl/accumulate.html">
                    accumulate</a></code> algorithm evaluates the sum of the stored
            elements. The semantics of the <code>circular_buffer</code> can be inferred from
            the assertions.
        </p>
    <h2>
      <a name="notes">Notes</a>
    </h2>
    <p><a name="1">[1]</a> A good implementation of smart pointers is included in <a href="../../../libs/smart_ptr/">
                Boost</a>.
        </p>
    <p><a name="2">[2]</a> Never create a circular buffer of <code>std::auto_ptr</code>.
            Refer to <a href="http://www.aristeia.com">Scott Meyers</a>' excellent book <em>Effective
                STL</em> for a detailed discussion. (Meyers S., <i>Effective STL: 50 Specific
                Ways to Improve Your Use of the Standard Template Library</i>.
            Addison-Wesley, 2001.)
        </p>
    <h2>
      <a name="see">See also</a>
    </h2>
    <p><code><A href="circular_buffer_space_optimized.html">boost::circular_buffer_space_optimized</A>,
                <a href="http://www.sgi.com/tech/stl/Vector.html">std::vector</a>, <a href="http://www.sgi.com/tech/stl/List.html">
                    std::list</a>, <a href="http://www.sgi.com/tech/stl/Deque.html">std::deque</a></code>
        </p>
    <h2><A name="ideas">Ideas for Future Improvements</A>
    </h2>
    <p>The formal review revealed that the library is lack of adaptors which would provide additional
functionality. Yes, there is the <code>circular_buffer_space_optimized</code> adaptor, but it is
the only one. Particularly it would be nice to have an adaptor (of the base container and also it's space optimized
version) that would provide "hooks" - callback methods - which would be invoked when an element is
about to be overwritten optionally when the buffer is about to underflow. The callbacks can be then used
e.g. for invoking some method on the element being overwritten or for throwing an underflow/overflow
exception.
</p>
<h2><a name="ack">Acknowledgments</a></h2>
    <p>The <code>circular_buffer</code> has a short history. Its first version was a <code>std::deque</code> adaptor. This container was not very
effective because of many reallocations when inserting/removing an element.
Thomas Wenish did a review of this version and motivated me to create a circular
buffer which allocates memory at once when created.</p>
    <p>The second version adapted <code>std::vector</code> but it has been abandoned
            soon because of limited control over iterator invalidation.</p>
    <p>The current version is
            a full-fledged STL compliant container. Pavel Vozenilek did a thorough review of this version
            and came with many good ideas and improvements. Also, I would like to
            thank Howard Hinnant, Nigel Stewart and everyone who participated at the formal review for valuable
            comments and ideas.
        </p>
    <hr align="left" size="1">
    <table id="footer" border="0" width="100%">
      <tr>
<td align="left" valign="top"><small>Copyright  2003-2005 <A href="mailto:jano_gaspar%5Bat%5Dyahoo.com">Jan Gaspar</A></small></td>
        <td align="right" valign="top">
          <a href="http://validator.w3.org/check?url=http://www.boost.org/libs/circular_buffer/doc/circular_buffer.html">
            <IMG height=31 alt="Valid HTML 4.0!" src ="valid-html40.png" width=88 border=0 ></a>
        </td>
      </tr>
    </table>
  </body>
</html>
