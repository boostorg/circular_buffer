<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title>
      Templated Circular Buffer Container
    </title>
  </head>
  <body>
    <table id="title" border="0">
      <tr>
        <td>
          <h1>
            Templated Circular Buffer Container
          </h1>
          <h1>
            circular_buffer&lt;T, Alloc&gt;
          </h1>
        </td>
        <td>
          <a href="../../../"><img src="../../../boost.png" width="277" height="86" border="0" alt="Boost"></a>
        </td>
      </tr>
    </table>
    <h2>
      Contents
    </h2><a href="#description">Description</a><br>
    <a href="#briefexample">Introductory Example</a><br>
    <a href="#synopsis">Synopsis</a><br>
    <a href="#rationale">Rationale</a><br>
    <a href="#header">Header Files</a><br>
    <a href="#model">Modeled Concepts</a><br>
    <a href="#parameters">Template Parameters</a><br>
    <a href="#types">Public Types</a><br>
    <a href="#constructors">Constructors and Destructor</a><br>
    <a href="#methods">Public Member Functions</a><br>
    <a href="#functions">Standalone Functions</a><br>
    <a href="#semantics">Semantics</a><br>
    <a href="#caveats">Caveats</a><br>
    <a href="#debug">Debug Support</a><br>
    <a href="#examples">More Examples</a><br>
    <a href="#notes">Notes</a><br>
    <a href="#see">See also</a><br>
    <a href="#ack">Acknowledgments</a><br>
    <table id="table_figure" align="right" border="0">
      <tr>
        <td>
          <img src="circular_buffer.png" width="300" height="332" alt="Circular Buffer">
        </td>
      </tr>
      <tr>
        <td width="300">
          <table id="table_figure_desc" cellpadding="5" align="right" border="0">
            <tr>
              <td valign="top">
                <b>Figure:</b>
              </td>
              <td valign="top">
                The circular buffer (for someone known as <i>ring</i> or <i>cyclic buffer</i>).
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </table><br>
    <h2>
      <a name="description" id="description">Description</a>
    </h2>
    <p>
      In general the term <i>circular buffer</i> refers to an area in memory which is used to store incoming data. When
      the buffer is filled, new data is written starting at the beginning of the buffer and overwriting the old.
      <a href="#note1">[1]</a> (Also see the Figure.)
    </p>
    <p>
      The <code>circular_buffer</code> is a STL compliant container. It is a kind of sequence similar to
      <code>std::vector</code> or <code>std::deque</code>. It supports random access iterators, constant time insert
      and erase operations at the beginning or the end of the buffer and interoperability with <code>std</code>
      algorithms. The <code>circular_buffer</code> is especially designed to provide fixed capacity storage. When its
      capacity is exhausted, newly inserted elements will cause elements either at the beginning or end of the buffer
      (depending on what insert operation is used) to be overwritten.
    </p>
    <p>
      The <code>circular_buffer</code> only allocates memory when created, when the capacity is adjusted explicitly, or
      as necessary to accommodate resizing or assign operations. On the other hand, there is also a <code><a href=
      "circular_buffer_space_optimized.html">circular_buffer_space_optimized</a></code> available. It is an adaptor of
      the <code>circular_buffer</code> which does not allocate memory at once when created, rather it allocates memory
      as needed.
    </p><br>
    <h2>
      <a name="briefexample" id="briefexample">Introductory Example</a>
    </h2>
    <p>
      A brief example using the <code>circular_buffer</code>:
    </p>
    <pre>
   #include &lt;boost/circular_buffer.hpp&gt;

   int main(int /*argc*/, char* /*argv*/[]) {

      // Create a circular buffer with a capacity for 3 integers.
      boost::circular_buffer&lt;int&gt; cb(3);

      // Insert some elements into the buffer.
      cb.push_back(1);
      cb.push_back(2);
      cb.push_back(3);
      
      int a = cb[0];  // a == 1
      int b = cb[1];  // b == 2
      int c = cb[2];  // c == 3
      
      // The buffer is full now, pushing subsequent
      // elements will overwrite the front-most elements.

      cb.push_back(4);  // Overwrite 1 with 4.
      cb.push_back(5);  // Overwrite 2 with 5.

      // The buffer now contains 3, 4 and 5.
      
      a = cb[0];  // a == 3
      b = cb[1];  // b == 4
      c = cb[2];  // c == 5

      // Elements can be popped from either the front or the back.

      cb.pop_back();  // 5 is removed.
      cb.pop_front(); // 3 is removed.

      int d = cb[0];  // d == 4

      return 0;
   }
</pre><br>
    <h2>
      <a name="synopsis" id="synopsis">Synopsis</a>
    </h2>
    <div id="srcdoc_synopsis">
      <table id="table_synopsis" border="0" cellpadding="10">
        <tr>
          <td>
            <pre>
namespace boost {

template &lt;class <a href="#templateparam_T">T</a>, class <a href="#templateparam_Alloc">Alloc</a>&gt;
class circular_buffer
{
public:
   typedef typename Alloc::value_type <a href=
"#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a>;
   typedef typename Alloc::pointer <a href=
"#classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c">pointer</a>;
   typedef typename Alloc::const_pointer <a href=
"#classboost_1_1circular__buffer_190f7c6bcb624ad507de546366f49028a">const_pointer</a>;
   typedef typename Alloc::reference <a href=
"#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a>;
   typedef typename Alloc::const_reference <a href=
"#classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910">const_reference</a>;
   typedef typename Alloc::difference_type <a href=
"#classboost_1_1circular__buffer_15313e723fa85d73db5826f8b722aa2a9">difference_type</a>;
   typedef typename Alloc::size_type <a href=
"#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a>;
   typedef Alloc <a href="#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>;
   typedef <i>implementation-defined</i> <a href=
"#classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9">const_iterator</a>;
   typedef <i>implementation-defined</i> <a href=
"#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a>;
   typedef reverse_iterator&lt;const_iterator&gt; <a href=
"#classboost_1_1circular__buffer_1ca423a848964c7915629c90fa7c58598">const_reverse_iterator</a>;
   typedef reverse_iterator&lt;iterator&gt; <a href=
"#classboost_1_1circular__buffer_1e5dbaec472f4b6ab6a8d4d0d6b15cbdb">reverse_iterator</a>;
   typedef std::pair&lt;pointer, size_type&gt; <a href=
"#classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f">array_range</a>;
   typedef std::pair&lt;const_pointer, size_type&gt; <a href=
"#classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025">const_array_range</a>;
   typedef size_type <a href="#classboost_1_1circular__buffer_10b8131db04bfa69c99f23aed053ca8a8">capacity_control</a>;

   explicit <a href=
"#classboost_1_1circular__buffer_1e53e744d2f94a2bcbfcdb219a9d93300">circular_buffer</a>(const allocator_type&amp; alloc = allocator_type());
   explicit <a href=
"#classboost_1_1circular__buffer_1b12a66eb6cd7cc88e177bba0a66c70c7">circular_buffer</a>(size_type capacity, const allocator_type&amp; alloc = allocator_type());
   <a href=
"#classboost_1_1circular__buffer_1fdace8f110d5b7a17c02020757f06fe8">circular_buffer</a>(size_type n, value_type item, const allocator_type&amp; alloc = allocator_type());
   <a href=
"#classboost_1_1circular__buffer_1862017022c033a2b107a25a0130430d3">circular_buffer</a>(size_type capacity, size_type n, value_type item, const allocator_type&amp; alloc = allocator_type());
   <a href=
"#classboost_1_1circular__buffer_1e515d8a951eeb18b8cc930300e7e13bd">circular_buffer</a>(const circular_buffer&lt;T, Alloc&gt;&amp; cb);
   template &lt;class InputIterator&gt;
      <a href=
"#classboost_1_1circular__buffer_1434667d007d3009971550546d30c5c2e">circular_buffer</a>(InputIterator first, InputIterator last);
   template &lt;class InputIterator&gt;
      <a href=
"#classboost_1_1circular__buffer_1083b77ee1d5b4f12699a141756ae9fff">circular_buffer</a>(size_type capacity, InputIterator first, InputIterator last);
   template &lt;class InputIterator&gt;
      <a href=
"#classboost_1_1circular__buffer_1744ec06b06a5a723386b645a29cb8ed2">circular_buffer</a>(InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());
   template &lt;class InputIterator&gt;
      <a href=
"#classboost_1_1circular__buffer_104368d300980e3b3bf40f05b2444cf6c">circular_buffer</a>(size_type capacity, InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());
   <a href="#classboost_1_1circular__buffer_164250ffbbbdbc62b99e8301fc195b80c">~circular_buffer</a>();

   allocator_type <a href=
"#classboost_1_1circular__buffer_1a20b7d0e7a4da0af13286df9f53d660c">get_allocator</a>() const;
   allocator_type&amp; <a href="#classboost_1_1circular__buffer_1af7758a36ac2f84a3024b50b4fc7e098">get_allocator</a>();
   iterator <a href="#classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0">begin</a>();
   iterator <a href="#classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1">end</a>();
   const_iterator <a href="#classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038">begin</a>() const;
   const_iterator <a href="#classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac">end</a>() const;
   reverse_iterator <a href="#classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa">rbegin</a>();
   reverse_iterator <a href="#classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697">rend</a>();
   const_reverse_iterator <a href=
"#classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026">rbegin</a>() const;
   const_reverse_iterator <a href="#classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3">rend</a>() const;
   reference <a href=
"#classboost_1_1circular__buffer_1d219f0d3203fb43b964a8cf63f1865cd">operator[]</a>(size_type index);
   value_type <a href=
"#classboost_1_1circular__buffer_1eb0a7fe7f8a56a4dc4c933b93adfcef4">operator[]</a>(size_type index) const;
   reference <a href="#classboost_1_1circular__buffer_1cd84838cb4fffb6c113fd0297e502edc">at</a>(size_type index);
   value_type <a href=
"#classboost_1_1circular__buffer_1b233a298f5845a0fcf2ecc56f4170810">at</a>(size_type index) const;
   reference <a href="#classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f">front</a>();
   reference <a href="#classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a">back</a>();
   value_type <a href="#classboost_1_1circular__buffer_10df8595d83bb9d8a7ce50aabc678f90b">front</a>() const;
   value_type <a href="#classboost_1_1circular__buffer_1027201797868c6274feb6712f670a132">back</a>() const;
   array_range <a href="#classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d">array_one</a>();
   array_range <a href="#classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b">array_two</a>();
   const_array_range <a href="#classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945">array_one</a>() const;
   const_array_range <a href="#classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5">array_two</a>() const;
   pointer <a href="#classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e">linearize</a>();
   size_type <a href="#classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32">size</a>() const;
   size_type <a href="#classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7">max_size</a>() const;
   bool <a href="#classboost_1_1circular__buffer_15be1c2a005ec9828549ef6dd7ebed583">empty</a>() const;
   bool <a href="#classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a">full</a>() const;
   size_type <a href="#classboost_1_1circular__buffer_1de901b1737217f2c8140fc1691bf2d98">capacity</a>() const;
   void <a href=
"#classboost_1_1circular__buffer_1902a2d89e6bfab28f548cdb21cc42456">set_capacity</a>(size_type new_capacity);
   void <a href=
"#classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3">resize</a>(size_type new_size, value_type item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_1e5b482668b1ea6c434b7354389bcca89">rset_capacity</a>(size_type new_capacity);
   void <a href=
"#classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483">rresize</a>(size_type new_size, value_type item = value_type());
   circular_buffer&lt;T, Alloc&gt;&amp; <a href=
"#classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d">operator=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; cb);
   void <a href=
"#classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada">assign</a>(size_type n, value_type item);
   void <a href=
"#classboost_1_1circular__buffer_1cfb85121fac69d36d687ee584fb115e3">assign</a>(size_type capacity, size_type n, value_type item);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c">assign</a>(InputIterator first, InputIterator last);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_15201ad8c806598d87ee5988dc2180f3b">assign</a>(size_type capacity, InputIterator first, InputIterator last);
   void <a href=
"#classboost_1_1circular__buffer_1270ab7074c365663a6f18808024fd88b">swap</a>(circular_buffer&lt;T, Alloc&gt;&amp; cb);
   void <a href=
"#classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e">push_back</a>(value_type item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce">push_front</a>(value_type item = value_type());
   void <a href="#classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07">pop_back</a>();
   void <a href="#classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8">pop_front</a>();
   iterator <a href=
"#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert</a>(iterator pos, value_type item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140">insert</a>(iterator pos, size_type n, value_type item);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6">insert</a>(iterator pos, InputIterator first, InputIterator last);
   iterator <a href=
"#classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c">rinsert</a>(iterator pos, value_type item = value_type());
   void <a href=
"#classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5">rinsert</a>(iterator pos, size_type n, value_type item);
   template &lt;class InputIterator&gt;
      void <a href=
"#classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323">rinsert</a>(iterator pos, InputIterator first, InputIterator last);
   iterator <a href="#classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3">erase</a>(iterator pos);
   iterator <a href=
"#classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd">erase</a>(iterator first, iterator last);
   iterator <a href="#classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f">rerase</a>(iterator pos);
   iterator <a href=
"#classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f">rerase</a>(iterator first, iterator last);
   void <a href="#classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e">clear</a>();
};

template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_1d35871e838359b5215e1cbb353663207">operator==</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_195b08213f201c2067d8acb024756329d">operator&lt;</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_1f5717e2f6532581a6492ff1839b18f6d">operator!=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_1f575d7a9741c2044424de50c966c12f3">operator&gt;</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_179abcbacd24b67f08185db54aec8600d">operator&lt;=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href=
"#namespaceboost_11c31150380272af67deebef578c80b05">operator&gt;=</a>(const circular_buffer&lt;T, Alloc&gt;&amp; lhs, const circular_buffer&lt;T, Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   void <a href=
"#namespaceboost_14aa8f6a2c9640f3f22e266f0fca85777">swap</a>(circular_buffer&lt;T, Alloc&gt;&amp; lhs, circular_buffer&lt;T, Alloc&gt;&amp; rhs);

} // namespace boost
</pre>
          </td>
        </tr>
      </table>
    </div><br>
    <h2>
      <a name="rationale" id="rationale">Rationale</a>
    </h2>
    <p>
      The basic motivation behind the <code>circular_buffer</code> was to create a container which would work
      seamlessly with STL. Additionally, the design of the <code>circular_buffer</code> was guided by the following
      principles:
    </p>
    <ol>
      <li>Maximum <em>efficiency</em> for envisaged applications.
      </li>
      <li>Suitable for <em>general purpose</em> use.
      </li>
      <li>The behaviour of the buffer as <em>intuitive</em> as possible.
      </li>
      <li>Suitable for <em>specialization</em> by means of adaptors. (The <code><a href=
      "circular_buffer_space_optimized.html">circular_buffer_space_optimized</a></code> is such an example of the
      adaptor.)
      </li>
      <li>Easy to <em>debug</em>. (See <a href="#debug">Debug Support</a> for details.)
      </li>
    </ol>
    <p>
      In order to achieve maximum efficiency, the <code>circular_buffer</code> stores its elements in a <em>contiguous
      region of memory</em>, which then enables:
    </p>
    <ol>
      <li>Use of fixed memory and no implicit or unexpected memory allocation.
      </li>
      <li>Fast constant-time insertion and removal of elements from the front and back.
      </li>
      <li>Fast constant-time random access of elements.
      </li>
      <li>Suitability for real-time and performance critical applications.
      </li>
    </ol>
    <p>
      Possible applications of the <code>circular_buffer</code> include:
    </p>
    <ul>
      <li>Storage of the most recently received samples, overwriting the oldest as new samples arrive.
      </li>
      <li>As an underlying container for a <i>bounded buffer</i> (see the <a href="#boundedbuffer">Bounded Buffer
      Example</a>).
      </li>
      <li>A kind of cache storing a specified number of last inserted elements.
      </li>
      <li>Efficient fixed capacity FIFO (First In, First Out) or LIFO (Last In, First Out) queue which removes the
      oldest (inserted as first) elements when full.
      </li>
    </ul>
    <p>
      The following paragraphs describe issues that had to be considered during the implemenation of the
      <code>circular_buffer</code>:
    </p>
    <h4>
      <a name="threadsafety" id="threadsafety">Thread-Safety</a>
    </h4>
    <p>
      The thread-safety of the <code>circular_buffer</code> is the same as the thread-safety of containers in most STL
      implementations. This means the <code>circular_buffer</code> is thread-safe only in the sense that simultaneous
      accesses to distinct instances of the <code>circular_buffer</code> are safe, and simultaneous read accesses to a
      shared <code>circular_buffer</code> are safe.
    </p>
    <p>
      If multiple threads access a single <code>circular_buffer</code>, and at least one of the threads may potentially
      write, then the user is responsible for ensuring mutual exclusion between the threads during the container
      accesses. The mutual exclusion between the threads can be achieved by wrapping operations of the underlying
      <code>circular_buffer</code> with a lock acquisition and release. (See the <a href="#boundedbuffer">Bounded
      Buffer Example</a>.)
    </p>
    <h4>
      Overwrite Operation
    </h4>
    <p>
      Overwrite operation occurs when an element is inserted into a full <code>circular_buffer</code> - the old element
      is being overwriten by the new one. There was a discussion what exactly "overwriting of an element" means during
      the formal review. It may be either a destruction of the original element and a consequent inplace construction
      of a new element or it may be an assignment of a new element into an old one. The <code>circular_buffer</code>
      implements <b>assignment</b> because it is more effective.
    </p>
    <p>
      From the point of business logic of a stored element, the destruction/construction operation and assignment
      usually mean the same. However, in very rare cases (if in any) they may differ. If there is a requirement for
      elements to be destructed/constructed instead of being assigned, consider implementing a wrapper of the element
      which would implement the assign operator, and store the wrappers instead. It is necessary to note that storing
      such wrappers has a drawback. The destruction/construction will be invoked on every assignment of the wrapper -
      not only when a wrapper is being overwritten (when the buffer is full) but also when the stored wrappers are
      being shifted (e.g. as a result of insertion into the middle of container).
    </p>
    <h4>
      Writing to a Full Buffer
    </h4>
    <p>
      There are several options how to cope with the case if a data source produces more data than can fit in the
      fixed-sized buffer:
    </p>
    <ol>
      <li>Inform the data source to wait until there is room in the buffer (e.g. by throwing an overflow exception).
      </li>
      <li>If the oldest data is the most important, ignore new data from the source until there is room in the buffer
      again.
      </li>
      <li>If the latest data is the most important, write over the oldest data.
      </li>
      <li>Let the producer to be responsible for checking the size of the buffer prior writing into it.
      </li>
    </ol>
    <p>
      It is apparent that the <code>circular_buffer</code> implements the third option. But it may be less apparent it
      <b>does not</b> implement any other option - especially the first two. One can get an impression that the
      <code>circular_buffer</code> should implement first three options and offer a mechanism of choosing among them.
      This impression is wrong. The <code>circular_buffer</code> was designed and optimized to be circular (which means
      overwriting the oldest data when full). If such a controlling mechanism had been enabled, it would just
      complicate the matters and the usage of the <code>circular_buffer</code> would be probably less straightforward.
    </p>
    <p>
      Moreover, the first two options (and the fouth option as well) do not require the buffer to be circular at all.
      If there is a need for the first or second option, consider implementing an adaptor of e.g.
      <code>std::vector</code>. In this case the <code>circular_buffer</code> is not suitable for adapting, because, in
      contrary to <code>std::vector</code>, it bears an overhead for its circular behavior.
    </p>
    <h4>
      Reading/Removing from an Empty Buffer
    </h4>
    <p>
      When reading or removing an element from an empty buffer, the buffer should be able to notify the data consumer
      (e.g. by throwing underflow exception) that there are no elements stored in it. The <code>circular_buffer</code>
      does not implement such a behaviour for two reasons:
    </p>
    <ol>
      <li>It would introduce performance overhead.
      </li>
      <li>No other <code>std</code> container implements it this way.
      </li>
    </ol>
    <p>
      It is considered to be a bug to read or remove an element (e.g. by calling <code>front()</code> or
      <code>pop_back()</code>) from an empty <code>std</code> container and from an emtpy <code>circular_buffer</code>
      as well. The data consumer has to test if the container is not empty before reading/removing from it. However,
      when reading from the <code>circular_buffer</code>, there is an option to rely on the <code>at()</code> method
      which throws an exception when the index is out of range.
    </p>
    <h4>
      Iterator Invalidation
    </h4>
    <p>
      An iterator is usually considered to be invalidated if an element, the iterator pointed to, had been removed or
      overwritten by an another element. This definition is enforced by the <a href="#debug">Debug Support</a> and is
      documented for every method. However, some applications utilizing <code>circular_buffer</code> may require less
      strict definition: an iterator is invalid only if it points to an uninitialized memory. Consider following
      example:
    </p>
    <pre>
   #define BOOST_CB_DISABLE_DEBUG // The Debug Support has to be disabled, otherwise the code produces a runtime error.

   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;assert.h&gt;

   int main(int /*argc*/, char* /*argv*/[]) {

      boost::circular_buffer&lt;int&gt; cb(3);

      cb.push_back(1);
      cb.push_back(2);
      cb.push_back(3);

      boost::circular_buffer&lt;int&gt;::iterator it = cb.begin();

      assert(*it == 1);

      cb.push_back(4);

      assert(*it == 4); // The iterator still points to the initialized memory.

      return 0;
   }
</pre>
    <p>
      The iterator does not point to the original element any more (and is considered to be invalid from the "strict"
      point of view) but it still points to the same <em>valid</em> place in the memory. This "soft" definition of
      iterator invalidation is supported by the <code>circular_buffer</code> but should be considered as an
      implementation detail rather than a full-fledged feature. The rules when the iterator is still valid can be
      inferred from the code in <code><a href=
      "../test/soft_iterator_invalidation.cpp">soft_iterator_invalidation.cpp</a></code>.
    </p>
    <h2>
      <a name="header" id="header">Header Files</a>
    </h2>
    <p>
      The <code>circular_buffer</code> is defined in the file <code><a href=
      "../../../boost/circular_buffer.hpp">boost/circular_buffer.hpp</a></code>. There is also a forward declaration
      for the <code>circular_buffer</code> in the header file <code><a href=
      "../../../boost/circular_buffer_fwd.hpp">boost/circular_buffer_fwd.hpp</a></code>.
    </p><br>
    <h2>
      <a name="model" id="model">Modeled Concepts</a>
    </h2>
    <p>
      <a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random AccessContainer</a>, <a href=
      "http://www.sgi.com/tech/stl/FrontInsertionSequence.html">Front Insertion Sequence</a> and <a href=
      "http://www.sgi.com/tech/stl/BackInsertionSequence.html">Back Insertion Sequence</a>.
    </p><br>
    <h2>
      <a name="parameters" id="parameters">Template Parameters</a>
    </h2>
    <div id="srcdoc_params">
      <table id="table_template_params" border="1" cellpadding="3">
        <tr>
          <th>
            Parameter
          </th>
          <th>
            Description
          </th>
          <th>
            Default
          </th>
        </tr>
        <tr>
          <td>
            <a id="templateparam_T" name="templateparam_T"><code>T</code></a>
          </td>
          <td>
            The type of the elements stored in the circular buffer.
            <dl>
              <dt>
                <b>Type Requirements:</b>
              </dt>
              <dd>
                The <code>T</code> has to be <a href="http://www.sgi.com/tech/stl/Assignable.html">SGIAssignable</a>
                (SGI STL defined combination of <a href="../../utility/Assignable.html">Assignable</a> and <a href=
                "../../utility/CopyConstructible.html">CopyConstructible</a>). Moreover <code>T</code> has to be
                <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">DefaultConstructible</a> if supplied as
                a default parameter when invoking some of the circular buffer's methods e.g. <code><a href=
                "#classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95">insert</a>(<a href=
                "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, const <a href=
                "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a>&amp; item =
                value_type())</code>.
              </dd>
            </dl>
          </td>
          <td>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="templateparam_Alloc" name="templateparam_Alloc"><code>Alloc</code></a>
          </td>
          <td>
            The allocator type used for all internal memory management.
            <dl>
              <dt>
                <b>Type Requirements:</b>
              </dt>
              <dd>
                The <code>Alloc</code> has to meet the allocator requirements imposed by STL.
              </dd>
            </dl>
          </td>
          <td>
            <code>std::allocator&lt;T&gt;</code>
          </td>
        </tr>
      </table>
    </div><br>
    <h2>
      <a name="types" id="types">Public Types</a>
    </h2>
    <div id="srcdoc_types">
      <table id="table_public_types" border="1" cellpadding="3">
        <tr>
          <th>
            Type
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540" name=
            "classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540"><code>value_type</code></a>
          </td>
          <td>
            The type of elements stored in the circular buffer.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c" name=
            "classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c"><code>pointer</code></a>
          </td>
          <td>
            A pointer to an element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_190f7c6bcb624ad507de546366f49028a" name=
            "classboost_1_1circular__buffer_190f7c6bcb624ad507de546366f49028a"><code>const_pointer</code></a>
          </td>
          <td>
            A const pointer to the element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65" name=
            "classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65"><code>reference</code></a>
          </td>
          <td>
            A reference to an element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910" name=
            "classboost_1_1circular__buffer_1a8397191092f5bacee991b623ca4b910"><code>const_reference</code></a>
          </td>
          <td>
            A const reference to an element.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15313e723fa85d73db5826f8b722aa2a9" name=
            "classboost_1_1circular__buffer_15313e723fa85d73db5826f8b722aa2a9"><code>difference_type</code></a>
          </td>
          <td>
            The distance type. (A signed integral type used to represent the distance between two iterators.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00" name=
            "classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00"><code>size_type</code></a>
          </td>
          <td>
            The size type. (An unsigned integral type that can represent any nonnegative value of the container's
            distance type.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7" name=
            "classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7"><code>allocator_type</code></a>
          </td>
          <td>
            The type of an allocator used in the circular buffer.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9" name=
            "classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9"><code>const_iterator</code></a>
          </td>
          <td>
            A const (random access) iterator used to iterate through the circular buffer.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532" name=
            "classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532"><code>iterator</code></a>
          </td>
          <td>
            A (random access) iterator used to iterate through the circular buffer.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1ca423a848964c7915629c90fa7c58598" name=
            "classboost_1_1circular__buffer_1ca423a848964c7915629c90fa7c58598"><code>const_reverse_iterator</code></a>
          </td>
          <td>
            A const iterator used to iterate backwards through a circular buffer.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1e5dbaec472f4b6ab6a8d4d0d6b15cbdb" name=
            "classboost_1_1circular__buffer_1e5dbaec472f4b6ab6a8d4d0d6b15cbdb"><code>reverse_iterator</code></a>
          </td>
          <td>
            An iterator used to iterate backwards through a circular buffer.
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f" name=
            "classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f"><code>array_range</code></a>
          </td>
          <td>
            An array range. (A typedef for the <a href=
            "http://www.sgi.com/tech/stl/pair.html"><code>std::pair</code></a> where its first element is a pointer to
            a beginning of an array and its second element represents a size of the array.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025" name=
            "classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025"><code>const_array_range</code></a>
          </td>
          <td>
            A range of a const array. (A typedef for the <a href=
            "http://www.sgi.com/tech/stl/pair.html"><code>std::pair</code></a> where its first element is a pointer to
            a beginning of a const array and its second element represents a size of the const array.)
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10b8131db04bfa69c99f23aed053ca8a8" name=
            "classboost_1_1circular__buffer_10b8131db04bfa69c99f23aed053ca8a8"><code>capacity_control</code></a>
          </td>
          <td>
            The capacity type. (Defined just for consistency with the <a href=
            "circular_buffer_space_optimized.html"><code>circular_buffer_space_optimized</code></a>.)
          </td>
        </tr>
      </table>
    </div><br>
    <h2>
      <a name="constructors" id="constructors">Constructors and Destructor</a>
    </h2>
    <div id="srcdoc_constructors">
      <table id="table_constructors" border="1" cellpadding="3">
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1e53e744d2f94a2bcbfcdb219a9d93300" name=
            "classboost_1_1circular__buffer_1e53e744d2f94a2bcbfcdb219a9d93300"></a><code><b>explicit
            circular_buffer(const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create an empty circular buffer with a maximum capacity.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>capacity() == max_size() &amp;&amp; size() == 0</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b12a66eb6cd7cc88e177bba0a66c70c7" name=
            "classboost_1_1circular__buffer_1b12a66eb6cd7cc88e177bba0a66c70c7"></a><code><b>explicit
            circular_buffer(<a href="#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a>
            capacity, const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create an empty circular buffer with a given capacity.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).capacity() == capacity &amp;&amp; (*this).size == 0</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1fdace8f110d5b7a17c02020757f06fe8" name=
            "classboost_1_1circular__buffer_1fdace8f110d5b7a17c02020757f06fe8"></a><code><b>circular_buffer(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item, const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create a full circular buffer with a given capacity and filled with copies of <code>item</code>.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>capacity() == n &amp;&amp; size() == n &amp;&amp; (*this)[0] == (*this)[1] == ... == (*this)[n -
                1] == item</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1862017022c033a2b107a25a0130430d3" name=
            "classboost_1_1circular__buffer_1862017022c033a2b107a25a0130430d3"></a><code><b>circular_buffer(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> capacity, <a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item, const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1e515d8a951eeb18b8cc930300e7e13bd" name=
            "classboost_1_1circular__buffer_1e515d8a951eeb18b8cc930300e7e13bd"></a><code><b>circular_buffer(const
            circular_buffer&lt;T,Alloc&gt;&amp; cb);</b></code><br>
            <br>
            Copy constructor.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>*this == cb</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1434667d007d3009971550546d30c5c2e" name=
            "classboost_1_1circular__buffer_1434667d007d3009971550546d30c5c2e"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                circular_buffer(InputIterator first, InputIterator last);</b></code><br>
            <br>
            <br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1083b77ee1d5b4f12699a141756ae9fff" name=
            "classboost_1_1circular__buffer_1083b77ee1d5b4f12699a141756ae9fff"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                circular_buffer(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> capacity, InputIterator
            first, InputIterator last);</b></code><br>
            <br>
            <br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1744ec06b06a5a723386b645a29cb8ed2" name=
            "classboost_1_1circular__buffer_1744ec06b06a5a723386b645a29cb8ed2"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                circular_buffer(InputIterator first, InputIterator last, const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_104368d300980e3b3bf40f05b2444cf6c" name=
            "classboost_1_1circular__buffer_104368d300980e3b3bf40f05b2444cf6c"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                circular_buffer(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> capacity, InputIterator
            first, InputIterator last, const <a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp; alloc =
            allocator_type());</b></code><br>
            <br>
            Create a circular buffer with a copy of a range.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).capacity() == capacity</code><br>
                If the number of items to copy from the range <code>[first, last)</code> is greater than the specified
                <code>capacity</code> then only elements from the range <code>[last - capacity, last)</code> will be
                copied.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_164250ffbbbdbc62b99e8301fc195b80c" name=
            "classboost_1_1circular__buffer_164250ffbbbdbc62b99e8301fc195b80c"></a><code><b>~circular_buffer();</b></code><br>

            <br>
            Destructor.<br>
            <br>
          </td>
        </tr>
      </table>
    </div><br>
    <h2>
      <a name="methods" id="methods">Public Member Functions</a>
    </h2>
    <div id="srcdoc_methods">
      <table id="table_methods" border="1" cellpadding="3">
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a20b7d0e7a4da0af13286df9f53d660c" name=
            "classboost_1_1circular__buffer_1a20b7d0e7a4da0af13286df9f53d660c"></a><code><b><a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a> get_allocator()
            const;</b></code><br>
            <br>
            Return the allocator.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1af7758a36ac2f84a3024b50b4fc7e098" name=
            "classboost_1_1circular__buffer_1af7758a36ac2f84a3024b50b4fc7e098"></a><code><b><a href=
            "#classboost_1_1circular__buffer_14e07c6ddfe89debe384e59bed06e7cb7">allocator_type</a>&amp;
            get_allocator();</b></code><br>
            <br>
            Return the allocator.
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                This method was added in order to optimize obtaining of the allocator with a state, although use of
                stateful allocators in STL is discouraged.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0" name=
            "classboost_1_1circular__buffer_158d1ede2e85f5d46eda8db3f0c4efef0"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> begin();</b></code><br>
            <br>
            Return an iterator pointing to the beginning of the circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1" name=
            "classboost_1_1circular__buffer_1babfa093dad7801223b80626b598dee1"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> end();</b></code><br>
            <br>
            Return an iterator pointing to the end of the circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038" name=
            "classboost_1_1circular__buffer_10640d3d41c13b6089b6f169224cf1038"></a><code><b><a href=
            "#classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9">const_iterator</a> begin()
            const;</b></code><br>
            <br>
            Return a const iterator pointing to the beginning of the circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac" name=
            "classboost_1_1circular__buffer_17890810d07bc595cfb87f9c47cb075ac"></a><code><b><a href=
            "#classboost_1_1circular__buffer_15cab6d46f03c40d1e52d41843319ddb9">const_iterator</a> end()
            const;</b></code><br>
            <br>
            Return a const iterator pointing to the end of the circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa" name=
            "classboost_1_1circular__buffer_1db3d6b10b6763549f54d2627228fa7aa"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1e5dbaec472f4b6ab6a8d4d0d6b15cbdb">reverse_iterator</a>
            rbegin();</b></code><br>
            <br>
            Return a reverse iterator pointing to the beginning of the reversed circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697" name=
            "classboost_1_1circular__buffer_1cff9236a50107188b8942847a4dc2697"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1e5dbaec472f4b6ab6a8d4d0d6b15cbdb">reverse_iterator</a>
            rend();</b></code><br>
            <br>
            Return a reverse iterator pointing to the end of the reversed circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026" name=
            "classboost_1_1circular__buffer_1765d91bf48341907418433a1e3aab026"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1ca423a848964c7915629c90fa7c58598">const_reverse_iterator</a> rbegin()
            const;</b></code><br>
            <br>
            Return a const reverse iterator pointing to the beginning of the reversed circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3" name=
            "classboost_1_1circular__buffer_108dbf538b00a14daf5582ece80746fc3"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1ca423a848964c7915629c90fa7c58598">const_reverse_iterator</a> rend()
            const;</b></code><br>
            <br>
            Return a const reverse iterator pointing to the end of the reversed circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d219f0d3203fb43b964a8cf63f1865cd" name=
            "classboost_1_1circular__buffer_1d219f0d3203fb43b964a8cf63f1865cd"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> operator[](<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index);</b></code><br>
            <br>
            Return the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>*(this).size() &gt; index</code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1eb0a7fe7f8a56a4dc4c933b93adfcef4" name=
            "classboost_1_1circular__buffer_1eb0a7fe7f8a56a4dc4c933b93adfcef4"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> operator[](<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index)
            const;</b></code><br>
            <br>
            Return the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>*(this).size() &gt; index</code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1cd84838cb4fffb6c113fd0297e502edc" name=
            "classboost_1_1circular__buffer_1cd84838cb4fffb6c113fd0297e502edc"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> at(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index);</b></code><br>
            <br>
            Return the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>std::out_of_range</i> thrown when the <code>index</code> is invalid.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b233a298f5845a0fcf2ecc56f4170810" name=
            "classboost_1_1circular__buffer_1b233a298f5845a0fcf2ecc56f4170810"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> at(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> index)
            const;</b></code><br>
            <br>
            Return the element at the <code>index</code> position.
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>std::out_of_range</i> thrown when the <code>index</code> is invalid.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f" name=
            "classboost_1_1circular__buffer_10d5fdeabeb352f47d1f7bb1ea8d9819f"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> front();</b></code><br>
            <br>
            Return the first (leftmost) element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!*(this).empty()</code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a" name=
            "classboost_1_1circular__buffer_1d985d974020f88bb4255d8edbae0a30a"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1f38a9bc64d84757c661c2542ff9a7f65">reference</a> back();</b></code><br>
            <br>
            Return the last (rightmost) element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!*(this).empty()</code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10df8595d83bb9d8a7ce50aabc678f90b" name=
            "classboost_1_1circular__buffer_10df8595d83bb9d8a7ce50aabc678f90b"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> front()
            const;</b></code><br>
            <br>
            Return the first (leftmost) element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!*(this).empty()</code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1027201797868c6274feb6712f670a132" name=
            "classboost_1_1circular__buffer_1027201797868c6274feb6712f670a132"></a><code><b><a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> back()
            const;</b></code><br>
            <br>
            Return the last (rightmost) element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!*(this).empty()</code>
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d" name=
            "classboost_1_1circular__buffer_1957cccdcb0c4ef7d80a34a990065818d"></a><code><b><a href=
            "#classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f">array_range</a>
            array_one();</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b" name=
            "classboost_1_1circular__buffer_1f5081a54afbc2dfc1a7fb20329df7d5b"></a><code><b><a href=
            "#classboost_1_1circular__buffer_126d279f91fef717e25459a0817ff242f">array_range</a>
            array_two();</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945" name=
            "classboost_1_1circular__buffer_10f4b157e27b1170a571417986b239945"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025">const_array_range</a> array_one()
            const;</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5" name=
            "classboost_1_1circular__buffer_1bb8eb0f298ad2012c55c5303e1f174d5"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11885d7f475b7e7a74c95b2448d243025">const_array_range</a> array_two()
            const;</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e" name=
            "classboost_1_1circular__buffer_1ea728bf57f91aa8946eddf76ce816a4e"></a><code><b><a href=
            "#classboost_1_1circular__buffer_14ff917f8a6131ec18e91606727592a9c">pointer</a> linearize();</b></code><br>
            <br>
            Linearize the internal buffer into a continuous array. This method can be useful when passing the stored
            data into the legacy C API as an array.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>&amp;(*this)[0] &lt; &amp;(*this)[1] &lt; ... &lt; &amp;(*this)[size() - 1]</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                A pointer to the beginning of the array or 0 if empty.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
              <dd>
                <i>Whatever</i> T::operator = (const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Complexity:</b>
              </dt>
              <dd>
                Linear in the size of the circular_buffer; constant if the postcondition is already met.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Exception Safety:</b>
              </dt>
              <dd>
                Basic.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Iterator Invalidation:</b>
              </dt>
              <dd>
                Invalidates all iterators pointing to the circular_buffer; does not invalidate any iterator if the
                postcondition is already met prior calling this method.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Warning:</b>
              </dt>
              <dd>
                In general invoking any method which modifies the internal state of the circular_buffer may delinearize
                the internal buffer and invalidate the returned pointer.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                This is not the only way how to pass data into the legacy C API - see array_one() and array_two() for
                the other option.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32" name=
            "classboost_1_1circular__buffer_15fa0edd153e2591dd6bf070eb663ee32"></a><code><b><a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> size()
            const;</b></code><br>
            <br>
            Return the number of elements currently stored in the circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7" name=
            "classboost_1_1circular__buffer_157e2d506bc274b2a63fbe1b8fcafebd7"></a><code><b><a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> max_size()
            const;</b></code><br>
            <br>
            Return the largest possible size (or capacity) of the circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15be1c2a005ec9828549ef6dd7ebed583" name=
            "classboost_1_1circular__buffer_15be1c2a005ec9828549ef6dd7ebed583"></a><code><b>bool empty()
            const;</b></code><br>
            <br>
            Is the circular buffer empty?
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>true</code> if there are no elements stored in the circular buffer. <code>false</code> otherwise.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a" name=
            "classboost_1_1circular__buffer_1fd0eef8ba91210d1575404b7e3e8207a"></a><code><b>bool full()
            const;</b></code><br>
            <br>
            Is the circular buffer full?
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                <code>true</code> if the number of elements stored in the circular buffer equals the capacity of the
                circular buffer. <code>false</code> otherwise.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1de901b1737217f2c8140fc1691bf2d98" name=
            "classboost_1_1circular__buffer_1de901b1737217f2c8140fc1691bf2d98"></a><code><b><a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> capacity()
            const;</b></code><br>
            <br>
            Return the capacity of the circular buffer.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1902a2d89e6bfab28f548cdb21cc42456" name=
            "classboost_1_1circular__buffer_1902a2d89e6bfab28f548cdb21cc42456"></a><code><b>void set_capacity(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a>
            new_capacity);</b></code><br>
            <br>
            Change the capacity of the circular buffer.
            <dl>
              <dt>
                <b>Parameters:</b>
              </dt>
              <dd>
                <i>new_capacity</i> - The new capacity.
              </dd>
              <dd>
                <i>remove_front</i> - This parameter plays its role only if the current number of elements stored in
                the circular buffer is greater than the desired new capacity. If set to <code>true</code> then the
                first (leftmost) elements will be removed. If set to <code>false</code> then the last (leftmost)
                elements will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).capacity() == new_capacity</code><br>
                If the current number of elements stored in the circular buffer is greater than the desired new
                capacity then <code>((*this).size() - new_capacity)</code> elements will be removed according to the
                <code>remove_front</code> parameter.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3" name=
            "classboost_1_1circular__buffer_180c2e2e66a8fa9d0b7adc1b54921a8c3"></a><code><b>void resize(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> new_size, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item =
            value_type());</b></code><br>
            <br>
            Change the size of the circular buffer.
            <dl>
              <dt>
                <b>Parameters:</b>
              </dt>
              <dd>
                <i>new_size</i> - The new size.
              </dd>
              <dd>
                <i>item</i> - See the postcondition.
              </dd>
              <dd>
                <i>remove_front</i> - This parameter plays its role only if the current number of elements stored in
                the circular buffer is greater than the desired new capacity. If set to <code>true</code> then the
                first (leftmost) elements will be removed. If set to <code>false</code> then the last (rightmost)
                elements will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).size() == new_size</code><br>
                If the new size is greater than the current size, the rest of the circular buffer is filled with copies
                of <code>item</code>. In case the resulting size exceeds the current capacity the capacity is set to
                <code>new_size</code>. If the new size is lower than the current size then <code>((*this).size() -
                new_size)</code> elements will be removed according to the <code>remove_front</code> parameter.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1e5b482668b1ea6c434b7354389bcca89" name=
            "classboost_1_1circular__buffer_1e5b482668b1ea6c434b7354389bcca89"></a><code><b>void rset_capacity(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a>
            new_capacity);</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483" name=
            "classboost_1_1circular__buffer_144ecd9ec5f54a2d61c7d132e445d3483"></a><code><b>void rresize(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> new_size, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item =
            value_type());</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d" name=
            "classboost_1_1circular__buffer_1db1558911b2e251a587aeb3d8b3d797d"></a><code><b>circular_buffer&lt;T,Alloc&gt;&amp;
            operator=(const circular_buffer&lt;T,Alloc&gt;&amp; cb);</b></code><br>
            <br>
            Assignment operator.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>*this == cb</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada" name=
            "classboost_1_1circular__buffer_19ba4a81df16f386d31b04b49c82d1ada"></a><code><b>void assign(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item);</b></code><br>
            <br>
            Assign <code>n</code> items into the circular buffer.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).capacity() == n &amp;&amp; (*this).size() == n &amp;&amp; (*this)[0] == (*this)[1] == ...
                == (*this).back() == item</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1cfb85121fac69d36d687ee584fb115e3" name=
            "classboost_1_1circular__buffer_1cfb85121fac69d36d687ee584fb115e3"></a><code><b>void assign(<a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> capacity, <a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item);</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c" name=
            "classboost_1_1circular__buffer_1253302d9bda5d7efbc4a6c311de3790c"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void assign(InputIterator first, InputIterator last);</b></code><br>
            <br>
            Assign a copy of range.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).capacity() == std::distance(first, last) &amp;&amp; (*this).size() ==
                std::distance(first, last)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>An allocation error</i> if memory is exhausted (<code>std::bad_alloc</code> if the standard
                allocator is used).
              </dd>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_15201ad8c806598d87ee5988dc2180f3b" name=
            "classboost_1_1circular__buffer_15201ad8c806598d87ee5988dc2180f3b"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void assign(<a href="#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a>
            capacity, InputIterator first, InputIterator last);</b></code><br>
            <br>
            TODO doc.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1270ab7074c365663a6f18808024fd88b" name=
            "classboost_1_1circular__buffer_1270ab7074c365663a6f18808024fd88b"></a><code><b>void
            swap(circular_buffer&lt;T,Alloc&gt;&amp; cb);</b></code><br>
            <br>
            Swap the contents of two circular buffers.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>this</code> contains elements of <code>cb</code> and vice versa.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e" name=
            "classboost_1_1circular__buffer_1aa35dd7ef8eb1d04508494d1835cc82e"></a><code><b>void push_back(<a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item =
            value_type());</b></code><br>
            <br>
            Insert a new element at the end.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).back() == item</code><br>
                If the circular buffer is full, the first (leftmost) element will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce" name=
            "classboost_1_1circular__buffer_10ef57e73c193682a649d8eb4a1096dce"></a><code><b>void push_front(<a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item =
            value_type());</b></code><br>
            <br>
            Insert a new element at the start.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).front() == item</code><br>
                If the circular buffer is full, the last (rightmost) element will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07" name=
            "classboost_1_1circular__buffer_1df0da00cb501bea75afbbfab9f546a07"></a><code><b>void
            pop_back();</b></code><br>
            <br>
            Remove the last (rightmost) element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!*(this).empty()</code> <code>iterator it = ((*this).end() - 1)</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>((*this).end() - 1) != it</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8" name=
            "classboost_1_1circular__buffer_18ac972dc24ef7236faa1875de92b9dd8"></a><code><b>void
            pop_front();</b></code><br>
            <br>
            Remove the first (leftmost) element.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                <code>!*(this).empty()</code> <code>iterator it = (*this).begin()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).begin() != it</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95" name=
            "classboost_1_1circular__buffer_128c92740fee1b9deb8c69816e389de95"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> insert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item =
            value_type());</b></code><br>
            <br>
            Insert the <code>item</code> before the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                The <code>item</code> will be inserted at the position <code>pos</code>.<br>
                If the circular buffer is full, the first (leftmost) element will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                iterator to the inserted element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
              <dd>
                <i>Whatever</i> T::operator = (const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140" name=
            "classboost_1_1circular__buffer_1b2f197c99d47138db777f0a46783b140"></a><code><b>void insert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item);</b></code><br>
            <br>
            Insert <code>n</code> copies of the item before the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                This operation preserves the capacity of the circular buffer. If the insertion would result in
                exceeding the capacity of the circular buffer then the necessary number of elements from the beginning
                (left) of the circular buffer will be removed or not all <code>n</code> elements will be inserted or
                both.<code><br>
                Example:<br>
                original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
                position ---------------------^<br>
                insert(position, (size_t)5, 6);<br>
                (If the operation won't preserve capacity, the buffer would look like this |1|2|6|6|6|6|6|3|4|)<br>
                RESULTING circular buffer |6|6|6|6|3|4| - capacity: 6, size: 6</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
              <dd>
                <i>Whatever</i> T::operator = (const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6" name=
            "classboost_1_1circular__buffer_1d00091d1d794cab3264b3674e99b33f6"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void insert(<a href="#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a>
            pos, InputIterator first, InputIterator last);</b></code><br>
            <br>
            Insert the range <code>[first, last)</code> before the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator and valid range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                This operation preserves the capacity of the circular buffer. If the insertion would result in
                exceeding the capacity of the circular buffer then the necessary number of elements from the beginning
                (left) of the circular buffer will be removed or not the whole range will be inserted or both. In case
                the whole range cannot be inserted it will be inserted just some elements from the end (right) of the
                range (see the example).<code><br>
                Example:<br>
                array to insert: int array[] = { 5, 6, 7, 8, 9 };<br>
                original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
                position ---------------------^<br>
                insert(position, array, array + 5);<br>
                (If the operation won't preserve capacity, the buffer would look like this |1|2|5|6|7|8|9|3|4|)<br>
                RESULTING circular buffer |6|7|8|9|3|4| - capacity: 6, size: 6</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
              <dd>
                <i>Whatever</i> T::operator = (const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c" name=
            "classboost_1_1circular__buffer_12c9332f457bf5bb3128463cf528c058c"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> rinsert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item =
            value_type());</b></code><br>
            <br>
            Insert an <code>item</code> before the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                The <code>item</code> will be inserted before the position <code>pos</code>.<br>
                If the circular buffer is full, the last element (rightmost) will be removed.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                iterator to the inserted element.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
              <dd>
                <i>Whatever</i> T::operator = (const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5" name=
            "classboost_1_1circular__buffer_1a47a5358db1b7d7e4925c16db13d2fc5"></a><code><b>void rinsert(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos, <a href=
            "#classboost_1_1circular__buffer_19ba12c0142a21a7d960877c22fa3ea00">size_type</a> n, <a href=
            "#classboost_1_1circular__buffer_1cbdd7ca87e147c08cd2be267eefd6540">value_type</a> item);</b></code><br>
            <br>
            Insert <code>n</code> copies of the item before the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                This operation preserves the capacity of the circular buffer. If the insertion would result in
                exceeding the capacity of the circular buffer then the necessary number of elements from the end
                (right) of the circular buffer will be removed or not all <code>n</code> elements will be inserted or
                both.<code><br>
                Example:<br>
                original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
                position ---------------------^<br>
                insert(position, (size_t)5, 6);<br>
                (If the operation won't preserve capacity, the buffer would look like this |1|2|6|6|6|6|6|3|4|)<br>
                RESULTING circular buffer |1|2|6|6|6|6| - capacity: 6, size: 6</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
              <dd>
                <i>Whatever</i> T::operator = (const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323" name=
            "classboost_1_1circular__buffer_1d6479cbc43a304bdbf04262f957fa323"></a> <code><b>template &lt;class
            InputIterator&gt;<br>
                void rinsert(<a href="#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a>
            pos, InputIterator first, InputIterator last);</b></code><br>
            <br>
            Insert the range <code>[first, last)</code> before the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator and valid range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                This operation preserves the capacity of the circular buffer. If the insertion would result in
                exceeding the capacity of the circular buffer then the necessary number of elements from the end
                (right) of the circular buffer will be removed or not the whole range will be inserted or both. In case
                the whole range cannot be inserted it will be inserted just some elements from the beginning (left) of
                the range (see the example).<code><br>
                Example:<br>
                array to insert: int array[] = { 5, 6, 7, 8, 9 };<br>
                original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
                position ---------------------^<br>
                insert(position, array, array + 5);<br>
                (If the operation won't preserve capacity, the buffer would look like this |1|2|5|6|7|8|9|3|4|)<br>
                RESULTING circular buffer |1|2|5|6|7|8| - capacity: 6, size: 6</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Throws:</b>
              </dt>
              <dd>
                <i>Whatever</i> T::T(const T&amp;) throws.
              </dd>
              <dd>
                <i>Whatever</i> T::operator = (const T&amp;) throws.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3" name=
            "classboost_1_1circular__buffer_197155de712db1759e1698455b49a0be3"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> erase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos);</b></code><br>
            <br>
            Erase the element at the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator. <code>size_type old_size = (*this).size()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).size() == old_size - 1</code><br>
                Removes an element at the position <code>pos</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                iterator to the first element remaining beyond the removed element or <code>(*this).end()</code> if no
                such element exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd" name=
            "classboost_1_1circular__buffer_1a96415389509a18bd7d7b5d8e4dda9bd"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> erase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> first, <a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> last);</b></code><br>
            <br>
            Erase the range <code>[first, last)</code>.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>. <code>size_type old_size = (*this).size()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).size() == old_size - std::distance(first, last)</code><br>
                Removes the elements from the range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                iterator to the first element remaining beyond the removed element or <code>(*this).end()</code> if no
                such element exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f" name=
            "classboost_1_1circular__buffer_1b6d4ae77d7445f844e30e78592f1e06f"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> rerase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> pos);</b></code><br>
            <br>
            Erase the element at the given position.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid <code>pos</code> iterator. <code>size_type old_size = (*this).size()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).size() == old_size - 1</code><br>
                Removes an element at the position <code>pos</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                iterator to the first element remaining in front of the removed element or <code>(*this).begin()</code>
                if no such element exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f" name=
            "classboost_1_1circular__buffer_1b0f98ae303584ded5397f067bbfc911f"></a><code><b><a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> rerase(<a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> first, <a href=
            "#classboost_1_1circular__buffer_11b8a33f2dc8519b8a7d344ed4408c532">iterator</a> last);</b></code><br>
            <br>
            Erase the range <code>[first, last)</code>.
            <dl>
              <dt>
                <b>Precondition:</b>
              </dt>
              <dd>
                Valid range <code>[first, last)</code>. <code>size_type old_size = (*this).size()</code>
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                <code>(*this).size() == old_size - std::distance(first, last)</code><br>
                Removes the elements from the range <code>[first, last)</code>.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Returns:</b>
              </dt>
              <dd>
                iterator to the first element remaining in front of the removed element or <code>(*this).begin()</code>
                if no such element exists.
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
        <tr>
          <td>
            <a id="classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e" name=
            "classboost_1_1circular__buffer_1826f5770a40b8b752eb9587378464d1e"></a><code><b>void
            clear();</b></code><br>
            <br>
            Erase all stored elements.
            <dl>
              <dt>
                <b>Postcondition:</b>
              </dt>
              <dd>
                (*this).size() == 0
              </dd>
            </dl>
            <dl>
              <dt>
                <b>Note:</b>
              </dt>
              <dd>
                For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>.
              </dd>
            </dl>
          </td>
        </tr>
      </table>
    </div><br>
    <h2>
      <a name="functions" id="functions">Standalone Functions</a>
    </h2>
    <div id="srcdoc_functions">
      <table id="table_functions" border="1" cellpadding="3">
        <tr>
          <td>
            <a id="namespaceboost_1d35871e838359b5215e1cbb353663207" name=
            "namespaceboost_1d35871e838359b5215e1cbb353663207"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator==(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Test two circular buffers for equality.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_195b08213f201c2067d8acb024756329d" name=
            "namespaceboost_195b08213f201c2067d8acb024756329d"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&lt;(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Lexicographical comparison.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_1f5717e2f6532581a6492ff1839b18f6d" name=
            "namespaceboost_1f5717e2f6532581a6492ff1839b18f6d"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator!=(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Test two circular buffers for non-equality.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_1f575d7a9741c2044424de50c966c12f3" name=
            "namespaceboost_1f575d7a9741c2044424de50c966c12f3"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&gt;(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Lexicographical comparison.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_179abcbacd24b67f08185db54aec8600d" name=
            "namespaceboost_179abcbacd24b67f08185db54aec8600d"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&lt;=(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Lexicographical comparison.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_11c31150380272af67deebef578c80b05" name=
            "namespaceboost_11c31150380272af67deebef578c80b05"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                bool operator&gt;=(const circular_buffer&lt;T,Alloc&gt;&amp; lhs, const
            circular_buffer&lt;T,Alloc&gt;&amp; rhs);</b></code><br>
            <br>
            Lexicographical comparison.<br>
            <br>
          </td>
        </tr>
        <tr>
          <td>
            <a id="namespaceboost_14aa8f6a2c9640f3f22e266f0fca85777" name=
            "namespaceboost_14aa8f6a2c9640f3f22e266f0fca85777"></a> <code><b>template &lt;class T, class Alloc&gt;<br>
                void swap(circular_buffer&lt;T,Alloc&gt;&amp; lhs, circular_buffer&lt;T,Alloc&gt;&amp;
            rhs);</b></code><br>
            <br>
            Swap the contents of two circular buffers.<br>
            <br>
          </td>
        </tr>
      </table>
    </div><br>
    <h2>
      <a name="semantics" id="semantics">Semantics</a>
    </h2>
    <p>
      TODO remove this section
    </p>
    <p>
      The behaviour of insertion for <code>circular_buffer</code> is as follows:
    </p>
    <ul>
      <li>The capacity of a <code>circular_buffer</code> remains fixed unless adjusted via <code>set_capacity</code> or
      <code>resize</code> .
      </li>
      <li>
        <code>insert</code> will overwrite front elements as necessary.
      </li>
      <li>
        <code>rinsert</code> will overwrite back elements as necessary.
      </li>
    </ul>
    <p>
      The behaviour of resizing a <code>circular_buffer</code> is as follows:
    </p>
    <ul>
      <li>The capacity will be adjusted to accommodate a <code>resize</code> . (The capacity can be only increased, not
      decreased.)
      </li>
    </ul>
    <p>
      The behaviour of assigning to a <code>circular_buffer</code> is as follows:
    </p>
    <ul>
      <li>The capacity will be adjusted to accommodate an <code>assign</code> . (The capacity can be only increased,
      not decreased.)
      </li>
    </ul>
    <p>
      <a name="invalidation" id="invalidation"></a> The rules for iterator (and result of <code>data()</code> )
      invalidation for <code>circular_buffer</code> are as follows:
    </p>
    <ul>
      <li>
        <code>insert</code> at the end of the <code>circular_buffer</code> (including <code>push_back</code> ) does not
        invalidate any iterator except the case the iterator points to the overwritten element.
      </li>
      <li>
        <code>rinsert</code> at the beginning of the <code>circular_buffer</code> (including <code>push_front</code> )
        does not invalidate any iterator except the case the iterator points to the overwritten element.
      </li>
      <li>
        <code>insert</code> in the middle of the <code>circular_buffer</code> invalidates iterators pointing to the
        elements at the insertion point and behind the insertion point. It also invalidates iterators pointing to the
        overwritten element(s).
      </li>
      <li>
        <code>rinsert</code> in the middle of the <code>circular_buffer</code> invalidates iterators pointing to the
        elements before the insertion point and iterators pointing to the overwritten element(s).
      </li>
      <li>
        <code>erase</code> at the end of the <code>circular_buffer</code> (including <code>pop_back</code> )
        invalidates only iterators pointing to the erased element(s).
      </li>
      <li>
        <code>pop_front</code> invalidates only iterators pointing to the erased element.
      </li>
      <li>
        <code>erase</code> at the beginning or in the middle of the <code>circular_buffer</code> invalidates iterators
        pointing to the erased element(s) and iterators pointing to the elements behind the erase point.
      </li>
      <li>
        <code>data</code> , <code>set_capacity</code> , <code>resize</code> , <code>operator=</code> ,
        <code>assign</code> , <code>swap</code> and <code>clear</code> invalidate all iterators pointing to the
        <code>circular_buffer</code> .
      </li>
    </ul>
    <p>
      In addition to the preceding rules the iterators get also invalidated due to overwriting (e.g. iterator pointing
      to the front-most element gets invalidated when inserting into the full <code>circular_buffer</code> ). They get
      invalidated in that sense they do not point to the same element as before but they do still point to the same
      <b>valid</b> place in the memory. If you want to rely on this feature you have to turn of the <a href=
      "#debug">Debug Support</a> otherwise an assertion will report an error if such invalidated iterator is used.
    </p><br>
    <h2>
      <a name="caveats" id="caveats">Caveats</a>
    </h2>
    <p>
      The <code>circular_buffer</code> should not be used for storing pointers to dynamically allocated objects. When a
      <code>circular_buffer</code> becomes full, further insertion will overwrite the stored pointers - resulting in a
      <b>memoryleak</b>. One recommend alternative is the use of smart pointers <a href="#note2">[2]</a>. (Any
      container of <code>std::auto_ptr</code> is considered particularly hazardous. <a href="#note3">[3]</a> )
    </p>
    <p>
      Elements inserted near the front of a full <code>circular_buffer</code> can be lost. According to the <a href=
      "#semantics">semantics</a> of <code>insert</code> , insertion overwrites front-most items as necessary - possibly
      including elements currently being <b>inserted at the front</b> of the buffer. Conversely,
      <code>push_front</code> to a full <code>circular_buffer</code> is guaranteed to overwrite the back-most element.
    </p>
    <p>
      Elements inserted near the back of a full <code>circular_buffer</code> can be lost. According to the <a href=
      "#semantics">semantics</a> of <code>rinsert</code> , insertion overwrites back-most items as necessary - possibly
      including elements currently being <b>inserted at the back</b> of the buffer. Conversely, <code>push_back</code>
      to a full <code>circular_buffer</code> is guaranteed to overwrite the front-most element.
    </p>
    <p>
      While internals of a <code>circular_buffer</code> are circular, iterators are <b>not</b>. Iterators of a
      <code>circular_buffer</code> are only valid for the range <code>[begin(), end()]</code> . E.g. iterators
      <code>(begin() - 1)</code> and <code>(end() + 1)</code> are invalid.
    </p><br>
    <h2>
      <a name="debug" id="debug">Debug Support</a>
    </h2>
    <p>
      In order to help a programmer to avoid and find common bugs, the <code>circular_buffer</code> contains a kind of
      debug support.
    </p>
    <p>
      The <code>circular_buffer</code> maintains a list of valid iterators. As soon as any element gets destroyed all
      iterators pointing to this element are removed from this list and explicitly invalidated (an invalidation flag is
      set). The debug support also consists of many assertions (<a href=
      "../../utility/assert.html"><code>BOOST_ASSERT</code></a> macros) which ensure the <code>circular_buffer</code>
      and its iterators are used in the correct manner at runtime. In case an invalid iterator is used the assertion
      will report an error. The connection of explicit iterator invalidation and assertions makes a very robust debug
      technique which catches most of the errors.
    </p>
    <p>
      Moreover, the uninitialized memory allocated by <code>circular_buffer</code> is filled with the value
      <code>0xcc</code> in the debug mode. This can help the programmer when debugging the code to recognize the
      initialized memory from the uninitialized. For details refer the source code.
    </p>
    <p>
      The debug support is enabled only in the debug mode (when the <code>NDEBUG</code> is not defined). It can also be
      explicitly disabled by defining <code>BOOST_CB_DISABLE_DEBUG</code> macro.
    </p><br>
    <h2>
      <a name="examples" id="examples">More Examples</a>
    </h2>
    <p>
      The following example includes various usage of the <code>circular_buffer</code> .
    </p>
    <pre>
   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;numeric&gt;
   #include &lt;assert.h&gt;
   
   int main(int /*argc*/, char* /*argv*/[])
   {
      // create a circular buffer of capacity 3
      boost::circular_buffer&lt;int&gt; cb(3);
      
      // insert some elements into the circular buffer
      cb.push_back(1);
      cb.push_back(2);
     
      // assertions
      assert(cb[0] == 1);
      assert(cb[1] == 2);
      assert(!cb.full());
      assert(cb.size() == 2);
      assert(cb.capacity() == 3);

      // insert some other elements
      cb.push_back(3);
      cb.push_back(4);
     
      // evaluate the sum
      int sum = std::accumulate(cb.begin(), cb.end(), 0);
     
      // assertions
      assert(cb[0] == 2);
      assert(cb[1] == 3);
      assert(cb[2] == 4);
      assert(*cb.begin() == 2);
      assert(cb.front() == 2);
      assert(cb.back() == 4);
      assert(sum == 9);
      assert(cb.full());
      assert(cb.size() == 3);
      assert(cb.capacity() == 3);
     
      return 0;
   }
</pre>
    <p>
      The <code>circular_buffer</code> has a capacity of three <code>int</code>. Therefore, the size of the buffer will
      not exceed three. The <code><a href="http://www.sgi.com/tech/stl/accumulate.html">accumulate</a></code> algorithm
      evaluates the sum of the stored elements. The semantics of the <code>circular_buffer</code> can be inferred from
      the assertions.
    </p>
    <h4>
      <a name="boundedbuffer" id="boundedbuffer">Bounded Buffer Example</a>
    </h4>
    <p>
      The bounded buffer is normally used in a producer-consumer mode when producer threads produce items and store
      them in the container and consumer threads remove these items and process them. The bounded buffer has to
      guarantee that producers do not insert items into the container when the container is full, that consumers do not
      try to remove items when the container is empty, and that each produced item is consumed by exactly one consumer.
    </p>
    <p>
      The example below shows how the <code>circular_buffer</code> can be utilized as an underlying container of the
      bounded buffer.
    </p>
    <pre>
   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;boost/thread/mutex.hpp&gt;
   #include &lt;boost/thread/condition.hpp&gt;
   #include &lt;boost/thread/thread.hpp&gt;
   #include &lt;boost/progress.hpp&gt;
   #include &lt;boost/bind.hpp&gt;

   template &lt;class T&gt;
   class bounded_buffer {
   public:

      typedef boost::circular_buffer&lt;T&gt; container_type;
      typedef typename container_type::size_type size_type;
      typedef typename container_type::value_type value_type;

      explicit bounded_buffer(size_type capacity) : m_unread(0), m_container(capacity) {}

      void push_front(const value_type&amp; item) {
         boost::mutex::scoped_lock lock(m_mutex);
         m_not_full.wait(lock, boost::bind(&amp;bounded_buffer&lt;value_type&gt;::is_not_full, this));
         m_container.push_front(item);
         ++m_unread;
         lock.unlock();
         m_not_empty.notify_one();
      }

      void pop_back(value_type* pItem) {
         boost::mutex::scoped_lock lock(m_mutex);
         m_not_empty.wait(lock, boost::bind(&amp;bounded_buffer&lt;value_type&gt;::is_not_empty, this));
         *pItem = m_container[--m_unread];
         lock.unlock();
         m_not_full.notify_one();
      }

   private:
      bounded_buffer(const bounded_buffer&amp;);              // Disabled copy constructor
      bounded_buffer&amp; operator = (const bounded_buffer&amp;); // Disabled assign operator

      bool is_not_empty() const { return m_unread &gt; 0; }
      bool is_not_full() const { return m_unread &lt; m_container.capacity(); }

      size_type m_unread;
      container_type m_container;
      boost::mutex m_mutex;
      boost::condition m_not_empty;
      boost::condition m_not_full;
   };
</pre>
    <p>
      The <code>bounded_buffer</code> uses <a href="../../thread/doc/">Boost Threads</a> and <a href=
      "../../bind/bind.html">Boost Bind</a> libraries.
    </p>
    <p>
      The <code>push_front()</code> method is called by the producer thread in order to insert a new item into the
      buffer. The method locks the mutex and waits until there is a space for the new item. (The mutex is unlocked
      during the waiting stage and has to be regained when the condition is met.) If there is a space in the buffer
      available, the execution continues and the method inserts the item at the end of the
      <code>circular_buffer</code>. Then it increments the number of unread items and unlocks the mutex (in case an
      exception is thrown before the mutex is unlocked, the mutex is unlocked automatically by the destructor of the
      <code>scoped_lock</code>). At last the method notifies one of the consumer threads waiting for a new item to be
      inserted into the buffer.
    </p>
    <p>
      The <code>pop_back()</code> method is called by the consumer thread in order to read the next item from the
      buffer. The method locks the mutex and waits until there is an unread item in the buffer. If there is at least
      one unread item, the method decrements the number of unread items and reads the next item from the
      <code>circular_buffer</code>. Then it unlocks the mutex and notifies one of the producer threads waiting for the
      buffer to free a space for the next item.
    </p>
    <p>
      The <code>pop_back()</code> method does not remove the item but the item is left in the
      <code>circular_buffer</code> which then replaces it with a new one (inserted by a producer) when the
      <code>circular_buffer</code> is full. This technique is more effective than removing the item explicitly by
      calling the <code>pop_back()</code> method of the <code>circular_buffer</code>. This claim is based on the
      assumption that an assignment (replacement) of a new item into an old one is more effective than a destruction
      (removal) of an old item and a consequent inplace construction (insertion) of a new item.
    </p>
    <p>
      For comparison of bounded buffers based on different containers compile and run <a href=
      "../test/bounded_buffer_comparison.cpp">bounded_buffer_comparison.cpp</a>. The test should reveal the bounded
      buffer based on the <code>circular_buffer</code> is most effective closely followed by the
      <code>std::deque</code> based bounded buffer. (In praxis the result may be different because the test is affected
      by external factors such as immediate CPU load.)
    </p>
    <h2>
      <a name="notes" id="notes">Notes</a>
    </h2>
    <ol>
      <li>
        <a name="note1" id="note1"></a>
        <p>
          An indepth definition of a circular buffer can be found at <a href=
          "http://en.wikipedia.org/wiki/Circular_buffer">Wikipedia</a>.
        </p>
      </li>
      <li>
        <a name="note2" id="note2"></a>
        <p>
          A good implementation of smart pointers is included in <a href="../../smart_ptr/">Boost</a>.
        </p>
      </li>
      <li>
        <a name="note3" id="note3"></a>
        <p>
          Never create a circular buffer of <code>std::auto_ptr</code> . Refer to <a href=
          "http://www.aristeia.com">Scott Meyers</a> ' excellent book <em>Effective STL</em> for a detailed discussion.
          (Meyers S., <i>Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</i>.
          Addison-Wesley, 2001.)
        </p>
      </li>
    </ol><br>
    <h2>
      <a name="see" id="see">See also</a>
    </h2>
    <p>
      <code><a href="circular_buffer_space_optimized.html">boost::circular_buffer_space_optimized</a>, <a href=
      "http://www.sgi.com/tech/stl/Vector.html">std::vector</a>, <a href=
      "http://www.sgi.com/tech/stl/List.html">std::list</a>, <a href=
      "http://www.sgi.com/tech/stl/Deque.html">std::deque</a></code>
    </p><br>
    <h2>
      <a name="ack" id="ack">Acknowledgments</a>
    </h2>
    <p>
      The <code>circular_buffer</code> has a short history. Its first version was a <code>std::deque</code> adaptor.
      This container was not very effective because of many reallocations when inserting/removing an element. Thomas
      Wenish did a review of this version and motivated me to create a circular buffer which allocates memory at once
      when created.
    </p>
    <p>
      The second version adapted <code>std::vector</code> but it has been abandoned soon because of limited control
      over iterator invalidation.
    </p>
    <p>
      The current version is a full-fledged STL compliant container. Pavel Vozenilek did a thorough review of this
      version and came with many good ideas and improvements. Also, I would like to thank Howard Hinnant, Nigel Stewart
      and everyone who participated at the formal review for valuable comments and ideas.
    </p>
    <hr size="1">
    <table id="footer" width="100%" border="0">
      <tr valign="top">
        <td valign="top" align="left">
          <p>
            <small>Copyright  2003-2006 Jan Gaspar</small>
          </p>
          <p>
            <small>Use, modification, and distribution is subject to the Boost Software License, Version 1.0.<br>
            (See accompanying file <code>LICENSE_1_0.txt</code> or copy at <a href=
            "http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>.)</small>
          </p>
        </td>
        <td valign="top" align="right">
          <a href="http://validator.w3.org/check?url=referer"><img src="valid-html40.png" width="88" height="31" alt=
          "Valid HTML 4.0!" border="0"></a>
        </td>
      </tr>
    </table>
  </body>
</html>
