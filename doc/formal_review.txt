   1  -------------------------------------------------------------------------
   2  FORMAL REVIEW HISTORY OF THE CIRCULAR BUFFER
   3  -------------------------------------------------------------------------
   4  
   5  Date: Thu, 4 Mar 2004 04:37:22 -0800 (PST) 
   6  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
   7  To: boost@lists.boost.org 
   8  Subject: [boost] circular_buffer v3.6 
   9  
  10      
  11  Hello all!
  12  
  13  New version of the circular_buffer is available. It
  14  can be found at
  15  http://groups.yahoo.com/group/boost/files/circular_buffer_v3.6.zip
  16  
  17  Release notes:
  18  - fixed bug regarding not destroyed elements
  19  - requirements for element types were changed to
  20  CopyConstructible concept
  21  - changed debug support classes - no dynamic memory
  22  allocation needed
  23  - changed debug support for invalidated iterators:
  24  assertion raised also when used iterator which points
  25  to the overwritten element
  26  - added allocator& get_allocator() /* NONCONST */
  27  {...} method
  28  - added functionality to set_capacity() and resize()
  29  methods
  30  - changed circular_buffer_space_optimized constructor
  31  signatures
  32  
  33  Regards
  34  
  35  Jan
  36  
  37  
  38  -------------------------------------------------------------------------
  39  
  40  To: boost@lists.boost.org 
  41  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
  42  Date: Fri, 5 Mar 2004 03:16:30 +0100 
  43  Subject: [boost] Formal Review: Circular Buffer 
  44  
  45      
  46  
  47  The review of Jan Gaspar's Circular Buffer
  48  library starts today (March 5th) and runs for 10 days.
  49  
  50  
  51  Latest version of the library is available at:
  52  http://groups.yahoo.com/group/boost/files/circular_buffer_v3.6.zip
  53  
  54  
  55  What it is:
  56    Circular buffer (also known as ring or
  57    cyclic buffer) is container with fixed
  58    upper limit on number of elements inside.
  59  
  60    When capacity gets exhausted newly inserted
  61    elements will cause oldest elements to get
  62    dropped out.
  63  
  64  
  65  What makes the library Boost candidate:
  66    - it provides often used functionality,
  67    - it is STL compliant generic solution,
  68    - it is designed for CPU/memory efficiency,
  69    - it is fully documented and tested,
  70    - it contains extensive debug support,
  71    - it has been informally reviewed for long time.
  72  
  73  
  74  Discovered problems in code or in documentation,
  75  missing features, portability issues
  76  and finally opinion whether the library belongs
  77  to Boost is welcomed.
  78  
  79  /Pavel
  80  
  81  
  82  
  83  -------------------------------------------------------------------------
  84  
  85  To: boost@lists.boost.org 
  86  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
  87  Date: Fri, 5 Mar 2004 03:23:17 +0100 
  88  Subject: [boost] Re: Formal Review: Circular Buffer 
  89  
  90      
  91  
  92  > The review of Jan Gaspar's Circular Buffer
  93  > library starts today (March 5th) and runs for 10 days.
  94  >
  95  
  96  Here's result of first look into 3.6.
  97  More details will follow later.
  98  
  99  /Pavel
 100  
 101  ________________________________________________
 102  1. docs: the table "Friend Functions" should
 103     be rather "Standalone Functions" and should mention
 104     swap, <=, >= as well.
 105  ________________________________________________
 106  2. base.hpp: standalone function
 107     bool operator > (...) should be added.
 108  ________________________________________________
 109  3. docs: why is the (SGI) in paragraph
 110     "Model of" and why it is twice there?
 111  ________________________________________________
 112  4. docs: "Type Requirements": doesn't the T need
 113     to be DefaultConstructible as well, e.g.
 114     to support push_back(void)?
 115  
 116     Maybe the title should be "Element Type Requirements".
 117  ________________________________________________
 118  5. compiling test on BCB 6.4, adaptor.hpp:
 119  
 120  in snippet:
 121  
 122  #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
 123      reference operator [] (size_type n) { return circular_buffer<T,
 124  Alloc>::operator[](n); }
 125      return_value_type operator [] (size_type n) const { return
 126  circular_buffer<T, Alloc>::operator[](n); } <<<=== here
 127  #else
 128      using circular_buffer<T, Alloc>::operator[];
 129  #endif
 130  
 131  the line starting with "return_value_type" fails to compile
 132  with error:
 133  
 134  ------
 135  [C++ Error] adaptor.hpp(67): E2303 Type name expected
 136    Full parser context
 137      base_test.cpp(9): #include
 138  C:\Temp\temp\circular_buffer3.6\circular_buffer\libs\circular_buffer\test
 139  \test.hpp
 140      test.hpp(16): #include
 141  C:\Temp\temp\circular_buffer3.6\circular_buffer\libs\circular_buffer\test
 142  \../../../boost/circular_buffer.hpp
 143      circular_buffer.hpp(54): #include
 144  C:\Temp\temp\circular_buffer3.6\circular_buffer\libs\circular_buffer\test
 145  \../../../boost/circular_buffer/adaptor.hpp
 146      adaptor.hpp(16): namespace boost
 147      adaptor.hpp(32): class circular_buffer_space_optimized<T,Alloc>
 148  [C++ Error] adaptor.hpp(67): E2139 Declaration missing ;
 149    Full parser context
 150      base_test.cpp(9): #include
 151  C:\Temp\temp\circular_buffer3.6\circular_buffer\libs\circular_buffer\test
 152  \test.hpp
 153      test.hpp(16): #include
 154  C:\Temp\temp\circular_buffer3.6\circular_buffer\libs\circular_buffer\test
 155  \../../../boost/circular_buffer.hpp
 156      circular_buffer.hpp(54): #include
 157  C:\Temp\temp\circular_buffer3.6\circular_buffer\libs\circular_buffer\test
 158  \../../../boost/circular_buffer/adaptor.hpp
 159      adaptor.hpp(16): namespace boost
 160      adaptor.hpp(32): class circular_buffer_space_optimized<T,Alloc>
 161  ------
 162  
 163  When I change return type to "value_type" all
 164  compiles OK.
 165  
 166  This could be some BCB quirk.
 167  ________________________________________________
 168  6. compiling test on Intel C++ 7.0: all is OK.
 169  ________________________________________________
 170  7. compiling base_test.cpp on VC6.5: I am getting
 171  "user breakpoint" within Boost.Test. This may be
 172  regression of Test, though. I'll try to dig deeper.
 173  ________________________________________________
 174  EOF
 175  
 176  
 177  
 178  
 179  -------------------------------------------------------------------------
 180  
 181  
 182  To: boost@lists.boost.org 
 183  From: "Giovanni Bajo" <giovannibajo@libero.it>   
 184  Date: Fri, 5 Mar 2004 06:47:16 +0100 
 185  Subject: [boost] Re: Formal Review: Circular Buffer 
 186  
 187      
 188  Pavel Vozenilek wrote:
 189  
 190  > Discovered problems in code or in documentation,
 191  > missing features, portability issues and finally opinion whether the 
 192  library
 193  belongs
 194  > to Boost is welcomed.
 195  
 196  I'm trying to compile the library with GCC 3.4. I get the following 
 197  errors:
 198  
 199  ../../../boost/circular_buffer/debug.hpp: In member function `void
 200  boost::cb_details::cb_iterator_registry::invalidate_iterators(const
 201  Condition&)':
 202  ../../../boost/circular_buffer/debug.hpp:60: error: invalid use of 
 203  undefined
 204  type `const struct boost::cb_details::cb_iterator_base'
 205  ../../../boost/circular_buffer/debug.hpp:22: error: forward declaration 
 206  of
 207  `const struct boost::cb_details::cb_iterator_base'
 208  The type appears to be undefined at the point of use. I know this is 
 209  within a
 210  template function, but the type is non-dependent, so it must be defined 
 211  before
 212  its use. An out-of-class definition at the end of the file seems to 
 213  suffice.
 214  
 215  
 216  ../../../boost/circular_buffer/base.hpp:139: error: using typedef-name
 217  `boost::circular_buffer<T, Alloc>::iterator' after `struct'
 218  ../../../boost/circular_buffer/base.hpp:140: error: using typedef-name
 219  `boost::circular_buffer<T, Alloc>::const_iterator' after `struct'
 220  Verified, and the code really does try to use a typedef-name while 
 221  declaring
 222  friendship, which is invalid.
 223  
 224  
 225  ../../../boost/circular_buffer/adaptor.hpp:369: error: dependent-name
 226  `boost::cb_details::cb_iterator_category_traits<InputIterator>::tag' is 
 227  parsed
 228  as a non-type, but instantiation yields a type
 229  ../../../boost/circular_buffer/adaptor.hpp:369: note: say `typename
 230  boost::cb_details::cb_iterator_category_traits<InputIterator>::tag' if 
 231  a type
 232  is meant
 233  Just as it says. The same happens at line 412. Then in base.hpp, lines 
 234  570,
 235  827, 953, 1105.
 236  
 237  After fixing the above, I was able to compile & run adaptor_test and 
 238  base_test
 239  with no errors detected.
 240  -- 
 241  Giovanni Bajo
 242  
 243  
 244  
 245  -------------------------------------------------------------------------
 246  
 247  To: boost@lists.boost.org 
 248  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
 249  Date: Fri, 5 Mar 2004 17:31:04 +1100 
 250  Subject: [boost] Re: Formal Review: Circular Buffer 
 251  
 252      
 253  Hi Jan,
 254  
 255  This is not my final review, but just some comment and questions.
 256  It's based solely on my reading of the docs.
 257  
 258  1. your rationale mentions many characteristics that I would expect of
 259  std::deque. Do you have any idea
 260     how big the performance difference is?
 261  
 262  2. You mention "Guarantee of basic exception safety" as a design 
 263  criteria. I
 264  would expect many operations
 265      to have a stronger guarantee.
 266  
 267  3. you write "In fact the circular_buffer is defined in the file
 268  boost/circular_buffer/base.hpp, but it is necessary to ". I don't see
 269     why the user should be bothered with this implementation detail.
 270  
 271  4. Type Requirements: don't T need to be Assignable too?
 272  
 273  5. you could remove one version of push_back and push_front by using 
 274  default
 275  arguments. Similar for insert()/rinsert()
 276  
 277  6. What's the use of "return_value_type" ?return_value_type  operator[]
 278  (size_type index) const
 279          Return the element at the index position.
 280    Should it not be const_reference?
 281  
 282  7. when you state contracts like
 283  Precondition:
 284  *(this).size() > index
 285  don't you mean (*this).size() ? I would prefer that you omitted this
 286  entirely.
 287  
 288  8. maybe you should add const_pointer data() const ?
 289  
 290  9 I assume you provide the basic exception safety for set_capacity().
 291  However, I think you could achieve the strong guarantee
 292     by (1) allocating the new buffer and (2) start to copy elements 
 293  [might
 294  throw] (3) swap the two buffers upon completion. The same goes for
 295     resize(). Why are they both provided? (If you made resizes 2nd 
 296  argument
 297  to be the bool, then how would they differ?]
 298  
 299  10.  Can't the exception guarantee for the copy-constructor be stronger 
 300  too?
 301  (and assign(), and push_back(), push_front(), insert() )
 302  
 303  11. Some operations must be nothrow: swap(), size(), capaciity(),
 304  pop_back(), pop_front().
 305  
 306  Besides that, I think you documentation is excellent.
 307  
 308  br
 309  
 310  Thorsten
 311  
 312  
 313  -------------------------------------------------------------------------
 314  
 315  Date: Thu, 4 Mar 2004 22:42:48 -0800 (PST) 
 316  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
 317  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
 318  To: boost@lists.boost.org 
 319  
 320      
 321  Hi Pavel!
 322   
 323  > ________________________________________________
 324  > 1. docs: the table "Friend Functions" should
 325  >    be rather "Standalone Functions" and should
 326  > mention
 327  >    swap, <=, >= as well.
 328  Agree.
 329  
 330  > ________________________________________________
 331  > 2. base.hpp: standalone function
 332  >    bool operator > (...) should be added.
 333  It is there!
 334  
 335  template <class T, class Alloc>
 336  inline bool operator >(const circular_buffer<T,Alloc>&
 337  lhs, const circular_buffer<T, Alloc>& rhs) {
 338      return rhs < lhs;
 339  }
 340  
 341  > ________________________________________________
 342  > 3. docs: why is the (SGI) in paragraph
 343  >    "Model of" and why it is twice there?
 344  The (SGI) is there because it is different from the
 345  standard. See
 346  http://boost.org/libs/concept_check/reference.htm for
 347  details.
 348  
 349  > ________________________________________________
 350  > 4. docs: "Type Requirements": doesn't the T need
 351  >    to be DefaultConstructible as well, e.g.
 352  >    to support push_back(void)?
 353  Yes, but DefaultConstructible is needed only if you
 354  use such a method. In general it is not needed. For
 355  example you can just create empty circular_buffer and
 356  use push_back(T&). In this case T doesn't have to be
 357  DefaultConstructible.
 358   
 359  >    Maybe the title should be "Element Type
 360  > Requirements".
 361  OK.
 362  
 363  Jan
 364  
 365  
 366  -------------------------------------------------------------------------
 367  
 368  Date: Fri, 5 Mar 2004 01:27:03 -0800 (PST) 
 369  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
 370  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
 371  To: boost@lists.boost.org 
 372  
 373      
 374  Hi Thorsten!
 375  
 376  --- Thorsten Ottosen <nesotto@cs.auc.dk> wrote:
 377  > Hi Jan,
 378  > 
 379  > This is not my final review, but just some comment
 380  > and questions.
 381  > It's based solely on my reading of the docs.
 382  > 
 383  > 1. your rationale mentions many characteristics that
 384  > I would expect of
 385  > std::deque. Do you have any idea
 386  >    how big the performance difference is?
 387  The memory is allocated at once, that's the biggest
 388  difference.
 389  
 390  > 
 391  > 2. You mention "Guarantee of basic exception safety"
 392  > as a design criteria. I
 393  > would expect many operations
 394  >     to have a stronger guarantee.
 395  Of cource, some methods provide stronger guarantee,
 396  but in general the container povides just basic
 397  exception safety. For some methods (e.g. insert) it is
 398  impossible to provide stronger guarantees.
 399  
 400  > 
 401  > 3. you write "In fact the circular_buffer is defined
 402  > in the file
 403  > boost/circular_buffer/base.hpp, but it is necessary
 404  > to ". I don't see
 405  >    why the user should be bothered with this
 406  > implementation detail.
 407  You're right.
 408  
 409  > 
 410  > 4. Type Requirements: don't T need to be Assignable
 411  > too?
 412  Just no!
 413  
 414  > 
 415  > 5. you could remove one version of push_back and
 416  > push_front by using default
 417  > arguments. Similar for insert()/rinsert()
 418  I don't know if this is good idea or not, but all STL
 419  implementations I've seen have containers with both
 420  methods (one with default param and one without).
 421  
 422  > 
 423  > 6. What's the use of "return_value_type"
 424  > ?return_value_type  operator[]
 425  > (size_type index) const
 426  >         Return the element at the index position.
 427  >   Should it not be const_reference?
 428  return_value_type is just optimization. It is
 429  const_reference for objects and value_type for
 430  primitive types.
 431  
 432  > 
 433  > 7. when you state contracts like
 434  > Precondition:
 435  > *(this).size() > index
 436  > don't you mean (*this).size() ? I would prefer that
 437  > you omitted this
 438  > entirely.
 439  This is just typo. Anyway I would retain the
 440  precondition.
 441  
 442  > 
 443  > 8. maybe you should add const_pointer data() const ?
 444  It is not possible. data() is mutating operation. See
 445  the source code.
 446  
 447  > 
 448  > 9 I assume you provide the basic exception safety
 449  > for set_capacity().
 450  > However, I think you could achieve the strong
 451  > guarantee
 452  >    by (1) allocating the new buffer and (2) start to
 453  > copy elements [might
 454  > throw] (3) swap the two buffers upon completion. The
 455  > same goes for
 456  >    resize(). Why are they both provided? (If you
 457  > made resizes 2nd argument
 458  > to be the bool, then how would they differ?]
 459  Yes, it works exactly like this. But the statement
 460  about provided exception safety covers the whole
 461  container.
 462  
 463  > 
 464  > 10.  Can't the exception guarantee for the
 465  > copy-constructor be stronger too?
 466  > (and assign(), and push_back(), push_front(),
 467  > insert() )
 468  No for insert()/rinsert(), push_xxx(), data() and
 469  erase(). See the source code.
 470  
 471  > 
 472  > 11. Some operations must be nothrow: swap(), size(),
 473  > capaciity(),
 474  > pop_back(), pop_front().
 475  Yes, they are. It is not written explicitly in the
 476  documentation (there is just no "Exceptions" section
 477  for each method).
 478  
 479  Jan
 480  
 481  
 482  -------------------------------------------------------------------------
 483  
 484  To: boost@lists.boost.org 
 485  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
 486  Date: Fri, 5 Mar 2004 21:22:29 +1100 
 487  Subject: [boost] Re: Re: Formal Review: Circular Buffer 
 488  
 489      
 490  "Jan Gaspar" <jano_gaspar@yahoo.com> wrote in message
 491  news:20040305092703.88723.qmail@web41506.mail.yahoo.com...
 492  
 493  > 1. your rationale mentions many characteristics that
 494  > I would expect of
 495  > std::deque. Do you have any idea
 496  >    how big the performance difference is?
 497  The memory is allocated at once, that's the biggest
 498  difference.
 499  ------
 500  What I'm looking for is some more evidence that the data structure is 
 501  really
 502  faster. I think that
 503  is relevant since that is your reason d'etre (or something, I never 
 504  took
 505  French in highschool :-) )
 506  for the container.
 507  
 508  >
 509  > 2. You mention "Guarantee of basic exception safety"
 510  > as a design criteria. I
 511  > would expect many operations
 512  >     to have a stronger guarantee.
 513  Of cource, some methods provide stronger guarantee,
 514  but in general the container povides just basic
 515  exception safety. For some methods (e.g. insert) it is
 516  impossible to provide stronger guarantees.
 517  -------
 518  I guess I would like to know the exact guarantee of each function. It 
 519  will
 520  be important
 521  for eg. when I have to provide a pointer version of circular_buffer for 
 522  my
 523  smart containers.
 524  
 525  > 4. Type Requirements: don't T need to be Assignable
 526  > too?
 527  Just no!
 528  ---
 529  Then how is an element overwritten?
 530  
 531  > 5. you could remove one version of push_back and
 532  > push_front by using default
 533  > arguments. Similar for insert()/rinsert()
 534  I don't know if this is good idea or not, but all STL
 535  implementations I've seen have containers with both
 536  methods (one with default param and one without).
 537  ----
 538  ok. I must admit that I have never seen this before. For example, my
 539  dinkumware only has vector::push_back( T& );
 540  
 541  >
 542  > 7. when you state contracts like
 543  > Precondition:
 544  > *(this).size() > index
 545  > don't you mean (*this).size() ? I would prefer that
 546  > you omitted this
 547  > entirely.
 548  This is just typo. Anyway I would retain the
 549  precondition.
 550  ----
 551  yes, I'm not talking about removing the precondition. I just don't 
 552  think
 553  'this->' adds
 554  anything. size() > index would be fine to me.
 555  
 556  >
 557  > 8. maybe you should add const_pointer data() const ?
 558  It is not possible. data() is mutating operation. See
 559  the source code.
 560  ---------
 561  ok. then maybe one should get more hints about this mutation (I did not 
 562  have
 563  a clue), maybe like
 564  c.prepare_array();
 565  foo( &*c.begin() );
 566  And what complexity does it involves (linear, I assume)?
 567  
 568  > 9 I assume you provide the basic exception safety
 569  > for set_capacity().
 570  > However, I think you could achieve the strong
 571  > guarantee
 572  >    by (1) allocating the new buffer and (2) start to
 573  > copy elements [might
 574  > throw] (3) swap the two buffers upon completion. The
 575  > same goes for
 576  >    resize(). Why are they both provided? (If you
 577  > made resizes 2nd argument
 578  > to be the bool, then how would they differ?]
 579  Yes, it works exactly like this. But the statement
 580  about provided exception safety covers the whole
 581  container.
 582  --------
 583  I think that saying that your container gives the basic exception 
 584  safety
 585  guarantee
 586  is too weak a statement. Afterall, it *must* provide that guarantee. 
 587  The
 588  standard
 589  specifies which operations that differs and under which cercumstances 
 590  for T.
 591  
 592  >
 593  > 10.  Can't the exception guarantee for the
 594  > copy-constructor be stronger too?
 595  > (and assign(), and push_back(), push_front(),
 596  > insert() )
 597  No for insert()/rinsert(), push_xxx(), data() and
 598  erase(). See the source code.
 599  -------
 600  Ok, let's try push_back:
 601  
 602    void push_back(param_value_type item) {
 603          if (full()) {
 604              if (empty())
 605                  return; (*)
 606              replace_last(item); // can throw
 607              increment(m_last); // nothrow
 608              m_first = m_last;   // nothrow
 609          } else {
 610              m_alloc.construct(m_last, item); // can throw
 611              increment(m_last);                     // nothrow
 612              ++m_size;                                 // nothrow
 613          }
 614      }
 615  
 616  AFAICT, you have the strong property unless you cannot roll-back stuff 
 617  in
 618  replace_last/construct.
 619  (*) it might be good to document that push_back() can choose *not* to 
 620  insert
 621  something. For example,
 622       it would be good for me to know when I write a pointer wrapper.
 623  
 624  
 625  >
 626  > 11. Some operations must be nothrow: swap(), size(),
 627  > capaciity(),
 628  > pop_back(), pop_front().
 629  Yes, they are. It is not written explicitly in the
 630  documentation (there is just no "Exceptions" section
 631  for each method).
 632  -----
 633  Ok, I can live with that :-). You could consider one line that said 
 634  that.
 635  
 636  br
 637  
 638  Thorsten
 639  
 640  
 641  -------------------------------------------------------------------------
 642  
 643  To: boost@lists.boost.org 
 644  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
 645  Date: Fri, 5 Mar 2004 11:58:03 +0100 
 646  Subject: [boost] Re: Re: Formal Review: Circular Buffer 
 647  
 648      
 649  
 650  "Jan Gaspar" <jano_gaspar@yahoo.com> wrote
 651  
 652   ________________________________________________
 653  > 3. docs: why is the (SGI) in paragraph
 654  >    "Model of" and why it is twice there?
 655  The (SGI) is there because it is different from the
 656  standard. See
 657  http://boost.org/libs/concept_check/reference.htm for
 658  details.
 659  
 660  Maybe it could be (SGI specific).
 661  
 662  /Pavel
 663  
 664  
 665  -------------------------------------------------------------------------
 666  
 667  To: boost@lists.boost.org 
 668  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
 669  Date: Fri, 5 Mar 2004 12:04:09 +0100 
 670  Subject: [boost] Re: Re: Formal Review: Circular Buffer 
 671  
 672      
 673  
 674  "Thorsten Ottosen" <nesotto@cs.auc.dk> wrote
 675  
 676  > > 1. your rationale mentions many characteristics that
 677  > > I would expect of  std::deque. Do you have any idea
 678  > >  how big the performance difference is?
 679  >
 680  > What I'm looking for is some more evidence that the data structure is
 681  really
 682  > faster. I think that
 683  > is relevant since that is your reason d'etre (or something, I never 
 684  took
 685  > French in highschool :-) )  for the container.
 686  >
 687  Higher speed is welcomed side-effect of implementation here
 688  (no allocations).
 689  
 690  Choosen data structure provides a lot of flexibility,
 691  e.g. to implement debug support. That would be hard/impossible
 692  with std::deque.
 693  
 694  /Pavel
 695  
 696  
 697  -------------------------------------------------------------------------
 698  
 699  Date: Fri, 5 Mar 2004 05:37:10 -0800 (PST) 
 700  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
 701  Subject: Re: [boost] Re: Re: Formal Review: Circular Buffer 
 702  To: boost@lists.boost.org 
 703  
 704      
 705  Hello!
 706  
 707  > 
 708  > > 1. your rationale mentions many characteristics
 709  > that
 710  > > I would expect of
 711  > > std::deque. Do you have any idea
 712  > >    how big the performance difference is?
 713  > The memory is allocated at once, that's the biggest
 714  > difference.
 715  > ------
 716  > What I'm looking for is some more evidence that the
 717  > data structure is really
 718  > faster. I think that
 719  > is relevant since that is your reason d'etre (or
 720  > something, I never took
 721  > French in highschool :-) )
 722  > for the container.
 723  I agree with Pavel. Moreover you would have no control
 724  over iterator invalidation in std::deque.
 725  
 726  
 727  > 
 728  > >
 729  > > 2. You mention "Guarantee of basic exception
 730  > safety"
 731  > > as a design criteria. I
 732  > > would expect many operations
 733  > >     to have a stronger guarantee.
 734  > Of cource, some methods provide stronger guarantee,
 735  > but in general the container povides just basic
 736  > exception safety. For some methods (e.g. insert) it
 737  > is
 738  > impossible to provide stronger guarantees.
 739  > -------
 740  > I guess I would like to know the exact guarantee of
 741  > each function. It will
 742  > be important
 743  > for eg. when I have to provide a pointer version of
 744  > circular_buffer for my
 745  > smart containers.
 746  Ok, agree. Every method will have statement about its
 747  exception safety guarantee in the documentation.
 748  
 749  > 
 750  > > 4. Type Requirements: don't T need to be
 751  > Assignable
 752  > > too?
 753  > Just no!
 754  > ---
 755  > Then how is an element overwritten?
 756  Look at the replace() method in the source code.
 757  
 758  
 759  > >
 760  > > 7. when you state contracts like
 761  > > Precondition:
 762  > > *(this).size() > index
 763  > > don't you mean (*this).size() ? I would prefer
 764  > that
 765  > > you omitted this
 766  > > entirely.
 767  > This is just typo. Anyway I would retain the
 768  > precondition.
 769  > ----
 770  > yes, I'm not talking about removing the
 771  > precondition. I just don't think
 772  > 'this->' adds
 773  > anything. size() > index would be fine to me.
 774  Agree.
 775  
 776  > 
 777  > >
 778  > > 8. maybe you should add const_pointer data() const
 779  > ?
 780  > It is not possible. data() is mutating operation.
 781  > See
 782  > the source code.
 783  > ---------
 784  > ok. then maybe one should get more hints about this
 785  > mutation (I did not have
 786  > a clue), maybe like
 787  > c.prepare_array();
 788  > foo( &*c.begin() );
 789  There are some words regarding iterator invalidation
 790  in the method documentation.
 791  
 792  > And what complexity does it involves (linear, I
 793  > assume)?
 794  Yes, linear.
 795  
 796  Jan
 797  
 798  
 799  -------------------------------------------------------------------------
 800  
 801  To: boost@lists.boost.org 
 802  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
 803  Date: Sat, 6 Mar 2004 01:04:56 +1100 
 804  Subject: [boost] Re: Re: Re: Formal Review: Circular Buffer 
 805  
 806      
 807  One last thing:
 808  
 809  > > 8. maybe you should add const_pointer data() const
 810  > ?
 811  > It is not possible. data() is mutating operation.
 812  > See
 813  > the source code.
 814  > ---------
 815  > ok. then maybe one should get more hints about this
 816  > mutation (I did not have
 817  > a clue), maybe like
 818  > c.prepare_array();
 819  > foo( &*c.begin() );
 820  There are some words regarding iterator invalidation
 821  in the method documentation.
 822  ---
 823  ok, I'm not super religious about it, but my line of thought goes like 
 824  this:
 825  
 826  if a programmer sees this kind of code:
 827  
 828  circular_buffer<T> cb;
 829  ...
 830  foo( cb.data() );
 831  
 832  he would have to look at documentation to know what's going on (he 
 833  could be
 834  a maintenance programmer who have no
 835  earlier knowlegde of circular buffer). data() is a very
 836  innocent word and I doubt that people in general would think all 
 837  iterator
 838  were invalidated. I also doubt that they would think
 839  it was a linear time operation. Now, that's why I think it might be 
 840  possible
 841  to give programmer just a little more hint about
 842  what might be going on by using a *verb* in the functions name, eg.
 843  
 844  compute_data();
 845  prepare_data();
 846  prepare_array();
 847  linearize_data();
 848  
 849  It's probably good to get other's oppinion about this too.
 850  
 851  br
 852  
 853  Thorsten
 854  
 855  
 856  -------------------------------------------------------------------------
 857  
 858  To: boost@lists.boost.org 
 859  Subject: Re: [boost] Re: Re: Re: Formal Review: Circular Buffer 
 860  From: "Jeremy Maitin-Shepard" <jbms@attbi.com>   
 861  Date: Fri, 05 Mar 2004 13:54:05 -0500 
 862  
 863      
 864  Perhaps in addition to a data() function, it would be useful if the
 865  container provided constant-time access to the data as two arrays.
 866  Perhaps something like std::pair<T *, T *> first_range() and 
 867  std::pair<T
 868  *, T *> second_range().  (Where these can also be made available in
 869  const-form, since no internal modification is necessary)  Then as
 870  Thorsten suggested, an operation such as linearize or reorder could be
 871  added which orders the elements such that first_range() contains all of
 872  the elements.
 873  
 874  -- 
 875  Jeremy Maitin-Shepard
 876  
 877  
 878  -------------------------------------------------------------------------
 879  
 880  To: boost@lists.boost.org 
 881  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
 882  Date: Fri, 5 Mar 2004 20:07:24 +0100 
 883  Subject: [boost] Re: Re: Re: Re: Formal Review: Circular Buffer 
 884  
 885      
 886  
 887  "Jeremy Maitin-Shepard" <jbms@attbi.com> wrote
 888  
 889  > Perhaps in addition to a data() function, it would be useful if the
 890  > container provided constant-time access to the data as two arrays.
 891  > Perhaps something like std::pair<T *, T *> first_range() and 
 892  std::pair<T
 893  > *, T *> second_range().  (Where these can also be made available in
 894  > const-form, since no internal modification is necessary)  Then as
 895  > Thorsten suggested, an operation such as linearize or reorder could 
 896  be
 897  > added which orders the elements such that first_range() contains all 
 898  of
 899  > the elements.
 900  >
 901  data() does 'linearization' when needed (it was called flatten()
 902  when I proposed it ago).
 903  
 904  Do you have an example where returning two arrays is much better than
 905  optional reordering by data()?  What kind of algorithm would be better 
 906  to
 907  be called twice?
 908  
 909  /Pavel
 910  
 911  
 912  
 913  -------------------------------------------------------------------------
 914  
 915  To: boost@lists.boost.org 
 916  Subject: Re: [boost] Re: Re: Re: Re: Formal Review: Circular Buffer 
 917  From: "Jeremy Maitin-Shepard" <jbms@attbi.com>   
 918  Date: Fri, 05 Mar 2004 15:21:03 -0500 
 919  
 920      
 921  The advantage is that the two ranges can be returned without any
 922  reordering.  For instance, if the circular buffer is being used as a
 923  write buffer, it might prove more efficient to call the underlying
 924  write twice, once on each portion of the array, than to reorder the
 925  array (and call the underlying write only once).
 926  
 927  -- 
 928  Jeremy Maitin-Shepard
 929  
 930  
 931  -------------------------------------------------------------------------
 932  
 933  Date: Sat, 06 Mar 2004 15:40:58 -0500 
 934  To: boost@lists.boost.org, boost@lists.boost.org 
 935  From: "Beman Dawes" <bdawes@acm.org>   
 936  Subject: Re: [boost] Re: Re: Re: Formal Review: Circular Buffer 
 937  
 938      
 939  At 09:04 AM 3/5/2004, Thorsten Ottosen wrote:
 940   >One last thing:
 941   >
 942   >> > 8. maybe you should add const_pointer data() const
 943   >> ?
 944   >> It is not possible. data() is mutating operation.
 945   >> See
 946   >> the source code.
 947   >> ---------
 948   >> ok. then maybe one should get more hints about this
 949   >> mutation (I did not have
 950   >> a clue), maybe like
 951   >> c.prepare_array();
 952   >> foo( &*c.begin() );
 953   >There are some words regarding iterator invalidation
 954   >in the method documentation.
 955   >---
 956   >ok, I'm not super religious about it, but my line of thought goes 
 957  like
 958   >this:
 959   >
 960   >if a programmer sees this kind of code:
 961   >
 962   >circular_buffer<T> cb;
 963   >...
 964   >foo( cb.data() );
 965   >
 966   >he would have to look at documentation to know what's going on (he 
 967  could 
 968  be
 969   >a maintenance programmer who have no
 970   >earlier knowlegde of circular buffer). data() is a very
 971   >innocent word and I doubt that people in general would think all 
 972  iterator
 973   >were invalidated. I also doubt that they would think
 974   >it was a linear time operation. Now, that's why I think it might be
 975   >possible
 976   >to give programmer just a little more hint about
 977   >what might be going on by using a *verb* in the functions name, eg.
 978   >
 979   >compute_data();
 980   >prepare_data();
 981   >prepare_array();
 982   >linearize_data();
 983   >
 984   >It's probably good to get other's oppinion about this too.
 985  
 986  FWIW, I agree. Particularly since data() in std::string is const. Verbs 
 987  do 
 988  a better job of indicating meaning.
 989  
 990  --Beman
 991  
 992  
 993  
 994  -------------------------------------------------------------------------
 995  
 996  To: boost@lists.boost.org 
 997  From: "Alberto Barbati" <abarbati@iaanus.com>   
 998  Date: Sun, 07 Mar 2004 12:44:52 +0100 
 999  Subject: [boost] Re: Formal Review: Circular Buffer 
1000  
1001      
1002  Jan Gaspar wrote:
1003  >>>4. Type Requirements: don't T need to be
1004  >>>Assignabletoo?
1005  >>Just no!
1006  >>---
1007  >>Then how is an element overwritten?
1008  > Look at the replace() method in the source code.
1009  
1010  This strikes me. All standard containers require T to be Assignable, so 
1011  I don't understand the rationale for dropping such requirement. Does it 
1012  give more freedom? Perhaps yes, but not so much IMHO. Users of 
1013  containers are probably going to provide assignment anyway.
1014  
1015  Suppose that T *is* assignable, is destroy+copy construction better 
1016  than 
1017  assignment? Probably no, for several reasons, including:
1018  
1019  1) assigment is probably more efficient. In particular it might avoid 
1020  destruction/reconstruction of sub-objects non related with the class 
1021  invariant (for example: buffers, mutexes, etc.).
1022  
1023  2) with the dtor/ctor idiom, if the ctor throws an exception, the old 
1024  element is lost and you can't do anything about it, so the container 
1025  cannot provide more than the basic guarantee for any method that might 
1026  overwrite elements. However, the user might implement assigment with 
1027  the 
1028  strong guarantee, the container might leverage on that and provide the 
1029  strong guarantee too at least for methods that might overwrite a single 
1030  element such as push_back/push_front. (Of course, the user might 
1031  implement assignment so badly that it doesn't provide even the basic 
1032  guarantee and the container could not recover from that, but a library 
1033  such not try to outsmart the user... too much ;).
1034  
1035  Just my opinion,
1036  
1037  Alberto
1038  
1039  
1040  -------------------------------------------------------------------------
1041  
1042  To: boost@lists.boost.org 
1043  From: "David Abrahams" <dave@boost-consulting.com>   
1044  Date: Sun, 07 Mar 2004 08:42:43 -0500 
1045  Subject: [boost] Re: Formal Review: Circular Buffer 
1046  
1047      
1048  Alberto Barbati <abarbati@iaanus.com> writes:
1049  
1050  > Suppose that T *is* assignable, is destroy+copy construction better
1051  > than assignment? Probably no, for several reasons, including:
1052  >
1053  > 1) assigment is probably more efficient. In particular it might avoid
1054  >    destruction/reconstruction of sub-objects non related with the
1055  >    class invariant (for example: buffers, mutexes, etc.).
1056  >
1057  > 2) with the dtor/ctor idiom, if the ctor throws an exception, the old
1058  >    element is lost and you can't do anything about it, so the
1059  >    container cannot provide more than the basic guarantee for any
1060  >    method that might overwrite elements. However, the user might
1061  >    implement assigment with the strong guarantee, the container might
1062  >    leverage on that and provide the strong guarantee too at least for
1063  >    methods that might overwrite a single element such as
1064  >    push_back/push_front. (Of course, the user might implement
1065  >    assignment so badly that it doesn't provide even the basic
1066  >    guarantee and the container could not recover from that, but a
1067  >    library such not try to outsmart the user... too much ;).
1068  >
1069  > Just my opinion,
1070  
1071  Well said.
1072  
1073  -- 
1074  Dave Abrahams
1075  Boost Consulting
1076  www.boost-consulting.com
1077  
1078  
1079  -------------------------------------------------------------------------
1080  
1081  Date: Sun, 7 Mar 2004 13:31:40 -0800 (PST) 
1082  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
1083  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
1084  To: boost@lists.boost.org 
1085  
1086      
1087  
1088  --- David Abrahams <dave@boost-consulting.com> wrote:
1089  > Alberto Barbati <abarbati@iaanus.com> writes:
1090  > 
1091  > > Suppose that T *is* assignable, is destroy+copy
1092  > construction better
1093  > > than assignment? Probably no, for several reasons,
1094  > including:
1095  > >
1096  > > 1) assigment is probably more efficient. In
1097  > particular it might avoid
1098  > >    destruction/reconstruction of sub-objects non
1099  > related with the
1100  > >    class invariant (for example: buffers, mutexes,
1101  > etc.).
1102  I agree the assignment is more efficient. If you dig
1103  in the code little bit you will find that there is
1104  assignment operation provided for the primitive types.
1105  
1106  
1107  > >
1108  > > 2) with the dtor/ctor idiom, if the ctor throws an
1109  > exception, the old
1110  > >    element is lost and you can't do anything about
1111  > it, so the
1112  > >    container cannot provide more than the basic
1113  > guarantee for any
1114  > >    method that might overwrite elements. However,
1115  > the user might
1116  > >    implement assigment with the strong guarantee,
1117  > the container might
1118  > >    leverage on that and provide the strong
1119  > guarantee too at least for
1120  > >    methods that might overwrite a single element
1121  > such as
1122  > >    push_back/push_front. (Of course, the user
1123  > might implement
1124  > >    assignment so badly that it doesn't provide
1125  > even the basic
1126  > >    guarantee and the container could not recover
1127  > from that, but a
1128  > >    library such not try to outsmart the user...
1129  > too much ;).
1130  > >
1131  > > Just my opinion,
1132  > 
1133  The idea behind the dtor/ctor idiom is like this:
1134  suppose you have full circular_buffer and you want to
1135  push_back a new element (instance of some class). That
1136  means the fron-most element is about to be
1137  overwritten. Now if there will be the assignment idiom
1138  applied the front-most will be assigned to the new one
1139  - it will be not destroyed (no destructor will be
1140  called). IMHO this is not correct. The old element
1141  will not disappear - just its value/state will be
1142  different. I think that the overwrite operation means
1143  destruction of the old object, NOT assignment. What do
1144  you think?
1145  
1146  Jan
1147  
1148  
1149  > Well said.
1150  > 
1151  > -- 
1152  > Dave Abrahams
1153  > Boost Consulting
1154  > www.boost-consulting.com
1155  > 
1156  
1157  
1158  -------------------------------------------------------------------------
1159  
1160  Date: Sun, 7 Mar 2004 20:13:28 -0500 
1161  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
1162  From: "Jeremy Siek" <jsiek@osl.iu.edu>   
1163  To: boost@lists.boost.org 
1164  
1165      
1166  
1167  On Friday, March 5, 2004, at 01:42 AM, Jan Gaspar wrote:
1168  >> ________________________________________________
1169  >> 4. docs: "Type Requirements": doesn't the T need
1170  >>    to be DefaultConstructible as well, e.g.
1171  >>    to support push_back(void)?
1172  > Yes, but DefaultConstructible is needed only if you
1173  > use such a method. In general it is not needed. For
1174  > example you can just create empty circular_buffer and
1175  > use push_back(T&). In this case T doesn't have to be
1176  > DefaultConstructible.
1177  
1178  That means you have to mention this type requirement
1179  in the documentation for the push_back() method.
1180  
1181  Cheers,
1182  Jeremy
1183  
1184  
1185  -------------------------------------------------------------------------
1186  
1187  Date: Sun, 7 Mar 2004 20:23:29 -0500 
1188  Subject: Re: [boost] Formal Review: Circular Buffer 
1189  From: "Jeremy Siek" <jsiek@osl.iu.edu>   
1190  To: boost@lists.boost.org 
1191  
1192      
1193  I have read the documentation for the library, and browsed through the 
1194  test code.
1195  Based on that I recommend acceptance of the circular buffer library. 
1196  Nice work Jan!
1197  
1198  Here are some suggestions.
1199  
1200  This sentences seems unnecessary:
1201       In fact the circular_buffer is defined in the file
1202       boost/circular_buffer/base.hpp, but it is necessary to include the
1203      boost/circular_buffer.hpp in order to use this container
1204  
1205  Have you checked whether CopyConstructible is in fact the only
1206  requirements needed on the type parameter T? For example, I bet
1207  T must also be Assignable. But who knows what other requirements you 
1208  may have
1209  missed (it is easy to miss them). I recommend using concept archetypes 
1210  to check this.
1211  
1212  There are no requirements on the Alloc type parameter. Surely there
1213  should be some.
1214  
1215  I'm not a big fan of how the semantics section is separated from the
1216  function prototypes. I'd rather see all the information about a
1217  function in one place.
1218  
1219  Also I'm not fond of how the "source code documentation" is separate
1220  from the main documentation. I had to click around a lot to find
1221  information.
1222  
1223  
1224  Best wishes,
1225  Jeremy
1226  
1227  
1228  -------------------------------------------------------------------------
1229  
1230  Date: Sun, 7 Mar 2004 20:41:18 -0500 
1231  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
1232  From: "Jeremy Siek" <jsiek@osl.iu.edu>   
1233  To: boost@lists.boost.org 
1234  
1235      
1236  Hi Jan,
1237  
1238  On Sunday, March 7, 2004, at 04:31 PM, Jan Gaspar wrote:
1239  > overwritten. Now if there will be the assignment idiom
1240  > applied the front-most will be assigned to the new one
1241  > - it will be not destroyed (no destructor will be
1242  > called). IMHO this is not correct. The old element
1243  > will not disappear - just its value/state will be
1244  > different. I think that the overwrite operation means
1245  > destruction of the old object, NOT assignment. What do
1246  > you think?
1247  
1248  I don't see how it makes any difference from the semantic point
1249  of view. Other than tracing calls to destructors, are there any
1250  other ways to tell the difference?
1251  
1252  Another note about the documentation... whichever way this
1253  issues end up, more needs to be said about it in the docs.
1254  Currently, the docs say "overwrite" which to me sounds like
1255  assignment, and the docs never mention destroying the
1256  objects. I think you either need to give a technical definition
1257  for what you mean by "overwrite", or better yet, use different words.
1258  
1259  Cheers,
1260  Jeremy
1261  
1262  
1263  -------------------------------------------------------------------------
1264  
1265  To: boost@lists.boost.org 
1266  From: "Alberto Barbati" <abarbati@iaanus.com>   
1267  Date: Mon, 08 Mar 2004 03:01:32 +0100 
1268  Subject: [boost] Re: Formal Review: Circular Buffer 
1269  
1270      
1271  Jan Gaspar wrote:
1272  > I agree the assignment is more efficient. If you dig
1273  > in the code little bit you will find that there is
1274  > assignment operation provided for the primitive types.
1275  
1276  That is good. However, I think that such optimization is unnecessary. 
1277  For primitive types, the destructor is trivial and the copy constructor 
1278  is the assignment, so I bet a reasonably good compiler can optimize the 
1279  dtor/ctor idiom to a simple assigment even without any "help" in the 
1280  form of template machinery. Besides, bad compilers may introduce 
1281  pessimizations... ;)
1282  
1283  > The idea behind the dtor/ctor idiom is like this:
1284  > suppose you have full circular_buffer and you want to
1285  > push_back a new element (instance of some class). That
1286  > means the fron-most element is about to be
1287  > overwritten. Now if there will be the assignment idiom
1288  > applied the front-most will be assigned to the new one
1289  > - it will be not destroyed (no destructor will be
1290  > called). IMHO this is not correct. The old element
1291  > will not disappear - just its value/state will be
1292  > different. I think that the overwrite operation means
1293  > destruction of the old object, NOT assignment. What do
1294  > you think?
1295  
1296  That's interesting, indeed. I agree it is more "correct". However, I 
1297  don't see this improved correctness bringing a real benefit to the 
1298  user. 
1299  Do you have at least one use case where the ctor/dtor idiom can be 
1300  leveraged by the user in order to provide a feature not obtainable with 
1301  plain assignment?
1302  
1303  BTW, this discussion triggers some other ideas. Have you considered 
1304  adding to the circular_buffer the capability to optionally notify the 
1305  user about an impeding overwrite? I have at least one use case where it 
1306  might be useful. It might be as easy as invoking a boost::function0 
1307  callback, at the cost of few bytes in footprint and an extra test 
1308  before 
1309  any overwrite. Alternatively, we could put hooks (in form of a template 
1310  policy, for example) in the main container that are then implemented by 
1311  a container adaptor, so the user won't pay if it doesn't want such a 
1312  feature.
1313  
1314  Alberto
1315  
1316  
1317  -------------------------------------------------------------------------
1318  
1319  To: boost@lists.boost.org 
1320  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
1321  From: "Jeremy Maitin-Shepard" <jbms@attbi.com>   
1322  Date: Sun, 07 Mar 2004 21:07:54 -0500 
1323  
1324      
1325  Alberto Barbati <abarbati@iaanus.com> writes:
1326  
1327  > [snip]
1328  
1329  > BTW, this discussion triggers some other ideas. Have you considered 
1330  adding to
1331  > the circular_buffer the capability to optionally notify the user 
1332  about an
1333  > impeding overwrite? I have at least one use case where it might be 
1334  useful. It
1335  > might be as easy as invoking a boost::function0 callback, at the cost 
1336  of few
1337  > bytes in footprint and an extra test before any overwrite. 
1338  Alternatively, we
1339  > could put hooks (in form of a template policy, for example) in the 
1340  main
1341  > container that are then implemented by a container adaptor, so the 
1342  user won't
1343  > pay if it doesn't want such a feature.
1344  
1345  I would think that sort of feature would be better implemented as a
1346  wrapper around the circular_buffer container.
1347  
1348  -- 
1349  Jeremy Maitin-Shepard
1350  
1351  
1352  -------------------------------------------------------------------------
1353  
1354  To: boost@lists.boost.org 
1355  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
1356  Date: Mon, 8 Mar 2004 13:39:27 +1100 
1357  Subject: [boost] Re: Formal Review: Circular Buffer 
1358  
1359      
1360  "Alberto Barbati" <abarbati@iaanus.com> wrote in message
1361  news:c2gk5o$6v4$1@sea.gmane.org...
1362  > Jan Gaspar wrote:
1363  > > I agree the assignment is more efficient. If you dig
1364  > > in the code little bit you will find that there is
1365  > > assignment operation provided for the primitive types.
1366  >
1367  > That is good. However, I think that such optimization is unnecessary.
1368  > For primitive types, the destructor is trivial and the copy 
1369  constructor
1370  > is the assignment, so I bet a reasonably good compiler can optimize 
1371  the
1372  > dtor/ctor idiom to a simple assigment even without any "help" in the
1373  > form of template machinery. Besides, bad compilers may introduce
1374  > pessimizations... ;)
1375  
1376  The cases where a call to a destructor is actually important beacuse it 
1377  does
1378  some
1379  non-trivial work, one really need
1380  to ensure not even temporary objects of the type exists. That's one of 
1381  the
1382  capabilities my smart containers will allow, ie, "overwriting" really 
1383  means
1384  destructing and replacing.
1385  
1386  br
1387  
1388  Thorsten
1389  
1390  
1391  
1392  
1393  -------------------------------------------------------------------------
1394  
1395  To: boost@lists.boost.org 
1396  From: "David Abrahams" <dave@boost-consulting.com>   
1397  Date: Mon, 08 Mar 2004 05:08:32 -0500 
1398  Subject: [boost] Re: Formal Review: Circular Buffer 
1399  
1400      
1401  Jan Gaspar <jano_gaspar@yahoo.com> writes:
1402  
1403  > Now if there will be the assignment idiom
1404  > applied the front-most will be assigned to the new one
1405  > - it will be not destroyed (no destructor will be
1406  > called). IMHO this is not correct. The old element
1407  > will not disappear - just its value/state will be
1408  > different. I think that the overwrite operation means
1409  > destruction of the old object, NOT assignment. What do
1410  > you think?
1411  
1412  I think it introduces inefficiencies that most people won't want to
1413  pay for, and I don't see any benefits other than lifting the
1414  requirement on assignability.  Types that are copiable but not
1415  assignable are rare, though, at least in my experience.
1416  
1417  -- 
1418  Dave Abrahams
1419  Boost Consulting
1420  www.boost-consulting.com
1421  
1422  
1423  
1424  -------------------------------------------------------------------------
1425  
1426  To: boost@lists.boost.org 
1427  From: "Alberto Barbati" <abarbati@iaanus.com>   
1428  Date: Mon, 08 Mar 2004 11:22:48 +0100 
1429  Subject: [boost] Re: Formal Review: Circular Buffer 
1430  
1431      
1432  Thorsten Ottosen wrote:
1433  > "Alberto Barbati" <abarbati@iaanus.com> wrote in message
1434  > news:c2gk5o$6v4$1@sea.gmane.org...
1435  >>
1436  >>That is good. However, I think that such optimization is unnecessary.
1437  >>For primitive types, the destructor is trivial and the copy 
1438  constructor
1439  >>is the assignment, so I bet a reasonably good compiler can optimize 
1440  the
1441  >>dtor/ctor idiom to a simple assigment even without any "help" in the
1442  >>form of template machinery. Besides, bad compilers may introduce
1443  >>pessimizations... ;)
1444  > 
1445  > 
1446  > The cases where a call to a destructor is actually important beacuse 
1447  it does
1448  > some
1449  > non-trivial work, one really need
1450  > to ensure not even temporary objects of the type exists. That's one 
1451  of the
1452  > capabilities my smart containers will allow, ie, "overwriting" really 
1453  means
1454  > destructing and replacing.
1455  
1456  I'm sorry, I don't understand what you are trying to say here. I 
1457  started 
1458  my sentence with "For primitive types"...
1459  
1460  Alberto
1461  
1462  
1463  -------------------------------------------------------------------------
1464  
1465  To: boost@lists.boost.org 
1466  From: "Alberto Barbati" <abarbati@iaanus.com>   
1467  Date: Mon, 08 Mar 2004 11:28:33 +0100 
1468  Subject: [boost] Re: Formal Review: Circular Buffer 
1469  
1470      
1471  Jeremy Maitin-Shepard wrote:
1472  
1473  > Alberto Barbati <abarbati@iaanus.com> writes:
1474  > 
1475  >>BTW, this discussion triggers some other ideas. Have you considered 
1476  adding to
1477  >>the circular_buffer the capability to optionally notify the user 
1478  about an
1479  >>impeding overwrite? I have at least one use case where it might be 
1480  useful. It
1481  >>might be as easy as invoking a boost::function0 callback, at the cost 
1482  of few
1483  >>bytes in footprint and an extra test before any overwrite. 
1484  Alternatively, we
1485  >>could put hooks (in form of a template policy, for example) in the 
1486  main
1487  >>container that are then implemented by a container adaptor, so the 
1488  user won't
1489  >>pay if it doesn't want such a feature.
1490  > 
1491  > 
1492  > I would think that sort of feature would be better implemented as a
1493  > wrapper around the circular_buffer container.
1494  > 
1495  
1496  I tend to agree, in fact I mentioned container adaptor (= wrapper) in 
1497  the list of alternatives. I guess such an adaptor could perform the 
1498  task 
1499  more efficiently if the underlying container provided the right hooks, 
1500  but until we agree on the semantic and have a reasonable test 
1501  implementation it's difficult to tell.
1502  
1503  Alberto
1504  
1505  
1506  
1507  -------------------------------------------------------------------------
1508  
1509  To: boost@lists.boost.org 
1510  From: "Alberto Barbati" <abarbati@iaanus.com>   
1511  Date: Mon, 08 Mar 2004 11:42:29 +0100 
1512  Subject: [boost] Re: Formal Review: Circular Buffer 
1513  
1514      
1515  Jeremy Siek wrote:
1516  
1517  > 
1518  > On Friday, March 5, 2004, at 01:42 AM, Jan Gaspar wrote:
1519  > 
1520  >>> ________________________________________________
1521  >>> 4. docs: "Type Requirements": doesn't the T need
1522  >>>    to be DefaultConstructible as well, e.g.
1523  >>>    to support push_back(void)?
1524  >>
1525  >> Yes, but DefaultConstructible is needed only if you
1526  >> use such a method. In general it is not needed. For
1527  >> example you can just create empty circular_buffer and
1528  >> use push_back(T&). In this case T doesn't have to be
1529  >> DefaultConstructible.
1530  > 
1531  > 
1532  > That means you have to mention this type requirement
1533  > in the documentation for the push_back() method.
1534  
1535  Standard containers do not have push_back()/push_front() methods that 
1536  take no arguments, so I don't agree with the decision of having them. I 
1537  would remove them entirely.
1538  
1539  Moreover, I once had a discussion against having both a foobar() and a 
1540  foobar(T) or foobar(T&) signature. The argument was that explicit 
1541  instantiation of the entire class requires both methods to be 
1542  instantiated so it requires T to be DefaultConstructible even if 
1543  foobar() is never called. That's why the standard defines, for example, 
1544  std::vector::resize with a default argument, like this:
1545  
1546     void resize(size_type sz, T c = T());
1547  
1548  this definition effectively works around this kind of problem as the 
1549  default argument expression is not evaluated unless the method is 
1550  invoked with less than a full set of arguments.
1551  
1552  Alberto
1553  
1554  
1555  -------------------------------------------------------------------------
1556  
1557  To: boost@lists.boost.org 
1558  From: "Alberto Barbati" <abarbati@iaanus.com>   
1559  Date: Mon, 08 Mar 2004 13:03:04 +0100 
1560  Subject: [boost] Re: Formal Review: Circular Buffer 
1561  
1562      
1563  Pavel Vozenilek wrote:
1564  
1565  > Discovered problems in code or in documentation,
1566  > missing features, portability issues
1567  > and finally opinion whether the library belongs
1568  > to Boost is welcomed.
1569  
1570  I believe this library is very useful and generally well-written. I 
1571  found a few minor problems that I deem workable. My opinion is that the 
1572  library should be accepted. The only things I would like to be 
1573  discussed 
1574  thouroughly are the "ctor/dtor vs. assignment" dispute (see specific 
1575  thread) and the possibility to provide extension points that allows a 
1576  (possibly future) implementation of a "notifying" container (ibid.).
1577  
1578  About portability issues, these lines of code (file details.hpp, lines 
1579  274-277) invoke undefined behaviour, according to 5.7/5:
1580  
1581       if (less(rhs, lhs) && lhs.m_it <= rhs.m_it)
1582           return lhs.m_it + m_buff->capacity() - rhs.m_it;
1583       if (less(lhs, rhs) && lhs.m_it >= rhs.m_it)
1584           return lhs.m_it - m_buff->capacity() - rhs.m_it;
1585  
1586  that's because the expressions (lhs.m_it + m_buff->capacity()) and 
1587  (lhs.m_it - m_buff->capacity()) might produce a pointer outside the 
1588  allocated range. I suggest to replace those lines with:
1589  
1590       if (less(rhs, lhs) && lhs.m_it <= rhs.m_it)
1591           return lhs.m_it - rhs.m_it + m_buff->capacity();
1592       if (less(lhs, rhs) && lhs.m_it >= rhs.m_it)
1593           return lhs.m_it - rhs.m_it - m_buff->capacity();
1594  
1595  or, even better, to avoid complaints from nasty compilers about mixed 
1596  signed/unsigned usage:
1597  
1598       if (less(rhs, lhs) && lhs.m_it <= rhs.m_it)
1599           return (lhs.m_it - rhs.m_it) +
1600               static_cast<difference_type>(m_buff->capacity());
1601       if (less(lhs, rhs) && lhs.m_it >= rhs.m_it)
1602           return (lhs.m_it - rhs.m_it) -
1603               static_cast<difference_type>(m_buff->capacity());
1604  
1605  To be extra paranoid, we should ensure that the static_cast doesn't 
1606  overflow. This could be done by changing the defintion of max_size() in 
1607  base.hpp from:
1608  
1609       size_type max_size() const { return m_alloc.max_size(); }
1610  
1611  to
1612  
1613       size_type max_size() const {
1614           return std::min<size_type>(m_alloc.max_size(),
1615               (std::numeric_limits<difference_type>::max)()); }
1616  
1617  I've seen this issue overlooked even in commercial standard library 
1618  implementations. As c.end() - c.begin() == c.size() and c.end() - 
1619  c.begin() must be representable as a positive quantity of type 
1620  difference_type, this imply that c.size() <= c.max_size() <= 
1621  numeric_limits<difference_type>::max().
1622  
1623  On a side note, I think it should be good if the implementation of the 
1624  iterator classes used the new Boost Iterators Library. I have uploaded 
1625  in the Boost file area an implementation using boost::iterator_facade 
1626  (filename is circular_buffer_new_iterators.zip). The implementation 
1627  already include the fix above and also has a slightly more optimized 
1628  version of the less() method, with fewer tests and without switches.
1629  Problem is that there is something wrong with the implementation of 
1630  operator[] in iterator_facade and the regression test does not compile 
1631  anymore :-( However, if I hack iterator_facade::operator[] to avoid the 
1632  use of the operator_brackets_proxy class, all regression tests pass. 
1633  Maybe it would be good to discuss this problem of the iterator_facade 
1634  in 
1635  a different thread.
1636  
1637  Alberto Barbati
1638  
1639  
1640  
1641  -------------------------------------------------------------------------
1642  
1643  To: boost@lists.boost.org 
1644  From: "David Abrahams" <dave@boost-consulting.com>   
1645  Date: Mon, 08 Mar 2004 07:34:54 -0500 
1646  Subject: [boost] iterator_facade operator[] (was: Formal Review: Circular
1647  Buffer) 
1648      
1649  Alberto Barbati <abarbati@iaanus.com> writes:
1650  
1651  > Problem is that there is something wrong with the implementation of
1652  > operator[] in iterator_facade and the regression test does not 
1653  compile
1654  > anymore :-( 
1655  
1656  What makes you say that there's something wrong with iterator_facade's
1657  operator[]?  Is it possible that the regression test makes invalid
1658  assumptions about the way an iterator's operator[] is supposed to work?
1659  
1660  > However, if I hack iterator_facade::operator[] to avoid
1661  > the use of the operator_brackets_proxy class
1662  
1663  That's unneccessary.  Any iterator_facade behavior you want to replace
1664  can simply be added to your derived iterator class.
1665  
1666  > all regression tests pass. Maybe it would be good to discuss this
1667  > problem of the iterator_facade in a different thread.
1668  
1669  Here we are!
1670  
1671  -- 
1672  Dave Abrahams
1673  Boost Consulting
1674  www.boost-consulting.com
1675  
1676  
1677  -------------------------------------------------------------------------
1678  
1679  To: boost@lists.boost.org 
1680  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
1681  Date: Tue, 9 Mar 2004 00:40:45 +1100 
1682  Subject: [boost] Re: Formal Review: Circular Buffer 
1683  
1684      
1685  "Alberto Barbati" <abarbati@iaanus.com> wrote in message
1686  news:c2hhhi$lgs$1@sea.gmane.org...
1687  > Thorsten Ottosen wrote:
1688  [snip]
1689  > > The cases where a call to a destructor is actually important 
1690  beacuse it
1691  does
1692  > > some
1693  > > non-trivial work, one really need
1694  > > to ensure not even temporary objects of the type exists. That's one 
1695  of
1696  the
1697  > > capabilities my smart containers will allow, ie, "overwriting" 
1698  really
1699  means
1700  > > destructing and replacing.
1701  >
1702  > I'm sorry, I don't understand what you are trying to say here. I 
1703  started
1704  > my sentence with "For primitive types"...
1705  
1706  yeah, I could have said it better :-) What I meant was that 
1707  copy-behavior is
1708  ususally
1709  incompatible with non-trivial destructors. What I mean by non-trivial
1710  destructors is that
1711  eg. a file is closed or a connection is closed. In those cases making
1712  temporaries and copies
1713  is not good: you want more explicit control over when the destructor is
1714  called. (hence you need a
1715  container of heap-allocated objects and not something like 
1716  vector<Socket> )
1717   For most value-like objects we have the opposite situation and we 
1718  don't
1719  mind if an object is overwritten by
1720  assignment of if destructors are called.
1721  
1722  br
1723  
1724  Thorsten
1725  
1726  
1727  
1728  
1729  -------------------------------------------------------------------------
1730  
1731  To: boost@lists.boost.org 
1732  From: "Alberto Barbati" <abarbati@iaanus.com>   
1733  Date: Mon, 08 Mar 2004 15:17:02 +0100 
1734  Subject: [boost] Re: iterator_facade operator[] 
1735  
1736      
1737  David Abrahams wrote:
1738  
1739  > Alberto Barbati <abarbati@iaanus.com> writes:
1740  > 
1741  >>Problem is that there is something wrong with the implementation of
1742  >>operator[] in iterator_facade and the regression test does not 
1743  compile
1744  >>anymore :-( 
1745  > 
1746  > What makes you say that there's something wrong with 
1747  iterator_facade's
1748  > operator[]?  Is it possible that the regression test makes invalid
1749  > assumptions about the way an iterator's operator[] is supposed to 
1750  work?
1751  
1752  The problem is triggered by the expression
1753  
1754       BOOST_CHECK(it[0] == 2);
1755  
1756  found in file base_test.cpp line 157. VC .NET 2003 gives the following 
1757  error message:
1758  
1759  error C2678: binary '==' : no operator found which takes a left-hand 
1760  operand of type 
1761  'boost::detail::operator_brackets_result<Iterator,Value,Reference>::type' 
1762  (or there is no acceptable conversion)
1763  with
1764  [
1765  Iterator=boost::cb_details::cb_iterator<boost::circular_buffer<Integer>,Integer>,
1766  Value=Integer,
1767  Reference=Integer &
1768  ]
1769  
1770  "it" is defined as circular_buffer<Integer>::iterator. As the right 
1771  hand 
1772  side is not an "Integer" I also tried writing:
1773  
1774       BOOST_CHECK(it[0] == Integer(2));
1775  
1776  but the error message stays the same.
1777  
1778  >>However, if I hack iterator_facade::operator[] to avoid
1779  >>the use of the operator_brackets_proxy class
1780  > 
1781  > That's unneccessary.  Any iterator_facade behavior you want to 
1782  replace
1783  > can simply be added to your derived iterator class.
1784  
1785  Yes. Sure you are right. I feel kind of stupid, I should have thought 
1786  about it in the first place.
1787  
1788  I am uploading a revised version of 
1789  circular_buffer_new_iterators_v2.zip 
1790  that overrides operator[]. All regression tests passes with VC7.1. I 
1791  also made the implementation members private and fixed the comments.
1792  
1793  Anyway you'll agree that the issue is quite general and it might be 
1794  interesting to investigate if we could find a solution at the 
1795  iterator_facade level.
1796  
1797  >>all regression tests pass. Maybe it would be good to discuss this
1798  >>problem of the iterator_facade in a different thread.
1799  > 
1800  > 
1801  > Here we are!
1802  
1803  :-)
1804  
1805  Alberto
1806  
1807  
1808  
1809  -------------------------------------------------------------------------
1810  
1811  To: boost@lists.boost.org 
1812  From: "David Abrahams" <dave@boost-consulting.com>   
1813  Date: Mon, 08 Mar 2004 09:48:00 -0500 
1814  Subject: [boost] Re: iterator_facade operator[] 
1815  
1816      
1817  Alberto Barbati <abarbati@iaanus.com> writes:
1818  
1819  > David Abrahams wrote:
1820  >
1821  >> What makes you say that there's something wrong with
1822  >> iterator_facade's
1823  >> operator[]?  Is it possible that the regression test makes invalid
1824  >> assumptions about the way an iterator's operator[] is supposed to 
1825  work?
1826  >
1827  > The problem is triggered by the expression
1828  >
1829  >      BOOST_CHECK(it[0] == 2);
1830  >
1831  > found in file base_test.cpp line 157. VC .NET 2003 gives the 
1832  following
1833  > error message:
1834  >
1835  > error C2678: binary '==' : no operator found which takes a left-hand
1836  > operand of type
1837  > 
1838  boost::detail::operator_brackets_result<Iterator,Value,Reference>::type'
1839  > (or there is no acceptable conversion)
1840  > with
1841  > [
1842  > 
1843  Iterator=boost::cb_details::cb_iterator<boost::circular_buffer<Integer>,
1844  > Integer>, Value=Integer,
1845  > Reference=Integer &
1846  > ]
1847  >
1848  > "it" is defined as circular_buffer<Integer>::iterator. As the right
1849  > hand side is not an "Integer" I also tried writing:
1850  >
1851  >      BOOST_CHECK(it[0] == Integer(2));
1852  >
1853  > but the error message stays the same.
1854  
1855  The right check would be:
1856  
1857      BOOST_CHECK(Integer(it[0]) == 2);
1858  
1859  The return type of a random access iterator's operator[] is only
1860  required to be *convertible* to its value_type.
1861  
1862  > I am uploading a revised version of
1863  > circular_buffer_new_iterators_v2.zip that overrides operator[]. All
1864  > regression tests passes with VC7.1. I also made the implementation
1865  > members private and fixed the comments.
1866  >
1867  > Anyway you'll agree that the issue is quite general and it might be
1868  > interesting to investigate if we could find a solution at the
1869  > iterator_facade level.
1870  
1871  We've given it a lot of thought already.  In general there's no way
1872  to detect that a given iterator implementation will return a
1873  reference to a persistent object from its dereference
1874  implementation.  See
1875  http://www.boost.org/libs/iterator/doc/iterator_facade.html#operator.
1876  
1877  If you can come up with a way to decide reliably that the proxy is
1878  unneded, that'd be great -- but I doubt it can be done.  Anyone who
1879  really cares about returning a reference from operator[] can do what
1880  you did.  In general, though, there's no reason for any algorithm to
1881  use an iterator's operator[] anyway, so fulfilling the random-access
1882  requirement for operator[] is really a formality and it doesn't need
1883  to be optimal.
1884  
1885  -- 
1886  Dave Abrahams
1887  Boost Consulting
1888  www.boost-consulting.com
1889  
1890  
1891  -------------------------------------------------------------------------
1892  
1893  To: boost@lists.boost.org 
1894  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
1895  Date: Mon, 8 Mar 2004 18:35:41 +0100 
1896  Subject: [boost] Re: Formal Review: Circular Buffer 
1897  
1898      
1899  
1900  "David Abrahams" <dave@boost-consulting.com> wrote
1901  
1902  > > Now if there will be the assignment idiom
1903  > > applied the front-most will be assigned to the new one
1904  > > - it will be not destroyed (no destructor will be
1905  > > called). IMHO this is not correct. The old element
1906  > > will not disappear - just its value/state will be
1907  > > different. I think that the overwrite operation means
1908  > > destruction of the old object, NOT assignment. What do
1909  > > you think?
1910  >
1911  > I think it introduces inefficiencies that most people won't want to
1912  > pay for, and I don't see any benefits other than lifting the
1913  > requirement on assignability.  Types that are copiable but not
1914  > assignable are rare, though, at least in my experience.
1915  >
1916  I think you are missing the point: object pushed out
1917  of circular_buffer because container got full must be destroyed.
1918  
1919  Therefore assignement is not used, therefore no CopyConstructible
1920  requirement on T.
1921  
1922  (I'll look whether there aren't other places requiring assignement.)
1923  
1924  /Pavel
1925  
1926  
1927  
1928  
1929  -------------------------------------------------------------------------
1930  
1931  Date: Mon, 8 Mar 2004 09:58:40 -0800 (PST) 
1932  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
1933  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
1934  To: boost@lists.boost.org 
1935  
1936      
1937  Hi Jeremy!
1938  
1939  > That means you have to mention this type requirement
1940  > in the documentation for the push_back() method.
1941  > 
1942  Yes, I agree.
1943  
1944  
1945  
1946  
1947  -------------------------------------------------------------------------
1948  
1949  To: boost@lists.boost.org 
1950  From: "David Abrahams" <dave@boost-consulting.com>   
1951  Date: Mon, 08 Mar 2004 12:59:53 -0500 
1952  Subject: [boost] Re: Formal Review: Circular Buffer 
1953  
1954      
1955  "Pavel Vozenilek" <pavel_vozenilek@hotmail.com> writes:
1956  
1957  > "David Abrahams" <dave@boost-consulting.com> wrote
1958  >
1959  >> > Now if there will be the assignment idiom
1960  >> > applied the front-most will be assigned to the new one
1961  >> > - it will be not destroyed (no destructor will be
1962  >> > called). IMHO this is not correct. The old element
1963  >> > will not disappear - just its value/state will be
1964  >> > different. I think that the overwrite operation means
1965  >> > destruction of the old object, NOT assignment. What do
1966  >> > you think?
1967  >>
1968  >> I think it introduces inefficiencies that most people won't want to
1969  >> pay for, and I don't see any benefits other than lifting the
1970  >> requirement on assignability.  Types that are copiable but not
1971  >> assignable are rare, though, at least in my experience.
1972  >>
1973  > I think you are missing the point: 
1974  
1975  Actually, no.  I realized you're making the argument below.
1976  
1977  > object pushed out of circular_buffer because container got full must
1978  > be destroyed.
1979  
1980  Why?  I mean, the only reason I can see for that requirement is an
1981  aesthetic one.  I don't see any logical foundation for the assertion.
1982  
1983  
1984  -- 
1985  Dave Abrahams
1986  Boost Consulting
1987  www.boost-consulting.com
1988  
1989  
1990  -------------------------------------------------------------------------
1991  
1992  Date: Mon, 8 Mar 2004 10:03:25 -0800 (PST) 
1993  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
1994  Subject: Re: [boost] Formal Review: Circular Buffer 
1995  To: boost@lists.boost.org 
1996  
1997      
1998  
1999  --- Jeremy Siek <jsiek@osl.iu.edu> wrote:
2000  > I have read the documentation for the library, and
2001  > browsed through the 
2002  > test code.
2003  > Based on that I recommend acceptance of the circular
2004  > buffer library. 
2005  > Nice work Jan!
2006  > 
2007  > Here are some suggestions.
2008  > 
2009  > This sentences seems unnecessary:
2010  >      In fact the circular_buffer is defined in the
2011  > file
2012  >      boost/circular_buffer/base.hpp, but it is
2013  > necessary to include the
2014  >     boost/circular_buffer.hpp in order to use this
2015  > container
2016  > 
2017  No it isn't, I'll change it.
2018  
2019  > Have you checked whether CopyConstructible is in
2020  > fact the only
2021  > requirements needed on the type parameter T? For
2022  > example, I bet
2023  > T must also be Assignable. But who knows what other
2024  > requirements you 
2025  > may have
2026  > missed (it is easy to miss them). I recommend using
2027  > concept archetypes 
2028  > to check this.
2029  > 
2030  Yes, it is the only requirement.
2031  
2032  > There are no requirements on the Alloc type
2033  > parameter. Surely there
2034  > should be some.
2035  > 
2036  I think the Alloc has to be just an allocator (with
2037  the neccessary methods). No special requirements
2038  needed.
2039  
2040  Jan
2041  
2042  
2043  
2044  -------------------------------------------------------------------------
2045  
2046  Date: Mon, 8 Mar 2004 10:06:01 -0800 (PST) 
2047  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
2048  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
2049  To: boost@lists.boost.org 
2050  
2051      
2052  
2053  --- Jeremy Siek <jsiek@osl.iu.edu> wrote:
2054  > Another note about the documentation... whichever
2055  > way this
2056  > issues end up, more needs to be said about it in the
2057  > docs.
2058  > Currently, the docs say "overwrite" which to me
2059  > sounds like
2060  > assignment, and the docs never mention destroying
2061  > the
2062  > objects. I think you either need to give a technical
2063  > definition
2064  > for what you mean by "overwrite", or better yet, use
2065  > different words.
2066  > 
2067  I agree with you. I have to specify the exact meaning
2068  of the "overwrite" operation.
2069  
2070  Jan
2071  
2072  -------------------------------------------------------------------------
2073  
2074  
2075  Date: Mon, 8 Mar 2004 10:10:50 -0800 (PST) 
2076  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
2077  Subject: Re: [boost] Re: Formal Review: Circular Buffer 
2078  To: boost@lists.boost.org 
2079  
2080      
2081  --- Alberto Barbati <abarbati@iaanus.com> wrote:
2082   
2083  > BTW, this discussion triggers some other ideas. Have
2084  > you considered 
2085  > adding to the circular_buffer the capability to
2086  > optionally notify the 
2087  > user about an impeding overwrite? 
2088  
2089  I didn't think of it. Anyway it is interesting.
2090  
2091  Jan
2092  
2093  -------------------------------------------------------------------------
2094  
2095  To: boost@lists.boost.org 
2096  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
2097  Date: Mon, 8 Mar 2004 19:22:33 +0100 
2098  Subject: [boost] Re: Formal Review: Circular Buffer 
2099  
2100      
2101  
2102  "David Abrahams" <dave@boost-consulting.com> wrote
2103  
2104  > > object pushed out of circular_buffer because container got full 
2105  must
2106  > > be destroyed.
2107  >
2108  > Why?  I mean, the only reason I can see for that requirement is an
2109  > aesthetic one.  I don't see any logical foundation for the assertion.
2110  >
2111  I am not getting something. You are saying objects can go away
2112  without being destructed?
2113  
2114  /Pavel
2115  
2116  
2117  -------------------------------------------------------------------------
2118  
2119  To: boost@lists.boost.org 
2120  From: "David Abrahams" <dave@boost-consulting.com>   
2121  Date: Mon, 08 Mar 2004 13:50:07 -0500 
2122  Subject: [boost] Re: Formal Review: Circular Buffer 
2123  
2124      
2125  "Pavel Vozenilek" <pavel_vozenilek@hotmail.com> writes:
2126  
2127  > "David Abrahams" <dave@boost-consulting.com> wrote
2128  >
2129  >> > object pushed out of circular_buffer because container got full 
2130  must
2131  >> > be destroyed.
2132  >>
2133  >> Why?  I mean, the only reason I can see for that requirement is an
2134  >> aesthetic one.  I don't see any logical foundation for the 
2135  assertion.
2136  >>
2137  > I am not getting something. You are saying objects can go away
2138  > without being destructed?
2139  
2140  No, I'm saying that their values can go away without destruction: you
2141  could replace their values in the buffer using assignment instead of
2142  destroy + construct.  There's no a priori reason they have to be
2143  destroyed.
2144  
2145  When I erase objects from a std::vector, the objects being erased
2146  don't neccessarily get destroyed.  They may be assigned.  For
2147  example, here's STLPort's vector<T>::erase(iterator) implementation:
2148  
2149    iterator erase(iterator __position) {
2150      if (__position + 1 != end())
2151        __copy_ptrs(__position + 1, this->_M_finish, __position, 
2152  _TrivialAss());
2153      --this->_M_finish;
2154      _Destroy(this->_M_finish);
2155      return __position;
2156    }
2157  
2158  Notice that only the last element of the vector is destroyed.
2159  
2160  -- 
2161  Dave Abrahams
2162  Boost Consulting
2163  www.boost-consulting.com
2164  
2165  
2166  -------------------------------------------------------------------------
2167  
2168  From: "Paul A Bristow" <boost@hetp.u-net.com>   
2169  To: boost@lists.boost.org 
2170  Subject: RE: [boost] Formal Review: Circular Buffer 
2171  Date: Mon, 8 Mar 2004 19:09:51 -0000 
2172  
2173      
2174  I have very briefly (re-)reviewed Jan Gaspar's circular buffer.
2175  
2176  What is your evaluation of the design?  It provides a useful
2177  'should-be-standard' feature not provided elsewhere.  
2178  
2179  What is your evaluation of the implementation?  It works in my tests,
2180  and some usage.
2181  
2182  What is your evaluation of the documentation?  Seems OK.  Examples good
2183  and well commented.
2184  
2185  [Aside- although I am not a fan of Doxygen generated docs - somehow 
2186  they
2187  never seem to tell what you want to know.  Does the automatic-ness
2188  delude the author that he has done his job when he hasn't really barely
2189  started?]
2190  
2191  What is your evaluation of the potential usefulness of the library?
2192  When useful and appropriate, invaluable.  STL compatibility should
2193  greatly increase its applicability.
2194  
2195  Did you try to use the library? Earlier versions. With what compiler?
2196  MSVC 7.1 Did you have any problems? No.  Compiles cleanly even in 
2197  strict
2198  mode.
2199  
2200  How much effort did you put into your evaluation? Shallow-depth study?
2201  
2202  Are you knowledgeable about the problem domain? Only as a user.
2203  
2204  Other comments:
2205  
2206  It is quite mature having been through a number of iterations under
2207  Boost (fairly friendly) fire for some time. Test suite looks OK.
2208  
2209  Do you think the library should be accepted as a Boost library?
2210  
2211  I vote for acceptance.
2212  
2213  Paul
2214  
2215  Paul A Bristow
2216  Prizet Farmhouse, Kendal, Cumbria UK LA8 8AB
2217  +44 1539 561830  +44 7714 330204
2218  mailto: pbristow@hetp.u-net.com
2219  
2220  
2221  
2222  
2223  -------------------------------------------------------------------------
2224  
2225  Date: Mon, 8 Mar 2004 20:34:32 +0100 
2226  From: "Pavol Droba" <droba@topmail.sk>  View Contact Details  
2227  To: boost@lists.boost.org 
2228  Subject: Re: [boost] Formal Review: Circular Buffer 
2229  
2230      
2231  Hi,
2232  
2233  I'd like to cast my vote on the circular_buffer review.
2234  I have read through all documentation, briefly skimmed through the 
2235  implementation and test code.
2236  
2237  
2238  a.. What is your evaluation of the design?
2239  ------------------------------------
2240  
2241  The library follows the standard STL container conventions very 
2242  closely. 
2243  Provided interface is sufficient and well defined. Debugging facility 
2244  seems very useful.
2245  
2246  One objection I have is following:
2247  Interaface models Sequence concept, but one of the concept's 
2248  requirements is missing.
2249  There is no constructor taking just two iterators as a parameter. 
2250  Initialization 
2251  from a pair of iterators is provided, but the signature does not match 
2252  the requirements 
2253  of Sequence concept. It is not possible to use this container in 
2254  generic algorithms,
2255  that require such a constructor (this is quite common case IMHO).
2256  
2257  I would like to see more adaptors in addtion to one provided. 
2258  Concretely, one that
2259  have been already mentioned, which provides means for notification when 
2260  a 
2261  buffer is empty/full. This might be extremly useful.
2262  Another adaptor I would like to see, is one, that disallows rewriting 
2263  of the
2264  old elements. Such an buffer can be used as a faster alternative to 
2265  std::deque,
2266  when a bounded buffer is sufficient. Checking for overflow can be 
2267  provided by an
2268  exception or an error code from insering operations.
2269  
2270  
2271  b.. What is your evaluation of the implementation?
2272  --------------------------------------------
2273  
2274  Implementaion seem quite solid. I have no objections. 
2275  
2276  As for the assign-construct/destruct discussion, I think, that one of 
2277  options would be to 
2278  use a policy class to define the behaviour. Both approaches have their 
2279  own pros and cons. Assignment might bring some speedup and I would 
2280  prefer it as default.
2281  Construct/Destruct might be benefitial in some applications (f.e. an 
2282  object is notified, by
2283  a destructor, that it has been removed from buffer).
2284  
2285  c.. What is your evaluation of the documentation?
2286  -------------------------------------------
2287  
2288  Documentation seem sound and well prepared. I was able easily 
2289  understand 
2290  how to use the library. Examples are illustrative enough for the common 
2291  usage.
2292  
2293  I have few suggestion, though. First of all, I don't like doxygen 
2294  generated documenation
2295  too much. This might be my personal preference, however it does not 
2296  integrage
2297  with other parts of documentation well. Source documentaion has 
2298  different layout and format
2299  than the rest and IMO it is little bit confusing to use two styles in 
2300  one doc.
2301  
2302  There is an obvious suggestion to solve this problem: convert docs to 
2303  boost-book. 
2304  
2305  d.. What is your evaluation of the potential usefulness of the library?
2306  -----------------------------------------------------------------
2307  
2308  I find the library useful for many application. Either as a bounded 
2309  aging buffer
2310  or as a faster alternative for deque when memory limit is benefitial or 
2311  required.
2312  
2313  e.. Did you try to use the library?  With what compiler?  Did you have 
2314  any
2315  problems?
2316  --------------------------------------------------------------------
2317  
2318  I have compiled test cases without any problem on vc7.1 and gcc3.3.1 
2319  under cygwin
2320  
2321  
2322  f.. How much effort did you put into your evaluation? A glance? A quick
2323  reading? In-depth study?
2324  -----------------------------------------------------------------
2325  
2326  I have spend about 2 to 3 hours studying the code, the documentation 
2327  and reading 
2328  the discussions here on the list.
2329  
2330  
2331  g.. Are you knowledgeable about the problem domain?
2332  ---------------------------------------------
2333  
2334  I have good knowledge about STL containers and concepts related to 
2335  them.
2336  
2337  h.. Do you think the library should be accepted as a Boost library?
2338  --------------------------------------------------------------
2339  
2340  I vote that the library should be ACCEPTED to boost. 
2341  
2342  It provides handy utility. Design and implementation is solid, 
2343  documentation is acceptable.
2344  
2345  
2346  Regards,
2347  
2348  Pavol
2349  
2350  
2351  -------------------------------------------------------------------------
2352  
2353  To: boost@lists.boost.org 
2354  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
2355  Date: Mon, 8 Mar 2004 21:16:18 +0100 
2356  Subject: [boost] Re: Formal Review: Circular Buffer 
2357  
2358      
2359  
2360  "David Abrahams" <dave@boost-consulting.com> wrote
2361  
2362  > No, I'm saying that their values can go away without destruction: you
2363  > could replace their values in the buffer using assignment instead of
2364  > destroy + construct.  There's no a priori reason they have to be
2365  > destroyed.
2366  >
2367  > When I erase objects from a std::vector, the objects being erased
2368  > don't neccessarily get destroyed.  They may be assigned.  For
2369  > example, here's STLPort's vector<T>::erase(iterator) implementation:
2370  >
2371  [snip code]
2372  >
2373  > Notice that only the last element of the vector is destroyed.
2374  >
2375  
2376  Quoting from similar discussion on c.l.c++.m: http://tinyurl.com/2c3na
2377  
2378  --- quote about vector::erase ---
2379  The standard says this:  "The destructor of T is called the number of
2380  times equal to the number of the elements erased, but the assignment
2381  operator of T is called the number of times equal to the number of
2382  elements in the vector after the erased elements."
2383  ------------------------------
2384  
2385  
2386  With circular buffer the destructor wouldn't be called at all,
2387  in similar circumstance.
2388  
2389  Eample:
2390     Circular buffer of size 3.
2391     You create 100 of objects and push them in.
2392      You would get:
2393        - 100 constructors called,
2394        - 97 copy constructors called,
2395        - 3 destructors called.
2396  
2397  /Pavel
2398  
2399  
2400  
2401  
2402  
2403  -------------------------------------------------------------------------
2404  
2405  To: boost@lists.boost.org 
2406  From: "Jan Langer" <jan@langernetz.de>   
2407  Date: Mon, 08 Mar 2004 21:30:44 +0100 
2408  Subject: [boost] Re: Formal Review: Circular Buffer 
2409  
2410      
2411  Hi,
2412  I did a short review of this library.
2413  
2414  - regarding the data() issue I think it should be mentioned that this 
2415  function has linear complexity. A name reflecting this behavior would 
2416  be 
2417  even better.
2418  
2419  - the difference between resize() and set_capacity() should be 
2420  mentioned 
2421  more explicitly. It might be especially confusing since std::vector's 
2422  reserve is quite similar to set_capacity but has a different name.
2423  
2424  - I am missing the counterpart to erase which shifts the elements 
2425  before 
2426  the erased elements and not the ones after. Probably this is not 
2427  important but std::deque allows erasing at the front without 
2428  invalidating all iterators (according to sgi-stl docs).
2429  
2430  - The insert() function has its rinsert() counterpart. The same issue 
2431  for resize and set_capacity is solved with the boolean parameter 
2432  remove_front. If this has an important reason it should be mentioned. 
2433  If 
2434  not I would like to see a more consistent solution.
2435  
2436  - In section Caveats:
2437  "... According to the semantics of rinsert, insertion overwrites 
2438  front-most items as necessary ..." should probably read "back-most 
2439  items" if this is a valid english word.
2440  
2441  - I compiled the library with g++ 3.2.2 and everything worked fine. But 
2442  when I tried to compile the example from the documentation with a 
2443  command line call to g++ I got the following error:
2444  
2445  [jan@affe test]$ g++ -Wall -Wno-long-long -ansi -pedantic -I .. -I 
2446  $BOOST_ROOT cb_example.cpp
2447  ../boost/circular_buffer/base.hpp: In member function `void
2448      boost::circular_buffer<T, Alloc>::replace(Alloc::pointer,
2449      boost::call_traits<Alloc::value_type>::param_type) [with T = int, 
2450  Alloc =
2451      std::allocator<int>]':
2452  ../boost/circular_buffer/base.hpp:1137:   instantiated from `void 
2453  boost::circular_buffer<T, 
2454  Alloc>::replace_last(boost::call_traits<Alloc::value_type>::param_type) 
2455  [with T = int, Alloc = std::allocator<int>]'
2456  ../boost/circular_buffer/base.hpp:605:   instantiated from `void 
2457  boost::circular_buffer<T, 
2458  Alloc>::push_back(boost::call_traits<Alloc::value_type>::param_type) 
2459  [with T = int, Alloc = std::allocator<int>]'
2460  cb_example.cpp:10:   instantiated from here
2461  ../boost/circular_buffer/base.hpp:1105: invalid use of member `
2462      boost::cb_details::cb_replace_category_traits<int>::tag'
2463  
2464  Without -ansi -pedantic it works fine. I don't know if it should work 
2465  with -ansi -pedantic but I thought it worth mentioning
2466  
2467  - In general the documentation is quite good and well written.
2468  
2469  - I didn't look at the code in detail, but in order to understand some 
2470  things I had a look at certain member functions and found them clearly 
2471  implemented and easy to understand.
2472  
2473  - I cannot sufficiently evaluate the usefullness of this library since 
2474  I 
2475  haven't had the need for it in my previous work in C++. Actually I 
2476  cannot imagine it being usefull in normal programming tasks where 
2477  memory 
2478  is plenty. And  I haven't done embedded programming in C++ yet.
2479  
2480  - I spent approximatly 3 to 4 hours on studying the docs, clarifying 
2481  certain things with the help of the code and compiling and looking at 
2482  the examples and writing this email.
2483  
2484  - I'm no expert in the problem domain. Just a regular user of std:: and 
2485  other containers.
2486  
2487  If some points mentioned above will be clarified and if other people 
2488  (or 
2489  me in the future) can find applications for it, I think its a very 
2490  usefull library.
2491  Since I am quite sure that this will be the case I vote for acceptance.
2492  
2493  regards
2494  jan
2495  
2496  -- 
2497  jan langer ... jan@langernetz.de
2498  "pi ist genau drei"
2499  
2500  
2501  
2502  -------------------------------------------------------------------------
2503  
2504  To: boost@lists.boost.org 
2505  From: "David Abrahams" <dave@boost-consulting.com>   
2506  Date: Mon, 08 Mar 2004 16:33:35 -0500 
2507  Subject: [boost] Re: Formal Review: Circular Buffer 
2508  
2509      
2510  "Pavel Vozenilek" <pavel_vozenilek@hotmail.com> writes:
2511  
2512  > "David Abrahams" <dave@boost-consulting.com> wrote
2513  >
2514  >> No, I'm saying that their values can go away without destruction: 
2515  you
2516  >> could replace their values in the buffer using assignment instead of
2517  >> destroy + construct.  There's no a priori reason they have to be
2518  >> destroyed.
2519  >>
2520  >> When I erase objects from a std::vector, the objects being erased
2521  >> don't neccessarily get destroyed.  They may be assigned.  For
2522  >> example, here's STLPort's vector<T>::erase(iterator) implementation:
2523  >>
2524  > [snip code]
2525  >>
2526  >> Notice that only the last element of the vector is destroyed.
2527  >>
2528  >
2529  > Quoting from similar discussion on c.l.c++.m: 
2530  http://tinyurl.com/2c3na
2531  >
2532  > --- quote about vector::erase ---
2533  > The standard says this:  "The destructor of T is called the number of
2534  > times equal to the number of the elements erased, but the assignment
2535  > operator of T is called the number of times equal to the number of
2536  > elements in the vector after the erased elements."
2537  > ------------------------------
2538  >
2539  >
2540  > With circular buffer the destructor wouldn't be called at all,
2541  > in similar circumstance.
2542  >
2543  > Eample:
2544  >    Circular buffer of size 3.
2545  >    You create 100 of objects and push them in.
2546  >     You would get:
2547  >       - 100 constructors called,
2548  >       - 97 copy constructors called,
2549  >       - 3 destructors called.
2550  
2551  Yeah, but my point is: so what?
2552  
2553  I still see no a priori reason that circular_buffer must do element
2554  destruction before it is itself destroyed.  std::vector *has* to do
2555  some destruction in order to get the right semantics.  Arguably,
2556  circular_buffer does not.  If it doesn't matter *which* vector
2557  elements get destroyed upon erase, then I presume it doesn't matter
2558  which circular_buffer elements get destroyed.  In that case, why
2559  should it matter that any elements are destroyed?
2560  
2561  -- 
2562  Dave Abrahams
2563  Boost Consulting
2564  www.boost-consulting.com
2565  
2566  
2567  
2568  -------------------------------------------------------------------------
2569  
2570  To: boost@lists.boost.org 
2571  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
2572  Date: Mon, 8 Mar 2004 23:17:56 +0100 
2573  Subject: [boost] Re: Formal Review: Circular Buffer 
2574  
2575      
2576  
2577  "David Abrahams" <dave@boost-consulting.com> wrote
2578  
2579  > I still see no a priori reason that circular_buffer must do element
2580  > destruction before it is itself destroyed.  std::vector *has* to do
2581  > some destruction in order to get the right semantics.  Arguably,
2582  > circular_buffer does not.  If it doesn't matter *which* vector
2583  > elements get destroyed upon erase, then I presume it doesn't matter
2584  > which circular_buffer elements get destroyed.  In that case, why
2585  > should it matter that any elements are destroyed?
2586  >
2587  If you have class and the class has static member keeping
2588  number of object instances alive (incremented in constructor,
2589  decremented in destructor):
2590  
2591   - putting these objects into vector keeps counter valid,
2592   - circular_buffer with assignement won't.
2593  
2594  That was problem I did have with earlier version of
2595  circular_buffer and that' why I did ask for construct/destruct
2596  feature.
2597  
2598  It is maybe border case but IMHO valid one against assignement.
2599  
2600  /Pavel
2601  
2602  
2603  
2604  -------------------------------------------------------------------------
2605  
2606  To: boost@lists.boost.org 
2607  From: "David Abrahams" <dave@boost-consulting.com>   
2608  Date: Mon, 08 Mar 2004 18:42:55 -0500 
2609  Subject: [boost] Re: Formal Review: Circular Buffer 
2610  
2611      
2612  "Pavel Vozenilek" <pavel_vozenilek@hotmail.com> writes:
2613  
2614  > "David Abrahams" <dave@boost-consulting.com> wrote
2615  >
2616  >> I still see no a priori reason that circular_buffer must do element
2617  >> destruction before it is itself destroyed.  std::vector *has* to do
2618  >> some destruction in order to get the right semantics.  Arguably,
2619  >> circular_buffer does not.  If it doesn't matter *which* vector
2620  >> elements get destroyed upon erase, then I presume it doesn't matter
2621  >> which circular_buffer elements get destroyed.  In that case, why
2622  >> should it matter that any elements are destroyed?
2623  >>
2624  > If you have class and the class has static member keeping
2625  > number of object instances alive (incremented in constructor,
2626  > decremented in destructor):
2627  >
2628  >  - putting these objects into vector keeps counter valid,
2629  >  - circular_buffer with assignement won't.
2630  
2631  I can't understand this claim.  If the counter works properly, then it
2632  will stay valid.  Assignment doesn't magically make instances appear
2633  or disappear.  In one case you assign and the counter doesn't
2634  change.  In the other you destroy one element and construct another
2635  in its place and the counter is incremented, then decremented.
2636  
2637  > That was problem I did have with earlier version of
2638  > circular_buffer and that' why I did ask for construct/destruct
2639  > feature.
2640  >
2641  > It is maybe border case but IMHO valid one against assignement.
2642  
2643  I don't get it.
2644  
2645  -- 
2646  Dave Abrahams
2647  Boost Consulting
2648  www.boost-consulting.com
2649  
2650  
2651  -------------------------------------------------------------------------
2652  
2653  To: boost@lists.boost.org 
2654  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
2655  Date: Tue, 9 Mar 2004 01:17:00 +0100 
2656  Subject: [boost] Re: Formal Review: Circular Buffer 
2657  
2658      
2659  
2660  "Alberto Barbati" <abarbati@iaanus.com> wrote
2661  
2662  [snip assignement prefereble over destruct/construct]
2663  
2664  > 2) with the dtor/ctor idiom, if the ctor throws an exception, the old
2665  > element is lost and you can't do anything about it, so the container
2666  > cannot provide more than the basic guarantee for any method that 
2667  might
2668  > overwrite elements. However, the user might implement assigment with 
2669  the
2670  > strong guarantee, the container might leverage on that and provide 
2671  the
2672  > strong guarantee too at least for methods that might overwrite a 
2673  single
2674  > element such as push_back/push_front. (Of course, the user might
2675  > implement assignment so badly that it doesn't provide even the basic
2676  > guarantee and the container could not recover from that, but a 
2677  library
2678  > such not try to outsmart the user... too much ;).
2679  >
2680  This argument isn't valid.
2681  
2682  push_back() will construct elements when there's space
2683  available in circular buffer.
2684  
2685  Therefore using assignement won't give the method
2686  strong guarantee (in all cases).
2687  
2688  /Pavel
2689  
2690  
2691  
2692  
2693  -------------------------------------------------------------------------
2694  
2695  To: boost@lists.boost.org 
2696  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
2697  Date: Tue, 9 Mar 2004 01:55:06 +0100 
2698  Subject: [boost] Re: Formal Review: Circular Buffer 
2699  
2700      
2701  
2702  "David Abrahams" <dave@boost-consulting.com> wrote
2703  
2704  > I can't understand this claim.  If the counter works properly, then 
2705  it
2706  > will stay valid.
2707  >
2708  This example was too simplified (and thus not to the point).
2709  
2710  More complex one:
2711  
2712  -----------------
2713  struct  my_class
2714  {
2715    void* database_handle;
2716  
2717    my_class() { database_handle = allocate_handle(); }
2718    ~my_class() { destroy_db_handle(database_handle); }
2719    my_class& operator=(const my_class& other) {
2720        // no copy of database handle, not needed,
2721        // not useful here
2722    }
2723    my_class(const my_class& other) {
2724       database_handle = allocate_handle(); // needs unique db connection
2725    }
2726  };
2727  
2728  circular_buffer<my_class> buffer(1);
2729  
2730  {
2731    my_class a;
2732    buffer.push_back(a);  // 2 handles after function returns
2733    ...
2734  }
2735  
2736  {
2737     my_class b;
2738     buffer.push_back(b);  // desctructor not called, handle lost
2739     ...
2740  }
2741  -----------
2742  
2743  To deal with lost resources you would need to modify
2744  operator=() to take ownership of  all rhs resources.
2745  But in this case following will fail:
2746  
2747    my_class a;
2748    my_class b;
2749    a = b;
2750    // b is stripped of its handle now, cannot be used
2751  
2752  
2753  /Pavel
2754  
2755  
2756  
2757  -------------------------------------------------------------------------
2758  
2759  To: boost@lists.boost.org 
2760  From: "Robert Bell" <belvis@imageworks.com>   
2761  Date: Mon, 08 Mar 2004 19:32:53 -0800 
2762  Subject: [boost] Re: Formal Review: Circular Buffer 
2763  
2764      
2765  Pavel Vozenilek wrote:
2766  > "David Abrahams" <dave@boost-consulting.com> wrote
2767  > 
2768  > 
2769  >>I can't understand this claim.  If the counter works properly, then 
2770  it
2771  >>will stay valid.
2772  >>
2773  > 
2774  > This example was too simplified (and thus not to the point).
2775  > 
2776  > More complex one:
2777  > 
2778  > -----------------
2779  > struct  my_class
2780  > {
2781  >   void* database_handle;
2782  > 
2783  >   my_class() { database_handle = allocate_handle(); }
2784  >   ~my_class() { destroy_db_handle(database_handle); }
2785  >   my_class& operator=(const my_class& other) {
2786  >       // no copy of database handle, not needed,
2787  >       // not useful here
2788  >   }
2789  >   my_class(const my_class& other) {
2790  >      database_handle = allocate_handle(); // needs unique db 
2791  connection
2792  >   }
2793  > };
2794  > 
2795  > circular_buffer<my_class> buffer(1);
2796  > 
2797  > {
2798  >   my_class a;
2799  >   buffer.push_back(a);  // 2 handles after function returns
2800  >   ...
2801  > }
2802  > 
2803  > {
2804  >    my_class b;
2805  >    buffer.push_back(b);  // desctructor not called, handle lost
2806  >    ...
2807  > }
2808  
2809  I don't see why a handle is lost.
2810  
2811  {
2812  // Only one handle in existence at this point, the one
2813  // previously added to buffer by "buffer.push_back(a);".
2814  
2815      my_class b;
2816  
2817  // Now two handles exist, one in b, and one in buffer.
2818  
2819      buffer.push_back(b);
2820  
2821  // Two handles still exist -- push_back uses assignment, which
2822  // doesn't affect handles at all. No new handles have been
2823  // created by push_back(b).
2824  
2825  }
2826  
2827  // Now only one handle exists, in buffer, since b has
2828  // gone out of scope and has been destroyed.
2829  
2830  What am I missing?
2831  
2832  Bob
2833  
2834  
2835  -------------------------------------------------------------------------
2836  
2837  To: boost@lists.boost.org 
2838  From: "Alberto Barbati" <abarbati@iaanus.com>   
2839  Date: Tue, 09 Mar 2004 06:07:40 +0100 
2840  Subject: [boost] Re: Formal Review: Circular Buffer 
2841  
2842      
2843  Pavel Vozenilek wrote:
2844  
2845  > "Alberto Barbati" <abarbati@iaanus.com> wrote
2846  > 
2847  > [snip assignement prefereble over destruct/construct]
2848  > 
2849  > 
2850  >>2) with the dtor/ctor idiom, if the ctor throws an exception, the old
2851  >>element is lost and you can't do anything about it, so the container
2852  >>cannot provide more than the basic guarantee for any method that 
2853  might
2854  >>overwrite elements. However, the user might implement assigment with 
2855  the
2856  >>strong guarantee, the container might leverage on that and provide 
2857  the
2858  >>strong guarantee too at least for methods that might overwrite a 
2859  single
2860  >>element such as push_back/push_front. (Of course, the user might
2861  >>implement assignment so badly that it doesn't provide even the basic
2862  >>guarantee and the container could not recover from that, but a 
2863  library
2864  >>such not try to outsmart the user... too much ;).
2865  >>
2866  > 
2867  > This argument isn't valid.
2868  > 
2869  > push_back() will construct elements when there's space
2870  > available in circular buffer.
2871  > 
2872  > Therefore using assignement won't give the method
2873  > strong guarantee (in all cases).
2874  
2875  If there is space, the buffer tries to copy construct an element in an 
2876  empty (uninitialized) space, then the internal state of the buffer is 
2877  updated (this operation does not throw). If the copy ctor throws an 
2878  exception, no object is constructed and the buffer state is not 
2879  modified 
2880  => the buffer is in the exact state it was before the call => strong 
2881  guarantee.
2882  
2883  If there is not enough space, the buffer tries to replace one value by 
2884  invoking operator=, then the internal state is updated (this operation 
2885  doesn't throw). *If operator= provides the strong guarantee* and 
2886  throws, 
2887  the element already in the buffer is not modified and the buffer state 
2888  is not modified either => the buffer is in the exact state it was 
2889  before 
2890  the call => strong guarantee.
2891  
2892  It seems to me that this cover all cases and you always get strong 
2893  guarantee. Am I missing something?
2894  
2895  Alberto
2896  
2897  
2898  
2899  -------------------------------------------------------------------------
2900  
2901  To: boost@lists.boost.org 
2902  From: "Alberto Barbati" <abarbati@iaanus.com>   
2903  Date: Tue, 09 Mar 2004 06:10:11 +0100 
2904  Subject: [boost] Re: Formal Review: Circular Buffer 
2905  
2906      
2907  Robert Bell wrote:
2908  
2909  > I don't see why a handle is lost.
2910  
2911  I agree with Robert analysis, I don't see any lost handle in that 
2912  example.
2913  
2914  Alberto
2915  
2916  
2917  -------------------------------------------------------------------------
2918  
2919  To: boost@lists.boost.org 
2920  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
2921  Date: Tue, 9 Mar 2004 06:24:38 +0100 
2922  Subject: [boost] Re: Formal Review: Circular Buffer 
2923  
2924      
2925  
2926  "Alberto Barbati" <abarbati@iaanus.com> wrote
2927  
2928  > If there is space, the buffer tries to copy construct an element in 
2929  an
2930  > empty (uninitialized) space, then the internal state of the buffer is
2931  > updated (this operation does not throw). If the copy ctor throws an
2932  > exception, no object is constructed and the buffer state is not 
2933  modified
2934  > => the buffer is in the exact state it was before the call => strong
2935  > guarantee.
2936  >
2937  > If there is not enough space, the buffer tries to replace one value 
2938  by
2939  > invoking operator=, then the internal state is updated (this 
2940  operation
2941  > doesn't throw). *If operator= provides the strong guarantee* and 
2942  throws,
2943  > the element already in the buffer is not modified and the buffer 
2944  state
2945  > is not modified either => the buffer is in the exact state it was 
2946  before
2947  > the call => strong guarantee.
2948  >
2949  > It seems to me that this cover all cases and you always get strong
2950  > guarantee. Am I missing something?
2951  >
2952  No, you are right here.
2953  
2954  /Pavel
2955  
2956  
2957  
2958  
2959  -------------------------------------------------------------------------
2960  
2961  To: boost@lists.boost.org 
2962  From: "Alberto Barbati" <abarbati@iaanus.com>   
2963  Date: Tue, 09 Mar 2004 06:41:23 +0100 
2964  Subject: [boost] Re: Formal Review: Circular Buffer 
2965  
2966      
2967  Thorsten Ottosen wrote:
2968  
2969  > "Alberto Barbati" <abarbati@iaanus.com> wrote in message
2970  > news:c2hhhi$lgs$1@sea.gmane.org...
2971  > 
2972  >>Thorsten Ottosen wrote:
2973  > 
2974  > [snip]
2975  > 
2976  >>>The cases where a call to a destructor is actually important beacuse 
2977  it
2978  > 
2979  > does
2980  > 
2981  >>>some
2982  >>>non-trivial work, one really need
2983  >>>to ensure not even temporary objects of the type exists. That's one 
2984  of
2985  > 
2986  > the
2987  > 
2988  >>>capabilities my smart containers will allow, ie, "overwriting" 
2989  really
2990  > 
2991  > means
2992  > 
2993  >>>destructing and replacing.
2994  >>
2995  >>I'm sorry, I don't understand what you are trying to say here. I 
2996  started
2997  >>my sentence with "For primitive types"...
2998  > 
2999  > 
3000  > yeah, I could have said it better :-) What I meant was that 
3001  copy-behavior is
3002  > ususally
3003  > incompatible with non-trivial destructors. What I mean by non-trivial
3004  > destructors is that
3005  > eg. a file is closed or a connection is closed. In those cases making
3006  > temporaries and copies
3007  > is not good: you want more explicit control over when the destructor 
3008  is
3009  > called. (hence you need a
3010  > container of heap-allocated objects and not something like 
3011  vector<Socket> )
3012  >  For most value-like objects we have the opposite situation and we 
3013  don't
3014  > mind if an object is overwritten by
3015  > assignment of if destructors are called.
3016  
3017  I learned that good programming practice is that if a class requires a 
3018  non-trivial destructor it should either implement both the copy 
3019  constructor and the assignment operator or declare them private and 
3020  leave them unimplemented. Moreover, if either the copy constructor or 
3021  the assignment operator is defined, both of them should. I never found 
3022  a 
3023  case where it was worth violating this practice, maybe you have such an 
3024  example?
3025  
3026  Fact is that I still fail to understand why a class that has a 
3027  meaningful copy constructor cannot implement a meaningful assignment 
3028  operator with the same semantic as dtor+copy ctor, but more 
3029  efficiently.
3030  
3031  Alberto
3032  
3033  
3034  -------------------------------------------------------------------------
3035  
3036  To: boost@lists.boost.org 
3037  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
3038  Date: Tue, 9 Mar 2004 07:12:41 +0100 
3039  Subject: [boost] Re: Formal Review: Circular Buffer 
3040  
3041      
3042  
3043  "Robert Bell" <belvis@imageworks.com> wrote
3044  
3045  [snipped]
3046  > What am I missing?
3047  >
3048  Hmm, I thought it over and it seems I am wrong in this
3049  subthread and others are right.
3050  
3051  /Pavel
3052  
3053  
3054  
3055  
3056  -------------------------------------------------------------------------
3057  
3058  To: boost@lists.boost.org 
3059  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
3060  Date: Tue, 9 Mar 2004 17:35:16 +1100 
3061  Subject: [boost] Re: Formal Review: Circular Buffer 
3062  
3063      
3064  "Alberto Barbati" <abarbati@iaanus.com> wrote in message
3065  news:c2jldp$j19$1@sea.gmane.org...
3066  > Thorsten Ottosen wrote:
3067  [snip]
3068  > > yeah, I could have said it better :-) What I meant was that
3069  copy-behavior is
3070  > > ususally
3071  > > incompatible with non-trivial destructors. What I mean by 
3072  non-trivial
3073  > > destructors is that
3074  > > eg. a file is closed or a connection is closed. In those cases 
3075  making
3076  > > temporaries and copies
3077  > > is not good:
3078  [snip]
3079  > I learned that good programming practice is that if a class requires 
3080  a
3081  > non-trivial destructor it should either implement both the copy
3082  > constructor and the assignment operator or declare them private and
3083  > leave them unimplemented.
3084  
3085  true. Don't be confusd by my slight misuse of "non-trivial destructor".
3086  
3087  >Moreover, if either the copy constructor or
3088  > the assignment operator is defined, both of them should.
3089  
3090  also true.
3091  
3092  >I never found a
3093  > case where it was worth violating this practice, maybe you have such 
3094  an
3095  > example?
3096  
3097  no.
3098  
3099  > Fact is that I still fail to understand why a class that has a
3100  > meaningful copy constructor cannot implement a meaningful assignment
3101  > operator with the same semantic as dtor+copy ctor, but more 
3102  efficiently.
3103  
3104  I can't either.
3105  [remark: we agree that circular_buffer should use assignment]
3106  
3107  [note:I was trying to mention a specific type of RAII objects which 
3108  cannot
3109  be put in copying containers].Copy behavior is not always desireable.
3110  If assigment of a Socket class would require the connection to close(), 
3111  then
3112  I don't want assigment. And I don't want temporary objects. Hence the 
3113  object
3114  must be heap-allocated.
3115  
3116  br
3117  
3118  Thorsten
3119  
3120  
3121  
3122  
3123  -------------------------------------------------------------------------
3124  
3125  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
3126  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
3127  Subject:  circular_buffer: problemy s VC6.5 
3128  Date: Tue, 9 Mar 2004 14:58:33 +0100 
3129  
3130      
3131  Ahoj Jano,
3132  
3133  circular buffer ma problemy na VC6.5. Puvodne jsem si mysles ze to je 
3134  kvuli
3135  Boost.Test ale i samostatny program selhava (i potom co jsem aplikoval 
3136  fixy
3137  od Giovanni Bajo).
3138  
3139  Attachnul jsem ho. Kompilator si stezuje na dvou mistech.
3140  
3141  Jinak base_test.cpp kompilovane v debug modu zpusobi access violation
3142  exception, v release modu internal compiler error (testovano na dvo 
3143  ruznych
3144  strojich).
3145  
3146  Mas k dispozici VC6.5? Jinak bych zkusil nejak to obejit.
3147  
3148  /Pavel
3149  
3150  Plain Text Attachment: 
3151  
3152  
3153  #include <boost/circular_buffer.hpp>
3154  
3155  #include <cassert>
3156  
3157  
3158  #include <numeric>
3159  #include <iterator>
3160  #include <vector>
3161  #if !defined(BOOST_NO_EXCEPTIONS)
3162  #include <exception>
3163  #endif
3164  
3165  // Integer - substitute for int - more appropriate for testing
3166  class Integer {
3167  private:
3168      int* m_pValue;
3169      static int ms_exception_trigger;
3170      void check_exception() {
3171          if (ms_exception_trigger > 0) {
3172              if (--ms_exception_trigger == 0) {
3173                  delete m_pValue;
3174                  m_pValue = 0;
3175  #if !defined(BOOST_NO_EXCEPTIONS)
3176                  throw std::exception();
3177  #endif
3178              }
3179          }
3180      }
3181  public:
3182      Integer() : m_pValue(new int(0)) { check_exception(); }
3183      Integer(int i) : m_pValue(new int(i)) { check_exception(); }
3184      Integer(const Integer& src) : m_pValue(new int(src)) { 
3185  check_exception(); }
3186      ~Integer() { delete m_pValue; }
3187      operator int () const { return *m_pValue; }
3188      static void set_exception_trigger(int n) { ms_exception_trigger = 
3189  n; }
3190  private:
3191      Integer& operator = (const Integer& src); // disabled
3192  };
3193  
3194  int Integer::ms_exception_trigger;
3195  
3196  struct A
3197  {
3198      A() : m_n(1) {}
3199      A(int n) : m_n(n) {}
3200      int m_n;
3201  private:
3202      A& operator = (const A& src); // disabled
3203  };
3204  
3205  class B {
3206  public:
3207      B() { increment(); }
3208      B(const B& y) { y.increment(); }
3209      ~B() { decrement(); }
3210      static int count() { return ms_count; }
3211  private:
3212      void increment() const { ++ms_count; }
3213      void decrement() const { --ms_count; }
3214      static int ms_count;
3215      B& operator = (const B& src); // disabled
3216  };
3217  
3218  class C {
3219  public:
3220      C() : m_num(255) {}
3221      virtual int test_reference1() const { return m_num; }
3222      int test_reference2() const { return 255; }
3223  private:
3224      int m_num;
3225      C& operator = (const C& src); // disabled
3226  };
3227  
3228  template <class T> class Adaptor {
3229  private:
3230      boost::circular_buffer<T> m_buff;
3231  public:
3232      typedef typename boost::circular_buffer<T>::iterator iterator;
3233      typedef typename boost::circular_buffer<T>::size_type size_type;
3234      
3235      Adaptor(size_type capacity) : m_buff(capacity) {}
3236      template <class InputIterator>
3237          Adaptor(size_type capacity, InputIterator first, InputIterator 
3238  last)
3239          : m_buff(capacity, first, last) {}
3240      
3241      iterator begin() { return m_buff.begin(); }
3242      iterator end() { return m_buff.end(); }
3243      size_type size() const { return m_buff.size(); }
3244      size_type capacity() const { return m_buff.capacity(); }
3245      T& operator [] (size_type index) { return m_buff[index]; }
3246      
3247      template <class InputIterator>
3248          void insert(iterator pos, InputIterator first, InputIterator 
3249  last) {
3250          size_type new_size = size() + distance(first, last);
3251          if (new_size > capacity()) {
3252              boost::circular_buffer<T> buff(new_size, begin(), pos);
3253              buff.insert(buff.end(), first, last);
3254              buff.insert(buff.end(), pos, end());
3255              m_buff.swap(buff);
3256          } else {
3257              m_buff.insert(pos, first, last);
3258          }
3259      }
3260  };
3261  
3262  
3263  using namespace boost;
3264  using namespace std;
3265  
3266  #define BOOST_CHECK(x) assert(x)
3267  #define BOOST_CHECK_THROW(x, y) try { x ; assert(false); } catch (const 
3268  y &) {} 
3269  
3270  void iterator_constructor_and_assign_test() {
3271  
3272      circular_buffer<Integer> cb(4, 3);
3273      circular_buffer<Integer>::iterator it = cb.begin();
3274      circular_buffer<Integer>::iterator itCopy;
3275      itCopy = it;
3276      it = it;
3277      circular_buffer<Integer>::const_iterator cit;
3278      cit = it;
3279      circular_buffer<Integer>::const_iterator end1 = cb.end();
3280      circular_buffer<Integer>::const_iterator end2 = end1;
3281  
3282      BOOST_CHECK(itCopy == it);
3283      BOOST_CHECK(cit == it);
3284      BOOST_CHECK(end1 == end2);
3285      BOOST_CHECK(it != end1);
3286      BOOST_CHECK(cit != end2);
3287  }
3288  
3289  void iterator_reference_test() {
3290  
3291      circular_buffer<C> cb(3, C());
3292      circular_buffer<C>::iterator it = cb.begin();
3293      circular_buffer<C>::const_iterator cit = cb.begin() + 1;
3294  
3295      BOOST_CHECK((*it).test_reference1() == it->test_reference2());
3296      BOOST_CHECK((*cit).test_reference2() == cit->test_reference1());
3297  }
3298  
3299  void iterator_difference_test() {
3300  
3301      circular_buffer<Integer> cb(5, 1);
3302      cb.push_back(2);
3303      circular_buffer<Integer>::iterator it1 = cb.begin() + 2;
3304      circular_buffer<Integer>::iterator it2 = cb.begin() + 3;
3305      circular_buffer<Integer>::const_iterator begin = cb.begin();
3306      circular_buffer<Integer>::iterator end = cb.end();
3307  
3308      BOOST_CHECK(begin - begin == 0);
3309      BOOST_CHECK(end - cb.begin() == 5);
3310      BOOST_CHECK(end - end == 0);
3311      BOOST_CHECK(begin - cb.end() == -5);
3312      BOOST_CHECK(it1 - cb.begin() == 2);
3313      BOOST_CHECK(end - it1 == 3);
3314      BOOST_CHECK(it2 - it1 == 1);
3315      BOOST_CHECK(it1 - it2 == -1);
3316      BOOST_CHECK(it2 - it2 == 0);
3317  }
3318  
3319  void iterator_increment_test() {
3320  
3321      circular_buffer<Integer> cb(10, 1);
3322      cb.push_back(2);
3323      circular_buffer<Integer>::iterator it1 = cb.begin();
3324      circular_buffer<Integer>::iterator it2 = cb.begin() + 5;
3325      circular_buffer<Integer>::iterator it3 = cb.begin() + 9;
3326      it1++;
3327      it2++;
3328      ++it3;
3329  
3330      BOOST_CHECK(it1 == cb.begin() + 1);
3331      BOOST_CHECK(it2 == cb.begin() + 6);
3332      BOOST_CHECK(it3 == cb.end());
3333  }
3334  
3335  void iterator_decrement_test() {
3336  
3337      circular_buffer<Integer> cb(10, 1);
3338      cb.push_back(2);
3339      circular_buffer<Integer>::iterator it1= cb.end();
3340      circular_buffer<Integer>::iterator it2= cb.end() - 5;
3341      circular_buffer<Integer>::iterator it3= cb.end() - 9;
3342      --it1;
3343      it2--;
3344      --it3;
3345  
3346      BOOST_CHECK(it1 == cb.end() - 1);
3347      BOOST_CHECK(it2 == cb.end() - 6);
3348      BOOST_CHECK(it3 == cb.begin());
3349  }
3350  
3351  void iterator_addition_test() {
3352  
3353      circular_buffer<Integer> cb(10, 1);
3354      cb.push_back(2);
3355      cb.push_back(2);
3356      circular_buffer<Integer>::iterator it1 = cb.begin() + 2;
3357      circular_buffer<Integer>::iterator it2 = cb.end();
3358      circular_buffer<Integer>::iterator it3 = cb.begin() + 5;
3359      circular_buffer<Integer>::iterator it4 = cb.begin() + 9;
3360      it1 += 3;
3361      it2 += 0;
3362      it3 += 5;
3363      it4 += -2;
3364  
3365      BOOST_CHECK(it1 == 5 + cb.begin());
3366      BOOST_CHECK(it2 == cb.end());
3367      BOOST_CHECK(it3 == cb.end());
3368      BOOST_CHECK(it4 + 3 == cb.end());
3369      BOOST_CHECK((-3) + it4 == cb.begin() + 4);
3370      BOOST_CHECK(cb.begin() + 0 == cb.begin());
3371  }
3372  
3373  void iterator_subtraction_test() {
3374  
3375      circular_buffer<Integer> cb(10, 1);
3376      cb.push_back(2);
3377      cb.push_back(2);
3378      cb.push_back(2);
3379      circular_buffer<Integer>::iterator it1 = cb.begin();
3380      circular_buffer<Integer>::iterator it2 = cb.end();
3381      circular_buffer<Integer>::iterator it3 = cb.end() - 5;
3382      circular_buffer<Integer>::iterator it4 = cb.begin() + 7;
3383      it1 -= -2;
3384      it2 -= 0;
3385      it3 -= 5;
3386  
3387      BOOST_CHECK(it1 == cb.begin() + 2);
3388      BOOST_CHECK(it2 == cb.end());
3389      BOOST_CHECK(it3 == cb.begin());
3390      BOOST_CHECK(it4 - 7 == cb.begin());
3391      BOOST_CHECK(it4 - (-3) == cb.end());
3392      BOOST_CHECK(cb.begin() - 0 == cb.begin());
3393  }
3394  
3395  void iterator_element_access_test() {
3396  
3397      circular_buffer<Integer> cb(10);
3398      cb.push_back(1);
3399      cb.push_back(2);
3400      cb.push_back(3);
3401      cb.push_back(4);
3402      cb.push_back(5);
3403      cb.push_back(6);
3404      circular_buffer<Integer>::iterator it = cb.begin() + 1;
3405  
3406      BOOST_CHECK(it[0] == 2);
3407      BOOST_CHECK(it[-1] == 1);
3408      BOOST_CHECK(it[2] == 4);
3409  }
3410  
3411  void iterator_comparison_test() {
3412  
3413      circular_buffer<Integer> cb(5, 1);
3414      cb.push_back(2);
3415      circular_buffer<Integer>::iterator it = cb.begin() + 2;
3416      circular_buffer<Integer>::const_iterator begin = cb.begin();
3417      circular_buffer<Integer>::iterator end = cb.end();
3418  
3419      BOOST_CHECK(begin == begin);
3420      BOOST_CHECK(end > cb.begin());
3421      BOOST_CHECK(begin < end);
3422      BOOST_CHECK(end > begin);
3423      BOOST_CHECK(end == end);
3424      BOOST_CHECK(begin < cb.end());
3425      BOOST_CHECK(!(begin + 1 > cb.end()));
3426      BOOST_CHECK(it > cb.begin());
3427      BOOST_CHECK(end > it);
3428      BOOST_CHECK(begin >= begin);
3429      BOOST_CHECK(end >= cb.begin());
3430      BOOST_CHECK(end <= end);
3431      BOOST_CHECK(begin <= cb.end());
3432      BOOST_CHECK(it >= cb.begin());
3433      BOOST_CHECK(end >= it);
3434      BOOST_CHECK(!(begin + 4 < begin + 4));
3435      BOOST_CHECK(begin + 4 < begin + 5);
3436      BOOST_CHECK(!(begin + 5 < begin + 4));
3437      BOOST_CHECK(it < end - 1);
3438      BOOST_CHECK(!(end - 1 < it));
3439  }
3440  
3441  void iterator_invalidation_test() {
3442  
3443  #if !defined(NDEBUG) && !defined(BOOST_DISABLE_CB_DEBUG)
3444  
3445      circular_buffer<Integer>::iterator it1;
3446      circular_buffer<Integer>::const_iterator it2;
3447      circular_buffer<Integer>::iterator it3;
3448      circular_buffer<Integer>::const_iterator it4;
3449      circular_buffer<Integer>::const_iterator it5;
3450  
3451      BOOST_CHECK(!it1.is_valid());
3452      BOOST_CHECK(!it2.is_valid());
3453      BOOST_CHECK(!it3.is_valid());
3454      BOOST_CHECK(!it4.is_valid());
3455      BOOST_CHECK(!it5.is_valid());
3456  
3457      {
3458          circular_buffer<Integer> cb(5, 0);
3459          const circular_buffer<Integer> ccb(5, 0);
3460  
3461          it1 = cb.begin();
3462          it2 = ccb.end();
3463          it3 = it1;
3464          it4 = it1;
3465          it5 = it2;
3466  
3467          BOOST_CHECK(it1.is_valid());
3468          BOOST_CHECK(it2.is_valid());
3469          BOOST_CHECK(it3.is_valid());
3470          BOOST_CHECK(it4.is_valid());
3471          BOOST_CHECK(it5.is_valid());
3472      }
3473  
3474      BOOST_CHECK(!it1.is_valid());
3475      BOOST_CHECK(!it2.is_valid());
3476      BOOST_CHECK(!it3.is_valid());
3477      BOOST_CHECK(!it4.is_valid());
3478      BOOST_CHECK(!it5.is_valid());
3479  
3480      circular_buffer<Integer> cb1(10, 0);
3481      circular_buffer<Integer> cb2(20, 0);
3482      it1 = cb1.end();
3483      it2 = cb2.begin();
3484      BOOST_CHECK(it1.is_valid());
3485      BOOST_CHECK(it2.is_valid());
3486  
3487      cb1.swap(cb2);
3488      BOOST_CHECK(!it1.is_valid());
3489      BOOST_CHECK(!it2.is_valid());
3490  
3491      it1 = cb1.begin() + 3;
3492      it2 = cb1.begin();
3493      cb1.push_back(1);
3494      BOOST_CHECK(it1.is_valid());
3495      BOOST_CHECK(!it2.is_valid());
3496      BOOST_CHECK(*it2.m_it == 1);
3497  
3498      circular_buffer<Integer> cb3(5);
3499      cb3.push_back(1);
3500      cb3.push_back(2);
3501      cb3.push_back(3);
3502      cb3.push_back(4);
3503      cb3.push_back(5);
3504      it1 = cb3.begin() + 2;
3505      it2 = cb3.begin();
3506      cb3.insert(cb3.begin() + 3, 6);
3507      BOOST_CHECK(it1.is_valid());
3508      BOOST_CHECK(!it2.is_valid());
3509      BOOST_CHECK(*it2.m_it == 5);
3510  
3511      it1 = cb3.begin() + 3;
3512      it2 = cb3.end() - 1;
3513      cb3.push_front(7);
3514      BOOST_CHECK(it1.is_valid());
3515      BOOST_CHECK(!it2.is_valid());
3516      BOOST_CHECK(*it2.m_it == 7);
3517  
3518      circular_buffer<Integer> cb4(5);
3519      cb4.push_back(1);
3520      cb4.push_back(2);
3521      cb4.push_back(3);
3522      cb4.push_back(4);
3523      cb4.push_back(5);
3524      it1 = cb4.begin() + 3;
3525      it2 = cb4.begin();
3526      cb4.rinsert(cb4.begin() + 2, 6);
3527      BOOST_CHECK(it1.is_valid());
3528      BOOST_CHECK(!it2.is_valid());
3529      BOOST_CHECK(*it2.m_it == 2);
3530  
3531      it1 = cb1.begin() + 5;
3532      it2 = cb1.end() - 1;
3533      cb1.pop_back();
3534      BOOST_CHECK(it1.is_valid());
3535      BOOST_CHECK(!it2.is_valid());
3536  
3537      it1 = cb1.begin() + 5;
3538      it2 = cb1.begin();
3539      cb1.pop_front();
3540      BOOST_CHECK(it1.is_valid());
3541      BOOST_CHECK(!it2.is_valid());
3542  
3543      circular_buffer<Integer> cb5(20, 0);
3544      it1 = cb5.begin() + 5;
3545      it2 = cb5.begin() + 15;
3546      cb5.erase(cb5.begin() + 10);
3547      BOOST_CHECK(it1.is_valid());
3548      BOOST_CHECK(!it2.is_valid());
3549  
3550      it1 = cb5.begin() + 1;
3551      it2 = cb5.begin() + 8;
3552      cb5.erase(cb5.begin() + 3, cb5.begin() + 7);
3553      BOOST_CHECK(it1.is_valid());
3554      BOOST_CHECK(!it2.is_valid());
3555  
3556  #endif // #if !defined(NDEBUG) && !defined(BOOST_DISABLE_CB_DEBUG)
3557  }
3558  
3559  // basic exception safety test (it is useful to use any memory-leak 
3560  detection tool)
3561  void exception_safety_test() {
3562  
3563  #if !defined(BOOST_NO_EXCEPTIONS)
3564  
3565      circular_buffer<Integer> cb1(3, 5);
3566      Integer::set_exception_trigger(3);
3567      BOOST_CHECK_THROW(cb1.set_capacity(5), exception);
3568  
3569      Integer::set_exception_trigger(3);
3570      BOOST_CHECK_THROW(circular_buffer<Integer> cb2(5, 10), exception);
3571  
3572      circular_buffer<Integer> cb3(5, 10);
3573      Integer::set_exception_trigger(3);
3574      BOOST_CHECK_THROW(circular_buffer<Integer> cb4(cb3), exception);
3575  
3576      vector<Integer> v(5, 10);
3577      Integer::set_exception_trigger(3);
3578      BOOST_CHECK_THROW(circular_buffer<Integer> cb5(8, v.begin(), 
3579  v.end()), exception);
3580  
3581      circular_buffer<Integer> cb6(5, 10);
3582      circular_buffer<Integer> cb7(8, 3);
3583      Integer::set_exception_trigger(3);
3584      BOOST_CHECK_THROW(cb7 = cb6, exception);
3585  
3586      circular_buffer<Integer> cb8(5, 10);
3587      Integer::set_exception_trigger(2);
3588      BOOST_CHECK_THROW(cb8.push_front(1), exception);
3589  
3590      circular_buffer<Integer> cb9(5);
3591      cb9.push_back(1);
3592      cb9.push_back(2);
3593      cb9.push_back(3);
3594      Integer::set_exception_trigger(3);
3595      BOOST_CHECK_THROW(cb9.insert(cb9.begin() + 1, 4), exception);
3596  
3597      circular_buffer<Integer> cb10(5);
3598      cb10.push_back(1);
3599      cb10.push_back(2);
3600      cb10.push_back(3);
3601      Integer::set_exception_trigger(3);
3602      BOOST_CHECK_THROW(cb10.rinsert(cb10.begin() + 1, 4), exception);
3603  
3604      circular_buffer<Integer> cb11(5);
3605      cb11.push_back(1);
3606      cb11.push_back(2);
3607      Integer::set_exception_trigger(2);
3608      BOOST_CHECK_THROW(cb11.rinsert(cb11.begin(), 1), exception);
3609  
3610      circular_buffer<Integer> cb12(5, 1);
3611      Integer::set_exception_trigger(3);
3612      BOOST_CHECK_THROW(cb12.assign(4, 2), exception);
3613  
3614      circular_buffer<Integer> cb13(5, 1);
3615      Integer::set_exception_trigger(3);
3616      BOOST_CHECK_THROW(cb13.assign(6, 2), exception);
3617  
3618      circular_buffer<Integer> cb14(5);
3619      cb14.push_back(1);
3620      cb14.push_back(2);
3621      Integer::set_exception_trigger(3);
3622      BOOST_CHECK_THROW(cb14.insert(cb14.begin(), 10, 3), exception);
3623  
3624      circular_buffer<Integer> cb15(5);
3625      cb15.push_back(1);
3626      cb15.push_back(2);
3627      Integer::set_exception_trigger(3);
3628      BOOST_CHECK_THROW(cb15.insert(cb15.end(), 10, 3), exception);
3629  
3630      circular_buffer<Integer> cb16(5);
3631      cb16.push_back(1);
3632      cb16.push_back(2);
3633      Integer::set_exception_trigger(3);
3634      BOOST_CHECK_THROW(cb16.rinsert(cb16.begin(), 10, 3), exception);
3635  
3636      circular_buffer<Integer> cb17(5);
3637      cb17.push_back(1);
3638      cb17.push_back(2);
3639      Integer::set_exception_trigger(3);
3640      BOOST_CHECK_THROW(cb17.rinsert(cb17.end(), 10, 3), exception);
3641  
3642      circular_buffer<Integer> cb18(5, 0);
3643      cb18.push_back(1);
3644      cb18.push_back(2);
3645      cb18.pop_front();
3646      Integer::set_exception_trigger(4);
3647      BOOST_CHECK_THROW(cb18.data(), exception);
3648  
3649      circular_buffer<Integer> cb19(5, 0);
3650      cb19.push_back(1);
3651      cb19.push_back(2);
3652      Integer::set_exception_trigger(5);
3653      BOOST_CHECK_THROW(cb19.data(), exception);
3654  
3655      circular_buffer<Integer> cb20(5, 0);
3656      cb20.push_back(1);
3657      cb20.push_back(2);
3658      Integer::set_exception_trigger(6);
3659      BOOST_CHECK_THROW(cb20.data(), exception);
3660  
3661      circular_buffer<Integer> cb21(5);
3662      cb21.push_back(1);
3663      cb21.push_back(2);
3664      cb21.push_back(3);
3665      Integer::set_exception_trigger(2);
3666      BOOST_CHECK_THROW(cb21.insert(cb21.begin() + 1, 4), exception);
3667  
3668      circular_buffer<Integer> cb22(5);
3669      cb22.push_back(1);
3670      cb22.push_back(2);
3671      cb22.push_back(3);
3672      Integer::set_exception_trigger(2);
3673      BOOST_CHECK_THROW(cb22.insert(cb22.end(), 4), exception);
3674  
3675      circular_buffer<Integer> cb23(5, 0);
3676      Integer::set_exception_trigger(2);
3677      BOOST_CHECK_THROW(cb23.insert(cb23.begin() + 1, 4), exception);
3678  
3679      circular_buffer<Integer> cb24(5);
3680      cb24.push_back(1);
3681      cb24.push_back(2);
3682      cb24.push_back(3);
3683      Integer::set_exception_trigger(2);
3684      BOOST_CHECK_THROW(cb24.rinsert(cb24.begin() + 1, 4), exception);
3685  
3686      circular_buffer<Integer> cb25(5, 0);
3687      Integer::set_exception_trigger(2);
3688      BOOST_CHECK_THROW(cb25.rinsert(cb25.begin() + 3, 4), exception);
3689  
3690      circular_buffer<Integer> cb26(5);
3691      cb26.push_back(1);
3692      cb26.push_back(2);
3693      Integer::set_exception_trigger(5);
3694      BOOST_CHECK_THROW(cb26.insert(cb26.begin(), 10, 3), exception);
3695  
3696      circular_buffer<Integer> cb27(5);
3697      cb27.push_back(1);
3698      cb27.push_back(2);
3699      Integer::set_exception_trigger(5);
3700      BOOST_CHECK_THROW(cb27.insert(cb27.end(), 10, 3), exception);
3701  
3702      circular_buffer<Integer> cb28(5);
3703      cb28.push_back(1);
3704      cb28.push_back(2);
3705      Integer::set_exception_trigger(5);
3706      BOOST_CHECK_THROW(cb28.rinsert(cb28.begin(), 10, 3), exception);
3707  
3708      circular_buffer<Integer> cb29(5);
3709      cb29.push_back(1);
3710      cb29.push_back(2);
3711      Integer::set_exception_trigger(5);
3712      BOOST_CHECK_THROW(cb29.rinsert(cb29.end(), 10, 3), exception);
3713  
3714      circular_buffer<Integer> cb30(10);
3715      cb30.push_back(1);
3716      cb30.push_back(2);
3717      cb30.push_back(3);
3718      Integer::set_exception_trigger(2);
3719      BOOST_CHECK_THROW(cb30.rinsert(cb30.begin(), 10, 3), exception);
3720  
3721  #endif // #if !defined(BOOST_NO_EXCEPTIONS)
3722  }
3723  
3724  // test main
3725  void main()
3726  {
3727      iterator_constructor_and_assign_test();
3728      iterator_reference_test();
3729      iterator_difference_test();
3730      iterator_increment_test();
3731      iterator_decrement_test();
3732      iterator_addition_test();
3733      iterator_subtraction_test();
3734      iterator_element_access_test();
3735      iterator_comparison_test();
3736      iterator_invalidation_test();
3737      exception_safety_test();
3738  
3739  }
3740  
3741  
3742  -------------------------------------------------------------------------
3743  
3744  From: "Jeremy Siek" <jsiek@osl.iu.edu>   
3745  Subject: Re: [boost] Formal Review: Circular Buffer 
3746  Date: Tue, 9 Mar 2004 09:24:36 -0500 
3747  To: boost@lists.boost.org 
3748  
3749      
3750  Hi Jan,
3751  
3752  On Mar 8, 2004, at 1:03 PM, Jan Gaspar wrote:
3753  > I think the Alloc has to be just an allocator (with
3754  > the neccessary methods). No special requirements
3755  > needed.
3756  >
3757  
3758  That's what I mean, the documentation should say that
3759  Alloc is required to meet the standard allocator requirements.
3760  
3761  Cheers,
3762  Jeremy
3763  
3764  _______________________________________________
3765  Jeremy Siek <jsiek@osl.iu.edu>
3766  http://www.osl.iu.edu/~jsiek
3767  Ph.D. Student, Indiana University Bloomington
3768  C++ Booster (http://www.boost.org)
3769  Office phone: (812) 856-1820
3770  
3771  
3772  -------------------------------------------------------------------------
3773  
3774  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
3775  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
3776  Subject: Re: circular_buffer: problemy s VC6.5 
3777  Date: Tue, 9 Mar 2004 16:46:38 +0100 
3778  
3779      
3780  Ahoj Jano,
3781  
3782  > Mam pristup len ku VC6.0. Vyskusam to s tym, mozno
3783  > budem mat tie iste problemy.
3784  > 
3785  Nemel bych pouzivat slang. VC6.5 je VC6.0 + service pack 5.
3786  Ten se da stahnout free z MSDN:
3787  http://msdn.microsoft.com/vstudio/downloads/updates/sp/vs6/sp5/default
3788  .aspx
3789  Cislo service packu se ukaze v splash screen.
3790  
3791  /Pavel
3792         
3793  -------------------------------------------------------------------------
3794         
3795  Subject: RE: [boost] Formal Review: Circular Buffer 
3796  Date: Tue, 9 Mar 2004 09:44:34 -0800 
3797  From: "Powell, Gary" <powellg@amazon.com>   
3798  To: boost@lists.boost.org 
3799  
3800      
3801  Shouldn't the comparison functions allow the types to differ? I mean 
3802  don't they still lexigraphically compare as long as there is a comparison 
3803  function F that a F b for each element exists
3804  
3805  circular_buffer<T, MyAlloc> x;
3806  circular_buffer<S, YourAlloc> y;
3807  
3808  bool b = x == y; for where the operator T == S is valid? And what does 
3809  the allocator have to do with it?
3810  
3811  Therefore IMO, all of the comparison functions should change from
3812  
3813  template< typename T, typename Alloc>
3814  bool operator F ( circular_buffer<T, Alloc> &lhs, 
3815                    circular_buffer<T, Alloc> &rhs);
3816  
3817  to
3818  
3819  template< typename T1, typename Alloc1,
3820            typename T2, typename Alloc2>
3821  bool operator F ( circular_buffer<T1, Alloc1> &lhs, 
3822                    circular_buffer<T2, Alloc2> &rhs);
3823  
3824    Yours,
3825    -Gary-
3826  
3827  powellg@amazon.com
3828  
3829  
3830  -------------------------------------------------------------------------
3831  
3832  Subject: RE: [boost] Formal Review: Circular Buffer 
3833  Date: Tue, 9 Mar 2004 09:45:07 -0800 
3834  From: "Powell, Gary" <powellg@amazon.com>   
3835  To: boost@lists.boost.org 
3836  
3837      
3838  documentation bug:
3839  Definition of data() Shouldn't that be only in the doc for the circular 
3840  buffer space optimized? It isn't part of the adaptor interface.
3841  
3842  Also this may be old ground, but any particular reason you are not 
3843  using a std::vector as the underlying container, coupled with the iterator 
3844  adaptors?
3845  
3846  On the positive side, I like the functionality. I use this sort of 
3847  container all the time. I often have things for which I can only hold N
3848  and when I have N+1, I need to purge the oldest.
3849  
3850    Yours,
3851    -Gary-
3852  
3853    
3854  
3855  
3856  -------------------------------------------------------------------------
3857  
3858  Subject: RE: [boost] Formal Review: Circular Buffer 
3859  Date: Tue, 9 Mar 2004 10:19:38 -0800 
3860  From: "Powell, Gary" <powellg@amazon.com>   
3861  To: boost@lists.boost.org 
3862  
3863      
3864  I have reviewed Jan Gaspar's circular buffer.
3865  
3866  What is your evaluation of the design?  
3867  
3868  It's a useful container. I've hacked up a couple in my coding
3869  career and this one is very nice.
3870  
3871  Although I've usually implemented them as an adaptor to a container.
3872  This separates the container that I've optimized for the problem from
3873  the circular nature of it.  
3874  
3875  What is your evaluation of the implementation?  
3876  
3877  I was able to run the sample code with gcc 3.2 no problem.
3878  
3879  What is your evaluation of the documentation?  
3880  
3881  Doc's are fine.
3882  
3883  What is your evaluation of the potential usefulness of the library?
3884  Useful for both embedded systems and those with a stack that needs 
3885  to be limited. With a smart destructor you can push objects into the
3886  circular buffer holding them until you are either "full", or have
3887  time to deal with them.
3888  
3889  How much effort did you put into your evaluation? Shallow-depth study?
3890  Shallow study. One evening.
3891  
3892  Are you knowledgeable about the problem domain?
3893  Somewhat. I used to program for embedded systems, games, where
3894  memory is limited. We used this sort of buffer to constrain the
3895  the art resources from taking over the available memory.
3896  
3897  Other comments:
3898  
3899  Do you think the library should be accepted as a Boost library?
3900  
3901  I vote for acceptance with or without the suggested change about
3902  adapting a container. The comparison operators do need to be
3903  fixed though to compare two types.
3904  
3905  i.e.
3906  circular_buffer<int> x = { 1, 2, 3 }; // pseudo code.
3907  circular_buffer<short> y = { 1, 2,3 };
3908  x == y  -> true
3909  
3910    However I would prefer that the underlying container be part of the
3911  interface. But that's not a fixed in stone opinion.
3912  
3913  
3914  
3915  -------------------------------------------------------------------------
3916  
3917  To: boost@lists.boost.org 
3918  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
3919  Date: Tue, 9 Mar 2004 20:49:24 +0100 
3920  Subject: [boost] Re: Formal Review: Circular Buffer 
3921  
3922      
3923  
3924  "Powell, Gary" <powellg@amazon.com> wrote
3925  
3926  > Definition of data() Shouldn't that be only in the doc for the
3927  > circular buffer space optimized? It isn't part of the adaptor 
3928  interface.
3929  >
3930  No, it is part of 'core'.
3931  
3932  > Also this may be old ground, but any particular reason
3933  > you are not using a std::vector as the underlying container,
3934  > coupled with the iterator adaptors?
3935  >
3936  Complete control over data, debug support.
3937  
3938  /Pavel
3939  
3940  
3941  
3942  
3943  
3944  -------------------------------------------------------------------------
3945  
3946  To: boost@lists.boost.org 
3947  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
3948  Date: Tue, 9 Mar 2004 20:52:29 +0100 
3949  Subject: [boost] Re: Formal Review: Circular Buffer 
3950  
3951      
3952  
3953  "Powell, Gary" <powellg@amazon.com> wrote
3954  
3955  
3956  > Shouldn't the comparison functions allow the types to differ?
3957  >
3958  > circular_buffer<T, MyAlloc> x;
3959  > circular_buffer<S, YourAlloc> y;
3960  >
3961  > bool b = x == y; for where the operator T == S is valid?
3962  > And what does the allocator have to do with it?
3963  >
3964  Hmm, do you know a STL implementation/some container
3965  with this feature? It may be often bug to compare containers with
3966  different types.
3967  
3968  /Pavel
3969  
3970  
3971  
3972  
3973  
3974  -------------------------------------------------------------------------
3975  
3976  Subject: RE: [boost] Re: Formal Review: Circular Buffer 
3977  Date: Tue, 9 Mar 2004 13:55:15 -0800 
3978  From: "Powell, Gary" <powellg@amazon.com>   
3979  To: boost@lists.boost.org 
3980  
3981      
3982  No, but just because the standard libraries scr*wed up is no reason to 
3983  perpetuate the mistake.
3984  
3985  It's the rule of unexpected consequences.
3986  
3987  Is 
3988  circular_buffer<int> x  = { 1, 2, 3};
3989  circular_buffer<short> y = { 1, 2 ,3};
3990  
3991  x == y ?? or not?
3992  
3993  Sure looks like it should work.
3994  
3995  The VTL library does it IMO correctly, allowing that if there is an 
3996  operation
3997  T1 F T2, then
3998  
3999  V1 F V2  compiles. Otherwise you just force the user to write what 
4000  should be library
4001  code.
4002  
4003  (Obviously swap can't do this unless the Allocators are the same.)
4004  
4005  template<class T1, class T2, class Alloc>
4006  void swap( circular_buffer<T1, Alloc> &lhs, circular_buffer<T2, Alloc> 
4007  &rhs)
4008  {
4009     // do an element by element swap.
4010     // and insert for the leftover elements.
4011  }
4012  
4013  template<class T1, class Alloc>
4014  void swap<T1, T1, Alloc> ( circular_buffer<T1, Alloc> &lhs, 
4015  circular_buffer<T1, Alloc> &rhs)
4016  {
4017     // swap the whole container.
4018     lhs.swap(rhs);
4019  }
4020  
4021    Yours,
4022    -Gary-
4023  
4024  
4025  -----Original Message-----
4026  From: boost-bounces@lists.boost.org 
4027  [mailto:boost-bounces@lists.boost.org] On Behalf Of Pavel Vozenilek
4028  Sent: Tuesday, March 09, 2004 11:52 AM
4029  To: boost@lists.boost.org
4030  Subject: [boost] Re: Formal Review: Circular Buffer
4031  
4032  
4033  
4034  "Powell, Gary" <powellg@amazon.com> wrote
4035  
4036  
4037  > Shouldn't the comparison functions allow the types to differ?
4038  >
4039  > circular_buffer<T, MyAlloc> x;
4040  > circular_buffer<S, YourAlloc> y;
4041  >
4042  > bool b = x == y; for where the operator T == S is valid?
4043  > And what does the allocator have to do with it?
4044  >
4045  Hmm, do you know a STL implementation/some container
4046  with this feature? It may be often bug to compare containers with
4047  different types.
4048  
4049  /Pavel
4050  
4051  
4052  -------------------------------------------------------------------------
4053  
4054  Date: Tue, 09 Mar 2004 23:56:28 +0100 
4055  From: "JOAQUIN LOPEZ MU?Z" <joaquin@tid.es>   
4056  Subject: Re: RE: [boost] Re: Formal Review: Circular Buffer 
4057  To: boost@lists.boost.org 
4058  CC:  
4059  
4060      
4061  ----- Mensaje original -----
4062  De: "Powell, Gary" <powellg@amazon.com>
4063  Fecha: Martes, Marzo 9, 2004 10:55 pm
4064  Asunto: RE: [boost] Re: Formal Review: Circular Buffer
4065  
4066  > 
4067  > The VTL library does it IMO correctly, allowing that if there is 
4068  > an operation
4069  > T1 F T2, then
4070  > 
4071  > V1 F V2  compiles. Otherwise you just force the user to write what 
4072  > should be library
4073  > code.
4074  > 
4075  > (Obviously swap can't do this unless the Allocators are the same.)
4076  > 
4077  
4078  I don't quite get you here. I think the two allocator
4079  types cannot be equal: the first allocator allocates T1's,
4080  the second T2's. I might be totally misinterpreting you, of
4081  course.
4082  
4083  
4084  > template<class T1, class T2, class Alloc>
4085  > void swap( circular_buffer<T1, Alloc> &lhs, circular_buffer<T2, 
4086  > Alloc> &rhs)
4087  > {
4088  >   // do an element by element swap.
4089  >   // and insert for the leftover elements.
4090  > }
4091  > 
4092  
4093  IMHO doing an elementwise swapping is very ill-behaved.
4094  It would reduce to repeatedly calling something like:
4095  
4096  template <typename T1,typename T2>
4097  void swap_different(T1& x,T1& y)
4098  {
4099    T1 tmp(y);
4100    x=y;
4101    y=x;
4102  }
4103  
4104  So, for swap to have *some* exception safety the
4105  assignment operators must not throw, which seems too
4106  restrictive (think types with dynamic allocation).
4107  Maybe things can be improved a bit with something along
4108  this line:
4109  
4110  template<class T1, class T2, class Alloc1, class Alloc2>
4111  void swap(
4112    circular_buffer<T1, Alloc1> &lhs,
4113    circular_buffer<T2, Alloc2> &rhs)
4114  {
4115    circular_buffer<T1, Alloc1> new_lhs;
4116    // copy rhs into new_lhs
4117    circular_buffer<T2, Alloc2> new_rhs;
4118    // copy lhs into new_rhs
4119  
4120    lhs.swap(new_lhs); // nothrow
4121    rhs.swap(new_rhs); // nothrow
4122  }
4123  
4124  There is a final annoyance, though: in many cases
4125  the code can emit a narrowing cast warning (if assigning
4126  an int to a short, for instance.)
4127  
4128  Joaqun M Lpez Munoz
4129  Telefnica, Investigacin y Desarrollo
4130  
4131  
4132  
4133  
4134  -------------------------------------------------------------------------
4135  
4136  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
4137  To: jano_gaspar@yahoo.com 
4138  Subject:  [circular_buffer] compile problems 
4139  Date: Fri, 12 Mar 2004 17:47:16 +1100 
4140  
4141      
4142  Hi Jan,
4143  
4144  My Comeau compiler has these complaints when trying a simple test 
4145  program:
4146  
4147  "boost/circular_buffer/debug.hpp", line 60: error #393: pointer to
4148  incomplete
4149            class type is not allowed
4150            for (const cb_iterator_base* p = m_iterators; p != 0; p =
4151  p->next()) {
4152                                                                      ^
4153  
4154  "boost/circular_buffer/debug.hpp", line 62: error #393: pointer to
4155  incomplete
4156            class type is not allowed
4157                    p->invalidate();
4158                    ^
4159  
4160  
4161  "boost/circular_buffer/base.hpp", line 139: error #1201: typedef 
4162  "iterator"
4163            may not be used in an elaborated type specifier
4164        friend struct iterator;
4165                      ^
4166  
4167  "boost/circular_buffer/base.hpp", line 140: error #1201: typedef
4168            "const_iterator" may not be used in an elaborated type 
4169  specifier
4170        friend struct const_iterator;
4171  
4172  There might be more. The first two can be fixed by the attached patch.
4173  Would you say comeau is right or wrong?
4174  
4175  best regards
4176  
4177  Thorsten
4178  
4179  PS: Here's the test program:
4180  
4181  #include "boost/circular_buffer.hpp"
4182  #include <boost/progress.hpp>
4183  #include <deque>
4184  #include <string>
4185  
4186  using namespace boost;
4187  using namespace std;
4188  
4189  int main()
4190  {
4191      enum { size = 1000 };
4192      deque<string> ds( size );
4193      deque<int>    di( size );
4194      circular_buffer<string> cbs( size );
4195      circular_buffer<int>     cbi( size );
4196  
4197  }
4198  
4199  
4200  -------------------------------------------------------------------------
4201  
4202  To: boost@lists.boost.org 
4203  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
4204  Date: Fri, 12 Mar 2004 21:06:16 +1100 
4205  Subject:  [boost] [circular buffer review] 
4206  
4207      
4208  Hi All,
4209  
4210  here is my review of the circular buffer class.
4211  
4212  What is your evaluation of the design?
4213  ---------------------------------
4214  
4215  The design is good. People can easily learn to use it.
4216  There are some miner things that I would like see changed, like double
4217  versions of push_back and push_front. I don't
4218  understand why both set_capacit and resize are provided and I would 
4219  like to
4220  see them merged if possible.
4221  
4222  I also think push_back should throw an exception if no element is 
4223  inserted.
4224  This behavior is somewhat different push_back() from a
4225  normal std container. If there are similar cases then I think they 
4226  should be
4227  looked at again too.
4228  
4229  What is your evaluation of the implementation?
4230  -----------------------------------------
4231  I haven't looked closely at the source code.
4232  
4233  
4234  What is your evaluation of the documentation?
4235  ----------------------------------------
4236  very good once the exception-safety issues are solved
4237  
4238  
4239  What is your evaluation of the potential usefulness of the library?
4240  ----------------------------------------------------------
4241  I'm in doubt. The library has efficiency as its hallmark. The  
4242  rationale
4243  says that it
4244  gives efficient FIFO queue. So I tried to compare it with std::deque, 
4245  and
4246  here is my results
4247  of an /O2 build with vc71:
4248  
4249  $ ./cbuffer_vs_deque.exe
4250  
4251   circular_buffer<int>: 2.15 s
4252  
4253  
4254   deque<int>: 2.84 s
4255  
4256  
4257   circular_buffer<string>: 20.59 s
4258  
4259  
4260   deque<string>: 18.64 s
4261  
4262  The test program is attached; I might have made an error, but if I have 
4263  not,
4264  then
4265  I don't see the claim as true. In that case I need to see some more 
4266  evidence
4267  about why
4268  the speed advantages should be so good. It also make me wonder if there 
4269  is
4270  any need for
4271  circular_buffer_space_optimized.
4272  
4273  Did you try to use the library?  With what compiler?  Did you have any
4274  problems?
4275  ----------------------------------------------------------------------
4276  
4277  yes, with vc7.1; Comeau 4.3.0 could not compile it. It worked fine on 
4278  vc7.1
4279  
4280  
4281  How much effort did you put into your evaluation? A glance? A quick 
4282  reading?
4283  In-depth study?
4284  ----------------------------------------------------------------------
4285  -------------
4286  A couple of hours with both documentation and code use.
4287  
4288  
4289  Are you knowledgeable about the problem domain?
4290  -----------------------------------------------
4291  I don't have experience with embedded applications; I have written 
4292  stuff in
4293  which performace
4294  was critical and in which specially designed datastructures was 
4295  necessary.
4296  
4297  
4298  Do you think the library should be accepted as a Boost library?
4299  ---------------------------------------------------------
4300  
4301  Yes if the author can convince me that we really get more performance.
4302  No otherwise.
4303  
4304  best regards
4305  
4306  Thorsten
4307  
4308  
4309  -------------------------------------------------------------------------
4310  
4311  To: boost@lists.boost.org 
4312  From: "Tom Widmer" <tom_usenet@hotmail.com>   
4313  Date: Fri, 12 Mar 2004 16:15:48 +0000 
4314  Subject: [boost] Re: [circular buffer review] 
4315  
4316      
4317  On Fri, 12 Mar 2004 21:06:16 +1100, "Thorsten Ottosen"
4318  <nesotto@cs.auc.dk> wrote:
4319  
4320  >What is your evaluation of the potential usefulness of the library?
4321  >----------------------------------------------------------
4322  >I'm in doubt. The library has efficiency as its hallmark. The  
4323  rationale
4324  >says that it
4325  >gives efficient FIFO queue. So I tried to compare it with std::deque, 
4326  and
4327  >here is my results
4328  >of an /O2 build with vc71:
4329  >
4330  >$ ./cbuffer_vs_deque.exe
4331  >
4332  > circular_buffer<int>: 2.15 s
4333  >
4334  >
4335  > deque<int>: 2.84 s
4336  >
4337  >
4338  > circular_buffer<string>: 20.59 s
4339  >
4340  >
4341  > deque<string>: 18.64 s
4342  >
4343  >The test program is attached; I might have made an error, but if I 
4344  have not,
4345  >then
4346  >I don't see the claim as true. In that case I need to see some more 
4347  evidence
4348  >about why
4349  >the speed advantages should be so good. It also make me wonder if 
4350  there is
4351  >any need for
4352  >circular_buffer_space_optimized.
4353  
4354  Your code does have at least two major errors:
4355  
4356  mutex::scoped_lock lock( mutex );
4357  is a function declaration (demonstrating the danger of C++ and "using
4358  namespace boost"). You meant:
4359  mutex::scoped_lock lock(queue_mutex);
4360  
4361  Also, you have implemented a stack rather than a queue; the reader
4362  should use front() and pop_front(). This didn't make much difference
4363  to the benchmark.
4364  
4365  You should also probably using condition variables rather than
4366  thread::yield - thread::yield is rarely needed in properly written
4367  multithreaded code (although I've been lucky enough to write most of
4368  my threading code in a realtime operating system with deterministic
4369  scheduling).
4370  
4371  But in any case, your benchmark does prove a point - circular_buffer
4372  seems a bit unnecessary if you have a properly implemented std::deque,
4373  as found in Dinkumware's library for one. No ongoing memory allocation
4374  has to happen in std::deque either! This is because it can use a
4375  circular buffer for the map of blocks, and not throw away empty
4376  blocks.
4377  
4378  Tom
4379  
4380  
4381  -------------------------------------------------------------------------
4382  
4383  To: boost@lists.boost.org 
4384  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
4385  Date: Fri, 12 Mar 2004 23:36:28 +0100 
4386  Subject: [boost] Re: Formal Review: Circular Buffer (some notes) 
4387  
4388      
4389  Bellow are few notes to circular_buffer library.
4390  Over weekend I'll reread the code and post remaining notes.
4391  /Pavel
4392  
4393  ____________________________________
4394  1. docs: there should be warning for
4395     data() documentation that the returned
4396     pointer gets very easily invalidated.
4397  ____________________________________
4398  2. docs: Synopsis in circular_buffer.html
4399     could be splitted by <p> into two paragraphs.
4400     It would look less "heavy".
4401  ____________________________________
4402  3. the macros as BOOST_CB_TRY should be at some time
4403  replaced by common Boost macros.
4404  
4405  These macros are proposed but not yet added there AFAIK.
4406  
4407  #if !(defined BOOST_NO_EXCEPTIONS)
4408  #    define BOOST_TRY { try
4409  #    define BOOST_CATCH(x) catch(x)
4410  #    define BOOST_RETHROW throw
4411  #    define BOOST_CATCH_END  }
4412  #else
4413  #    if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
4414  #        define BOOST_TRY { if ("")
4415  #        define BOOST_CATCH(x) else if (!"")
4416  #    else
4417  #        define BOOST_TRY { if (true)
4418  #        define BOOST_CATCH else if (false)
4419  #    endif
4420  #    define BOOST_RETHROW
4421  #    define BOOST_CATCH_END }
4422  #endif
4423  _________________________________________
4424  4. circular_buffer.hpp:
4425  
4426  #include <boost/type_traits.hpp>
4427  should be replaced by finer granularity includes.
4428  This line big huge impact on compilation time.
4429  __________________________________________
4430  5. base.hpp:
4431  
4432  #if BOOST_CB_ENABLE_DEBUG
4433      #include <string.h>
4434  #endif
4435  
4436  maybe this can change to <cstring>.
4437  __________________________________________
4438  6. base.hpp, Intel C++ 7.0, warning on line:
4439  
4440      void replace(pointer pos, param_value_type item) {
4441          replace(pos, item, cb_details::template
4442  cb_replace_category_traits<value_type>::tag()); <<< here
4443  
4444  C:\Temp\temp\circular_buffer3.6\circular_buffer\boost/circular_buffer
4445  /base.h pp(1105): warning #1017: name following "template"
4446  must be a member template
4447  
4448  Dtto assign(), insert(), rinsert(). insert()/rinsert() in adaptor.hpp.
4449  __________________________________________
4450  7. base.hpp: few places contain text "circular_buffer<T, Alloc>".
4451  
4452  Helper type, e.g. self_t can be created and used
4453  there. Its slightly easier to read.
4454  __________________________________________
4455  EOF
4456  
4457  
4458  
4459  -------------------------------------------------------------------------
4460  
4461  To: boost@lists.boost.org 
4462  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
4463  Date: Sat, 13 Mar 2004 12:29:03 +1100 
4464  Subject: [boost] Re: [circular buffer review] 
4465  
4466      
4467  
4468  "Tom Widmer" <tom_usenet@hotmail.com> wrote in message
4469  news:tcl350tm80fqpbma96j3jcsa6i6o3t9dm6@4ax.com...
4470  [snip]
4471  > Your code does have at least two major errors:
4472  >
4473  > mutex::scoped_lock lock( mutex );
4474  > is a function declaration (demonstrating the danger of C++ and "using
4475  > namespace boost"). You meant:
4476  > mutex::scoped_lock lock(queue_mutex);
4477  
4478  Doh! I dont get why this cold compile at all!
4479  
4480  > Also, you have implemented a stack rather than a queue; the reader
4481  > should use front() and pop_front(). This didn't make much difference
4482  > to the benchmark.
4483  
4484  yeah it doesn't.
4485  
4486  > You should also probably using condition variables rather than
4487  > thread::yield - thread::yield is rarely needed in properly written
4488  > multithreaded code (although I've been lucky enough to write most of
4489  > my threading code in a realtime operating system with deterministic
4490  > scheduling).
4491  
4492  Ok, I'm no MT expert, but I haven't seen any examples of how to do 
4493  this.
4494  It would explain why you have to hack so much to call yield :-)
4495  
4496  > But in any case, your benchmark does prove a point - circular_buffer
4497  > seems a bit unnecessary if you have a properly implemented 
4498  std::deque,
4499  > as found in Dinkumware's library for one. No ongoing memory 
4500  allocation
4501  > has to happen in std::deque either! This is because it can use a
4502  > circular buffer for the map of blocks, and not throw away empty
4503  > blocks.
4504  
4505  ok.
4506  
4507  br
4508  
4509  Thorsten
4510  
4511  
4512  
4513  -------------------------------------------------------------------------
4514  
4515  Date: Sat, 13 Mar 2004 07:23:56 -0800 (PST) 
4516  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
4517  Subject: Re: [boost] [circular buffer review] 
4518  To: boost@lists.boost.org 
4519  
4520      
4521  Hi Thorsten!
4522  
4523  --- Thorsten Ottosen <nesotto@cs.auc.dk> wrote:
4524  
4525  > I'm in doubt. The library has efficiency as its
4526  > hallmark. The  rationale
4527  > says that it
4528  > gives efficient FIFO queue. So I tried to compare it
4529  > with std::deque, and
4530  > here is my results
4531  > of an /O2 build with vc71:
4532  > 
4533  > $ ./cbuffer_vs_deque.exe
4534  > 
4535  >  circular_buffer<int>: 2.15 s
4536  > 
4537  > 
4538  >  deque<int>: 2.84 s
4539  > 
4540  > 
4541  >  circular_buffer<string>: 20.59 s
4542  > 
4543  > 
4544  >  deque<string>: 18.64 s
4545  > 
4546  I compiled your test and made some experiments with
4547  it. My results are:
4548  
4549  circular_buffer<int>: 2.84 s
4550  deque<int>: 3.84 s
4551  
4552  circular_buffer<string>: 27.65 s
4553  deque<string>: 25.65 s
4554  
4555  
4556  struct test_struct {
4557  	double d;
4558  };
4559  
4560  circular_buffer<test_struct>: 3.15 s
4561  deque<test_struct>: 4.22 s
4562  
4563  struct test_struct2 {
4564  	double d1;
4565  	double d2;
4566  	double d3;
4567  	double d4;
4568  	double d5;
4569  };
4570  
4571  circular_buffer<test_struct2>: 7.67 s
4572  deque<test_struct2>: 6.47 s
4573  
4574  It seems to me that if you use circular_buffer for
4575  storing "small" elements the circular_buffer is about
4576  30% faster than deque. If you use larger elements the
4577  deque is faster about 10%. (I did also experiments
4578  with buffer size, but the results were about the
4579  same.) I don't have an explanation for such behavour.
4580  (Does anyone have?)
4581  
4582  So, the result is: the circular_buffer is more
4583  effective for storing primitive types.
4584  
4585  
4586  Btw, at the early stages of library developmet I
4587  implemented the circular_buffer as std::deque adaptor.
4588  The problem was that there was no control over
4589  iterator invalidation.
4590  
4591  Best regards,
4592  
4593  Jan
4594  
4595  
4596  
4597  -------------------------------------------------------------------------
4598  
4599  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
4600  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
4601  Subject: Re: circular_buffer: problemy s VC6.5 
4602  Date: Sat, 13 Mar 2004 16:54:30 +0100 
4603  
4604      
4605  > Skompiloval som to v debug mode. Po spusteni v
4606  > debugeri base_test spadol (user exception) v
4607  > <streambuf> headeri este pred tym, ako sa zavolal prvy
4608  > test! Netusim, kde by mohol byt problem.
4609  > 
4610  > Co sa tyka release modu - zeby chybny kompilator?
4611  > 
4612  > Este je zaujimave, ze adaptor_test som skompiloval a
4613  > spustil bez problemov.
4614  > 
4615  
4616  Ja jsem zase zkusil Thorstenuv example (with fixes) 
4617  s Intel C++ 7.0 a zatimco v debug mode vsechno
4618  funguje v Release mode to spadne na access violation :-O
4619  
4620  
4621  Ja nejdriv musim znovu procist cely kod, pak zkusim lokalizovat
4622  ten problem.
4623  
4624  
4625  Jinak za par dni ohlasim ze circular_buffer je prijaty do Boostu.
4626  Myslim ze je to po dlouhe dobe neco co za to stoji. Ten mail ti 
4627  predtim poslu aby jsi to mohl okomentovat.
4628  
4629  
4630  Budes chtit pridavat neco jako adapter ktery vola functor pri
4631  vymazani elementu?
4632  
4633  /Pavel
4634  
4635  -------------------------------------------------------------------------
4636  
4637  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
4638  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
4639  Subject: Re: [circular buffer review] 
4640  Date: Sat, 13 Mar 2004 17:03:47 +0100 
4641  
4642      
4643  
4644  ----- Original Message ----- 
4645  From: "Jan Gaspar" <jano_gaspar@yahoo.com>
4646  Newsgroups: gmane.comp.lib.boost.devel
4647  Sent: Saturday, March 13, 2004 4:23 PM
4648  Subject: Re: [circular buffer review]
4649  
4650  
4651  > Hi Thorsten!
4652  > 
4653  [snip]
4654  >
4655  > It seems to me that if you use circular_buffer for
4656  > storing "small" elements the circular_buffer is about
4657  > 30% faster than deque. If you use larger elements the
4658  > deque is faster about 10%. (I did also experiments
4659  > with buffer size, but the results were about the
4660  > same.) I don't have an explanation for such behavour.
4661  > (Does anyone have?)
4662  > 
4663  > So, the result is: the circular_buffer is more
4664  > effective for storing primitive types.
4665  > 
4666  I was mailing with Thorsten about this bechmark.
4667  
4668  My point is that this test is rather simplistic:
4669   - the data and code fit into CPU cache
4670   - heap is not defragmented
4671  
4672  In real applications the cost of allocations will grow
4673  and cache misses will be more frequent.
4674  
4675  std::deque does more allocations and has worse
4676  cache friendliness.
4677  
4678  This type of benchmark is rather hard to write, though.
4679  
4680  -------
4681  
4682  I guess replacing the construct/destruct feature with copy 
4683  assignement should help a bit here (my request for it was 
4684  mistake).
4685  
4686  /Pavel
4687         
4688  
4689  -------------------------------------------------------------------------
4690  
4691  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
4692  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
4693  Subject: Re: circular_buffer: problemy s VC6.5 
4694  Date: Sat, 13 Mar 2004 18:05:16 +0100 
4695  
4696      
4697  > > Budes chtit pridavat neco jako adapter ktery vola
4698  > > functor pri
4699  > > vymazani elementu?
4700  >
4701  > Myslim, ze ano, aj ked este nemam uplne presnu
4702  > predstavu.
4703  >
4704  Trochu jsem o tom premyslel:
4705  
4706  1. mohlo by to byt neco jako:
4707  
4708  notify_on_element_dropped<circular_buffer<int> >;
4709  notify_on_element_dropped<circular_buffer_space_optimized<int> >;
4710  
4711  ----
4712  
4713  
4714  notify_on_element_dropped<circular_buffer<int> > a;
4715  
4716  int handler_id = a.add_handler(... functor ...)
4717  a.add_notification_handler(... functor2 ...)
4718  a.remove_notification_handler(handler_id);
4719  a.remove_all_notification_handlers();
4720  
4721  Asi proto musi byt dve specializace: constructory
4722  circular_buffer a circular_buffer_space_optimized nejsou
4723  kompatibilni.
4724  
4725  2. mozna lze udelat adapter tak aby akceptoval vice druhu functoru a 
4726  vice
4727  nez jeden:
4728  
4729  boost::function(void (void)) functor1;
4730  boost::function(void (const T&)) functor2;
4731  boost::function(void (const circular_buffer<int>&, const T&)) functor3;
4732  
4733  a.add_notification_handler(functor1);
4734  a.add_notification_handler(functor2);
4735  a.add_notification_handler(functor3);
4736  
4737  a.push_back(999); // all three functors will get called.
4738  
4739  To by asi vyzadovalo Boost.Signal (hadam, nepouzival jsem to).
4740  
4741  /Pavel
4742  
4743  
4744  -------------------------------------------------------------------------
4745  
4746  To: boost@lists.boost.org 
4747  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
4748  Date: Sun, 14 Mar 2004 08:49:06 +1100 
4749  Subject:  [boost] Re: [circular buffer review] 
4750  
4751      
4752  Hi Jan,
4753  
4754  The attached file corrects the mutex and fifo error in the first.
4755  
4756  > It seems to me that if you use circular_buffer for
4757  > storing "small" elements the circular_buffer is about
4758  > 30% faster than deque. If you use larger elements the
4759  > deque is faster about 10%.
4760  
4761  > So, the result is: the circular_buffer is more
4762  > effective for storing primitive types.
4763  
4764  Could it be that your special treatment of small types makes this
4765  difference?
4766  
4767  I guess a deque cannot guarantee sequential data. Or could it with a 
4768  special
4769  allocator?
4770  
4771  br
4772  
4773  Thorsten
4774  
4775  
4776  -------------------------------------------------------------------------
4777  
4778  Date: Sun, 14 Mar 2004 01:03:43 -0800 (PST) 
4779  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
4780  Subject: Re: [boost] Re: [circular buffer review] 
4781  To: boost@lists.boost.org 
4782  
4783      
4784  Hi Thorsten!
4785  
4786  > Could it be that your special treatment of small
4787  > types makes this
4788  > difference?
4789  The test_struct is not a primitive type and for this
4790  type the optimization does not apply.
4791  
4792  > 
4793  > I guess a deque cannot guarantee sequential data. Or
4794  > could it with a special
4795  > allocator?
4796  I don't understand this question.
4797  
4798  Jan
4799  
4800  
4801  -------------------------------------------------------------------------
4802  
4803  To: boost@lists.boost.org 
4804  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
4805  Date: Sun, 14 Mar 2004 21:02:32 +1100 
4806  Subject: [boost] Re: Re: [circular buffer review] 
4807  
4808      
4809  Hi Jan,
4810  
4811  > >
4812  > > I guess a deque cannot guarantee sequential data. Or
4813  > > could it with a special
4814  > > allocator?
4815  > I don't understand this question.
4816  
4817  I mean a vector and a circular_buffer can pass a pointer to their data 
4818  to
4819  C-style functions.
4820  A deque cannot because it's data is not guaranteed to be sequential. 
4821  The
4822  question is if
4823  a deque could provide this guarantee somehow using eg. a special 
4824  allocator.
4825  
4826  br
4827  
4828  Thorsten
4829  
4830  
4831  
4832  -------------------------------------------------------------------------
4833  
4834  To: boost@lists.boost.org 
4835  From: "Joe Gottman" <jgottman@carolina.rr.com>   
4836  Date: Sun, 14 Mar 2004 09:15:12 -0500 
4837  Subject: [boost] Re: Re: [circular buffer review] 
4838  
4839      
4840  
4841  "Thorsten Ottosen" <nesotto@cs.auc.dk> wrote in message
4842  news:c31al8$bk8$1@sea.gmane.org...
4843  > Hi Jan,
4844  >
4845  > > >
4846  > > > I guess a deque cannot guarantee sequential data. Or
4847  > > > could it with a special
4848  > > > allocator?
4849  > > I don't understand this question.
4850  >
4851  > I mean a vector and a circular_buffer can pass a pointer to their 
4852  data to
4853  > C-style functions.
4854  > A deque cannot because it's data is not guaranteed to be sequential. 
4855  The
4856  > question is if
4857  > a deque could provide this guarantee somehow using eg. a special
4858  allocator.
4859  
4860     A deque can't.  From the way it is specified, it more-or-less has to 
4861  be
4862  implemented as several fixed-size buffers, plus a control structure to 
4863  tell
4864  which buffer is being used when. A circular_buffer really can't be 
4865  passed to
4866  a C-style function either.  What if the data starts in the middle and 
4867  wraps
4868  around the end?
4869  
4870  Joe Gottman
4871  
4872  
4873  -------------------------------------------------------------------------
4874  
4875  To: boost@lists.boost.org 
4876  From: "Thorsten Ottosen" <nesotto@cs.auc.dk>   
4877  Date: Mon, 15 Mar 2004 02:38:42 +1100 
4878  Subject: [boost] Re: Re: [circular buffer review] 
4879  
4880      
4881  > > > > I guess a deque cannot guarantee sequential data. Or
4882  > > > > could it with a special
4883  > > > > allocator?
4884  > > > I don't understand this question.
4885  > >
4886  > > I mean a vector and a circular_buffer can pass a pointer to their 
4887  data
4888  to
4889  > > C-style functions.
4890  > > A deque cannot because it's data is not guaranteed to be 
4891  sequential. The
4892  > > question is if
4893  > > a deque could provide this guarantee somehow using eg. a special
4894  > allocator.
4895  >
4896  >    A deque can't.  From the way it is specified, it more-or-less has 
4897  to be
4898  > implemented as several fixed-size buffers, plus a control structure 
4899  to
4900  tell
4901  > which buffer is being used when.
4902  
4903  then what about one big fixed-sized buffer? Can't the allocator 
4904  determine
4905  the buffer size?
4906  
4907  >A circular_buffer really can't be passed to
4908  > a C-style function either.  What if the data starts in the middle and
4909  wraps
4910  > around the end?
4911  
4912  You would have to call data(), right?
4913  
4914  br
4915  
4916  Thorsten
4917  
4918  
4919  -------------------------------------------------------------------------
4920  
4921  Date: Sun, 14 Mar 2004 13:26:51 -0800 (PST) 
4922  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
4923  Subject: Re: [boost] Re: Re: [circular buffer review] 
4924  To: boost@lists.boost.org 
4925  
4926      
4927  
4928  --- Thorsten Ottosen <nesotto@cs.auc.dk> wrote:
4929  > > > > > I guess a deque cannot guarantee sequential
4930  > data. Or
4931  > > > > > could it with a special
4932  > > > > > allocator?
4933  > > > > I don't understand this question.
4934  > > >
4935  > > > I mean a vector and a circular_buffer can pass a
4936  > pointer to their data
4937  > to
4938  > > > C-style functions.
4939  > > > A deque cannot because it's data is not
4940  > guaranteed to be sequential. The
4941  > > > question is if
4942  > > > a deque could provide this guarantee somehow
4943  > using eg. a special
4944  > > allocator.
4945  > >
4946  > >    A deque can't.  From the way it is specified,
4947  > it more-or-less has to be
4948  > > implemented as several fixed-size buffers, plus a
4949  > control structure to
4950  > tell
4951  > > which buffer is being used when.
4952  > 
4953  > then what about one big fixed-sized buffer? Can't
4954  > the allocator determine
4955  > the buffer size?
4956  > 
4957  > >A circular_buffer really can't be passed to
4958  > > a C-style function either.  What if the data
4959  > starts in the middle and
4960  > wraps
4961  > > around the end?
4962  > 
4963  > You would have to call data(), right?
4964  > 
4965  Yes you're right.
4966  
4967  I just want to mention one more problem with deque.
4968  With deque as underlying container of the
4969  circular_buffer, you have no or very limited control
4970  over iterator invalidation.
4971  
4972  
4973  Best regards,
4974  
4975  Jan
4976  
4977  
4978  -------------------------------------------------------------------------
4979  
4980  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
4981  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
4982  Subject: review result 
4983  Date: Fri, 19 Mar 2004 23:46:17 +0100 
4984  
4985      
4986  Ahoj Jano,
4987  Napsal jsem koncept review result. Napis mi prosim 
4988  pripominky/zmeny/jiny
4989  text.
4990  
4991  -------------------------
4992  The circular_buffer library by Jan Gaspar has
4993  been accepted into Boost.
4994  
4995  
4996  The reviews were helpful in finding at least one
4997  issue with the library and few ones with its
4998  documentation. Thanks to all reviewers for the time
4999  and effort!
5000  
5001  
5002  Main points to be addressed:
5003   - issue of copy construction versus construct/destruct
5004     has been cleared (the problem was created by me)
5005   - documentation should list exception safety for every
5006     function
5007   - documentation may add some rationale on its internal
5008     data structures and their advantage over std::deque
5009   - portability problems should be solved
5010   - adaptor with notification when oldest element gets
5011     pushed out of bufer may be added
5012  
5013  
5014  Other points that may be considered:
5015   - name of data() function
5016   - existence of push_back(void) like functions
5017   - using new iterator adaptors
5018   - difference between resize/set_capacity may be
5019     more emphasized in docs,
5020   - other fixes/improvements suggested during review.
5021  
5022  
5023  Thanks for professional quality library, Jano.
5024  
5025  /Pavel
5026  ----------------------------------
5027  
5028  Mozna by bylo nejlepsi postnout jeste verzi 3.7, ja bych ji vyzkousel
5029  na tom co mam k dispozici
5030  
5031  
5032  S CVS nemam zkusenosti - myslim ze je potreba account na SourceForge
5033  a pak asi mail Bemanovi Dawesovi. Nekdy ted ma byt C++ standard comitee
5034  konference takze veci asi pujdou pomaleji.
5035  
5036  
5037  ----------------------------------
5038  K predchozimu emailu:
5039  
5040  [notification handler]
5041  > Ja som rozmyslal troch inak:
5042  >
5043  > // An example of the overwrite functor.
5044  > // There can be also construct/destruct functor
5045  > // and one with some notify code.
5046  >
5047  > template <class T> class AssignFnc :
5048  > std::binary_function<T*, T, void> {
5049  > void operator () (T* dest, const T& item) const {
5050  >  *dest = item;
5051  >  // notifying code can be added here
5052  >  }
5053  > };
5054  >
5055  > // then the buffer will look like this:
5056  > template <class T, class Alloc = Alloc(), class
5057  > OverwriteFnc = AssignFnc<T>>
5058  > class circular_buffer {
5059  > // ...
5060  > OverwriteFnc m_overwrite;
5061  >
5062  > // called whenever an item is about to be overwritten
5063  > void overwrite(T* dest, T& item) const {
5064  > m_overwrite(dest, item);
5065  > }
5066  >
5067  Mozna ze nova hodnota T neni ani tak zajimava,
5068  tu koneckoncu uzivatel zna.
5069  
5070  Ja bych preferroval tyto signatures:
5071  1. void operator()(void);
5072  2. void operator()(T& being_pushed_out);
5073  3. void operator()(const circular_buffer<T>&);
5074  4 void operator()(const circular_buffer<T>&, T& being_pushed_out);
5075  
5076  a to v jakkemkoliv mnoztvi a kombinacich (ale nevim jestli to je
5077  mozne - mozna pomoci Boost.Function).
5078  
5079  
5080  > Now, the question is what the overwrite operation
5081  > means and when it is called. IMHO the overwrite
5082  > operation is either construction/destruction or
5083  > assignment depending on the functor. I think the
5084  > operation should be called whenever a new item
5085  > replaces the old one (e.g. pushing back an item into a
5086  > full circular_buffer). In contrast when you insert an
5087  > item in the middle of a non-full circular_buffer, the
5088  > items behind the insertion point have to be shifted in
5089  > order to make space for the new inserted item. I think
5090  > the "shift" operation is not an overwrite operation
5091  > and it has to be always an assignment.
5092  >
5093  Ja abych rekl pokazde kdyz je element 'zrusen' kvuli dosazeni kapacity,
5094  at uz je to na kterekoliv strane. A to i vcetne:
5095  
5096  circular_buffer<int> buff(1);
5097  int array[] = { 1, 2, 3 };
5098  buff.insert(array, array + 3);
5099  
5100  notification by mel byt volan 2x.
5101  
5102  Dtto pro set_capacity() ktera zmensi buffer.
5103  
5104  Pro resize - nevim.
5105  
5106  /Pavel
5107  
5108  
5109  -------------------------------------------------------------------------
5110  
5111  Date: Sat, 20 Mar 2004 22:58:47 -0800 (PST) 
5112  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
5113  Subject: Re: review result 
5114  To: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com> 
5115  
5116      
5117  Nazdar Pavel!
5118  
5119  --- Pavel Vozenilek <pavel_vozenilek@hotmail.com>
5120  wrote:
5121  > 
5122  > Other points that may be considered:
5123  >  - name of data() function
5124  >  - existence of push_back(void) like functions
5125  >  - using new iterator adaptors
5126  Nespominam si na iterator adaptory, pamatam si len na
5127  container adaptory. Nemozem to ani najst v mailing
5128  list-e.
5129  > 
5130  > 
5131  > Thanks for professional quality library, Jano.
5132  > 
5133  Myslim, ze mas na tom zasluhu aj ty.
5134  > 
5135  > Mozna by bylo nejlepsi postnout jeste verzi 3.7, ja
5136  > bych ji vyzkousel
5137  > na tom co mam k dispozici
5138  > 
5139  Urcite tak urobim. Budem sa snazit doplnit/zmenit
5140  veci, ktore boli spomennute v review.
5141  > 
5142  > 
5143  > ----------------------------------
5144  > K predchozimu emailu:
5145  > 
5146  > >
5147  > Mozna ze nova hodnota T neni ani tak zajimava,
5148  > tu koneckoncu uzivatel zna.
5149  > 
5150  > Ja bych preferroval tyto signatures:
5151  > 1. void operator()(void);
5152  > 2. void operator()(T& being_pushed_out);
5153  > 3. void operator()(const circular_buffer<T>&);
5154  > 4 void operator()(const circular_buffer<T>&, T&
5155  > being_pushed_out);
5156  > 
5157  > a to v jakkemkoliv mnoztvi a kombinacich (ale nevim
5158  > jestli to je
5159  > mozne - mozna pomoci Boost.Function).
5160  >
5161  Nerozumiem tomu. Podla mna je operator:
5162  void operator () (T* dest, const T& item) const
5163  postacujuci. Bude robit bud construc/destruct alebo
5164  assign operaciu (podla toho, aky functor sa pouzije).
5165   
5166  
5167  > >
5168  > Ja abych rekl pokazde kdyz je element 'zrusen' kvuli
5169  > dosazeni kapacity,
5170  > at uz je to na kterekoliv strane. A to i vcetne:
5171  > 
5172  > circular_buffer<int> buff(1);
5173  > int array[] = { 1, 2, 3 };
5174  > buff.insert(array, array + 3);
5175  > 
5176  > notification by mel byt volan 2x.
5177  Myslim, ze mas pravdu. Trocha sa to vsak tym
5178  komplikuje, pretoze to znizi efektivnbost buffera.
5179  Myslim, ze pre notifikaciu budem musiet zvolit
5180  container adaptor pristup (a odelit to od overwrite
5181  functora).
5182  
5183  > 
5184  > Dtto pro set_capacity() ktera zmensi buffer.
5185  > 
5186  > Pro resize - nevim.
5187  Ano, aj pre resize, ak nova size bude mensia.
5188  
5189  Vdaka za skvelu spolupracu, Pavel!
5190  
5191  Jano
5192  
5193  
5194  -------------------------------------------------------------------------
5195  
5196  Ahoj Jano,
5197  
5198  > >  - using new iterator adaptors
5199  > Nespominam si na iterator adaptory, pamatam si len na
5200  > container adaptory. Nemozem to ani najst v mailing
5201  > list-e.
5202  > > 
5203  Alberto Barbati postnul na boost-files 
5204  circular_buffer_new_iterators.zip (attached).
5205  
5206  Jeho mail je taky attached.
5207  
5208  
5209  > > ----------------------------------
5210  > > K predchozimu emailu:
5211  > > 
5212  > > >
5213  > > Mozna ze nova hodnota T neni ani tak zajimava,
5214  > > tu koneckoncu uzivatel zna.
5215  > > 
5216  > > Ja bych preferroval tyto signatures:
5217  > > 1. void operator()(void);
5218  > > 2. void operator()(T& being_pushed_out);
5219  > > 3. void operator()(const circular_buffer<T>&);
5220  > > 4 void operator()(const circular_buffer<T>&, T&
5221  > > being_pushed_out);
5222  > > 
5223  > > a to v jakkemkoliv mnoztvi a kombinacich (ale nevim
5224  > > jestli to je
5225  > > mozne - mozna pomoci Boost.Function).
5226  > >
5227  > Nerozumiem tomu. Podla mna je operator:
5228  > void operator () (T* dest, const T& item) const
5229  > postacujuci. Bude robit bud construc/destruct alebo
5230  > assign operaciu (podla toho, aky functor sa pouzije).
5231  > 
5232  >
5233  Myslim ze tady je nejake nedorozumeni - podle mne 
5234  operator() nema delat assign nebo destruct/construct
5235  ale jenom informovat  ze hodnota je 'vytlacena' ven z bufferu.
5236  
5237  Tzn. ten operator by se volal jen nekdy, ne pri kazdem push_back().
5238  
5239  A uzivatel muze chit bude starou, prave rusenou hodnotu,
5240  nebo mu staci instance circular_buffer nebo ani nemusi
5241  chtit zadne detaily.
5242  
5243  
5244  /Pavel
5245  
5246  
5247  
5248    Attachment     
5249   
5250   
5251   
5252   
5253  circular_buffer_new_iterators.zip
5254  .zip file
5255  
5256   
5257  From: "Alberto Barbati" <abarbati@iaanus.com>
5258  Subject: Re: Formal Review: Circular Buffer
5259  Date: Monday, March 08, 2004 1:03 PM
5260  
5261  Pavel Vozenilek wrote:
5262  
5263  > Discovered problems in code or in documentation,
5264  > missing features, portability issues
5265  > and finally opinion whether the library belongs
5266  > to Boost is welcomed.
5267  
5268  I believe this library is very useful and generally well-written. I 
5269  found a few minor problems that I deem workable. My opinion is that the 
5270  library should be accepted. The only things I would like to be 
5271  discussed 
5272  thouroughly are the "ctor/dtor vs. assignment" dispute (see specific 
5273  thread) and the possibility to provide extension points that allows a 
5274  (possibly future) implementation of a "notifying" container (ibid.).
5275  
5276  About portability issues, these lines of code (file details.hpp, lines 
5277  274-277) invoke undefined behaviour, according to 5.7/5:
5278  
5279       if (less(rhs, lhs) && lhs.m_it <= rhs.m_it)
5280           return lhs.m_it + m_buff->capacity() - rhs.m_it;
5281       if (less(lhs, rhs) && lhs.m_it >= rhs.m_it)
5282           return lhs.m_it - m_buff->capacity() - rhs.m_it;
5283  
5284  that's because the expressions (lhs.m_it + m_buff->capacity()) and 
5285  (lhs.m_it - m_buff->capacity()) might produce a pointer outside the 
5286  allocated range. I suggest to replace those lines with:
5287  
5288       if (less(rhs, lhs) && lhs.m_it <= rhs.m_it)
5289           return lhs.m_it - rhs.m_it + m_buff->capacity();
5290       if (less(lhs, rhs) && lhs.m_it >= rhs.m_it)
5291           return lhs.m_it - rhs.m_it - m_buff->capacity();
5292  
5293  or, even better, to avoid complaints from nasty compilers about mixed 
5294  signed/unsigned usage:
5295  
5296       if (less(rhs, lhs) && lhs.m_it <= rhs.m_it)
5297           return (lhs.m_it - rhs.m_it) +
5298               static_cast<difference_type>(m_buff->capacity());
5299       if (less(lhs, rhs) && lhs.m_it >= rhs.m_it)
5300           return (lhs.m_it - rhs.m_it) -
5301               static_cast<difference_type>(m_buff->capacity());
5302  
5303  To be extra paranoid, we should ensure that the static_cast doesn't 
5304  overflow. This could be done by changing the defintion of max_size() in 
5305  base.hpp from:
5306  
5307       size_type max_size() const { return m_alloc.max_size(); }
5308  
5309  to
5310  
5311       size_type max_size() const {
5312           return std::min<size_type>(m_alloc.max_size(),
5313               (std::numeric_limits<difference_type>::max)()); }
5314  
5315  I've seen this issue overlooked even in commercial standard library 
5316  implementations. As c.end() - c.begin() == c.size() and c.end() - 
5317  c.begin() must be representable as a positive quantity of type 
5318  difference_type, this imply that c.size() <= c.max_size() <= 
5319  numeric_limits<difference_type>::max().
5320  
5321  On a side note, I think it should be good if the implementation of the 
5322  iterator classes used the new Boost Iterators Library. I have uploaded 
5323  in the Boost file area an implementation using boost::iterator_facade 
5324  (filename is circular_buffer_new_iterators.zip). The implementation 
5325  already include the fix above and also has a slightly more optimized 
5326  version of the less() method, with fewer tests and without switches.
5327  Problem is that there is something wrong with the implementation of 
5328  operator[] in iterator_facade and the regression test does not compile 
5329  anymore :-( However, if I hack iterator_facade::operator[] to avoid the 
5330  use of the operator_brackets_proxy class, all regression tests pass. 
5331  Maybe it would be good to discuss this problem of the iterator_facade 
5332  in 
5333  a different thread.
5334  
5335  Alberto Barbati
5336  
5337  
5338  -------------------------------------------------------------------------
5339  
5340  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
5341  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
5342  Subject: Re: review result 
5343  Date: Sun, 21 Mar 2004 22:36:56 +0100 
5344  
5345      
5346  Ahoj Jano,
5347  
5348  > Mojou myslienkou bolo skombinovat assignment a
5349  > notifikaciu do jedneho functora. Teraz si vsak myslim,
5350  > ze functor by mal robit iba assignment. Bude to
5351  > vlastne nieco ako policy, ktora urci, ci sa vykonat
5352  > assignment alebo construct/destruct.
5353  > 
5354  Mozna by se mel pouzit jen assignement a nic jineho.
5355  
5356  Ja jsem kdysi zil v presvedceni ze se v circular_bufferu
5357  ztrati efekty ktere se deji v destruktoru a ono to tak neni.
5358  
5359  /Pavel
5360  
5361  
5362  -------------------------------------------------------------------------
5363  
5364  To: boost@lists.boost.org 
5365  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
5366  Date: Tue, 23 Mar 2004 18:18:10 +0100 
5367  Subject: [boost] Review Result: Circular Buffer 
5368  
5369      
5370  The circular_buffer library by Jan Gaspar has
5371  been accepted into Boost.
5372  
5373  
5374  The reviews were helpful in finding at least one
5375  issue with the library and few ones with its
5376  documentation. Thanks to all reviewers for the time
5377  and effort!
5378  
5379  Post-review version 3.7 will be released before code
5380  gets into main CVS.
5381  
5382  
5383  Main points to be addressed:
5384   - issue of copy construction versus construct/destruct
5385     has been cleared (the problem was created by me)
5386   - documentation should list exception safety for every
5387     function
5388   - documentation may add some rationale on its internal
5389     data structures and their advantage over std::deque
5390   - portability problems should be solved
5391   - adaptor with notification when oldest element gets
5392     pushed out of bufer may be added
5393  
5394  
5395  Other points that may be considered:
5396   - name of data() function
5397   - existence of push_back(void) like functions
5398   - using new iterator adaptors
5399   - difference between resize/set_capacity may be
5400     more emphasized in docs,
5401   - other fixes/improvements suggested during review.
5402  
5403  
5404  Thanks for professional quality work, Jano.
5405  
5406  /Pavel
5407  
5408  
5409  
5410  
5411  
5412  -------------------------------------------------------------------------
5413  
5414  To: boost@lists.boost.org 
5415  From: "Neal D. Becker" <ndbecker2@verizon.net>   
5416  Date: Mon, 12 Apr 2004 11:22:36 -0400 
5417  Subject: [boost] circular_buffer question 
5418  
5419      
5420  I'm looking at circular_buffer.  It appears to me that operator[] uses
5421  "add", and that "add" only allows a positive value of offset?  It is 
5422  not
5423  difficult to allow arbitrary values, and this is very useful.  
5424  
5425  if "position" is the current "m_first" and "allocated" is the allocated
5426  buffer size, the index could be calculated:
5427  
5428    int index (int offset) const {
5429      int x = (offset + position) % int(allocated);
5430      if (x >= 0)
5431        return x;
5432      else
5433        return x + allocated;
5434    }
5435   
5436  
5437  
5438  -------------------------------------------------------------------------
5439  
5440  Date: Mon, 12 Apr 2004 23:40:03 -0700 (PDT) 
5441  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
5442  Subject: Re: [boost] circular_buffer question 
5443  To: boost@lists.boost.org 
5444  
5445      
5446  Hi Neal!
5447  
5448  I didn't considered this feature important. Moreover
5449  it would complicate the iterator. Currently these
5450  expressions are invalid:
5451  circular_buffer<int> cb(10);
5452  cb.push_back(1);
5453  // ...
5454  circular_buffer<int>::iterator it1 = cb.end() + 1; //
5455  invalid
5456  circular_buffer<int>::iterator it2 = cb.begin() - 1;
5457  // invalid (see Caveats section in docs)
5458  
5459  I think if I allowed negative indexes or indexes "out
5460  of range" I had to change the iterator, too.
5461  
5462  On the other hand it is not difficult to create an
5463  adaptor and someone can make one if he needs such
5464  feature.
5465  
5466  Best regards,
5467  
5468  Jan
5469  
5470  --- "Neal D. Becker" <ndbecker2@verizon.net> wrote:
5471  > I'm looking at circular_buffer.  It appears to me
5472  > that operator[] uses
5473  > "add", and that "add" only allows a positive value
5474  > of offset?  It is not
5475  > difficult to allow arbitrary values, and this is
5476  > very useful.  
5477  > 
5478  > if "position" is the current "m_first" and
5479  > "allocated" is the allocated
5480  > buffer size, the index could be calculated:
5481  > 
5482  >   int index (int offset) const {
5483  >     int x = (offset + position) % int(allocated);
5484  >     if (x >= 0)
5485  >       return x;
5486  >     else
5487  >       return x + allocated;
5488  >   }
5489  >  
5490  > 
5491  
5492  
5493  -------------------------------------------------------------------------
5494  
5495  To: boost@lists.boost.org 
5496  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
5497  Date: Tue, 13 Apr 2004 12:23:14 +0200 
5498  Subject: [boost] Re: circular_buffer question 
5499  
5500      
5501  
5502  "Jan Gaspar" <jano_gaspar@yahoo.com> wrote
5503  
5504  (snip using negative values for index in operator[] )
5505  
5506  There are few different cases:
5507  
5508  1. operator[] for circular_buffer iterator:
5509  
5510     circular_buffer<int> b(10);
5511     ... fill buffer
5512     circular_buffer<int>::iterator it = b.begin() + 5;
5513     int x = it[-1]; // should return value b[4]
5514  
5515  I think here negative values should be allowed here
5516  (provided they result in valid offset).
5517  
5518  
5519  2. operator[] for circular_buffer itself:
5520  
5521     circular_buffer<int> b(10);
5522     b.push_back(10);
5523     b.push_back(20);
5524     b.push_back(33);
5525     int x = b[-1];  // this would return value 30, the last one
5526     x = b[-2]; // would return 20
5527  
5528  This would be new feature, not available in current
5529  standard ontainers. I remember some language
5530  (forgot name) provides it.
5531  
5532  I personally would like to have this feature
5533  and have it in std::vector/deque too.
5534  
5535  
5536  Alternatively one can think about syntax as:
5537  int x = b[boost::end - 1];
5538  to indicate intent and catch possible bugs.
5539  
5540  (boost::end would be tag type and operator[]
5541  would be overloaded.)
5542  
5543  
5544  3. incrementing/decrementing circular_buffer
5545      iterator with automatic wrap-around:
5546  
5547      I think this (wrap-around) should not be
5548      allowed:
5549      - it could hide errors
5550      - it suggests circular-linked-list semantics
5551        (and one can then ask for rotate())
5552  
5553  /Pavel
5554  
5555  
5556  -------------------------------------------------------------------------
5557  
5558  
5559  Date: Tue, 13 Apr 2004 05:18:28 -0700 (PDT) 
5560  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
5561  Subject: Re: [boost] Re: circular_buffer question 
5562  To: boost@lists.boost.org 
5563  
5564      
5565  Hi Pavel!
5566  
5567  > 
5568  > 2. operator[] for circular_buffer itself:
5569  > 
5570  >    circular_buffer<int> b(10);
5571  >    b.push_back(10);
5572  >    b.push_back(20);
5573  >    b.push_back(33);
5574  >    int x = b[-1];  // this would return value 30,
5575  > the last one
5576  >    x = b[-2]; // would return 20
5577  > 
5578  > This would be new feature, not available in current
5579  > standard ontainers. I remember some language
5580  > (forgot name) provides it.
5581  > 
5582  > I personally would like to have this feature
5583  > and have it in std::vector/deque too.
5584  > 
5585  I think this can be solved (for any container) by some
5586  kind of adaptor:
5587  
5588  template <class Container> ring {
5589  public:
5590  
5591   // constructor
5592   ring(const Container& c);
5593  
5594   // element access
5595   Container::value_type& operator[] (int index) const;
5596  };
5597  
5598   
5599  > 
5600  > 3. incrementing/decrementing circular_buffer
5601  >     iterator with automatic wrap-around:
5602  > 
5603  >     I think this (wrap-around) should not be
5604  >     allowed:
5605  >     - it could hide errors
5606  >     - it suggests circular-linked-list semantics
5607  >       (and one can then ask for rotate())
5608  > 
5609  
5610  There is a cycle_iterator (yet another
5611  iterator_adaptor application) in the yahoo files
5612  section which can solve this problem.
5613  
5614  Jan
5615  
5616  
5617  
5618  -------------------------------------------------------------------------
5619  
5620  From: "Jeff Garland" <jeff@crystalclearsoftware.com>   
5621  To: "boost" <boost@lists.boost.org> 
5622  Date: Fri, 23 Apr 2004 19:50:39 -0700 
5623  Subject: [boost] [circular buffer] Status of Circular Buffer lib 
5624  
5625      
5626  I'm looking at using circular buffer on a project.  With only minor 
5627  adaptation
5628  it does exactly what I need.  I know it has been accepted, but isn't 
5629  yet in
5630  CVS. So I have a few questions:
5631  
5632  1) Is 3.6 from the files section the latest version?
5633  2) Any showstopper bugs I should be aware of?
5634  3) I'm assuming it works with VC7.1 and gcc 3.x?
5635  4) Looks like my interface needs will be pretty basic: push_back, 
5636  erase,
5637  clear.  I assuming review changes won't impact these, correct?
5638  5) Any reason it is NOT ready for prime time?
5639  
5640  Thx for the great submission!
5641  
5642  Jeff
5643  
5644  
5645  -------------------------------------------------------------------------
5646  
5647  Date: Fri, 23 Apr 2004 23:07:58 -0700 (PDT) 
5648  From: "Jan Gaspar" <jano_gaspar@yahoo.com>   
5649  Subject: Re: [boost] [circular buffer] Status of Circular Buffer lib 
5650  To: boost@lists.boost.org 
5651  
5652      
5653  Hi Jeff!
5654  
5655  --- Jeff Garland <jeff@crystalclearsoftware.com>
5656  wrote:
5657  > I'm looking at using circular buffer on a project. 
5658  > With only minor adaptation
5659  > it does exactly what I need.  I know it has been
5660  > accepted, but isn't yet in
5661  > CVS. So I have a few questions:
5662  > 
5663  > 1) Is 3.6 from the files section the latest version?
5664  Yes, it is the latest version. I'm working on the
5665  postreview one, but I have just little time for it
5666  now. I hope I won't miss the next 1.32 release of the
5667  boost libs.
5668  > 2) Any showstopper bugs I should be aware of?
5669  No, go ahead.
5670  > 3) I'm assuming it works with VC7.1 and gcc 3.x?
5671  Yes, but there were some minor problems I think with
5672  gcc 3.4. If it will not work with your version of gcc
5673  look at the discussion regarding formal review of
5674  circular_buffer where you will find how to fix it.
5675  > 4) Looks like my interface needs will be pretty
5676  > basic: push_back, erase,
5677  > clear.  I assuming review changes won't impact
5678  > these, correct?
5679  Your assumptions are right, no changes.
5680  > 5) Any reason it is NOT ready for prime time?
5681  See answer for 1).
5682  > 
5683  > Thx for the great submission!
5684  > 
5685  > Jeff
5686  >
5687  Best regards
5688  
5689  Jan
5690  
5691  
5692  -------------------------------------------------------------------------
5693  
5694  From: "Jeff Garland" <jeff@crystalclearsoftware.com>   
5695  To: boost@lists.boost.org 
5696  Subject: Re: [boost] [circular buffer] Status of Circular Buffer lib 
5697  Date: Sat, 24 Apr 2004 05:54:49 -0700 
5698  
5699      
5700  On Fri, 23 Apr 2004 23:07:58 -0700 (PDT), Jan Gaspar wrote
5701  > > 3) I'm assuming it works with VC7.1 and gcc 3.x?
5702  > Yes, but there were some minor problems I think with
5703  > gcc 3.4. If it will not work with your version of gcc
5704  > look at the discussion regarding formal review of
5705  > circular_buffer where you will find how to fix it.
5706  
5707  Ok, thanks. No gcc 3.4, just a couple different 3.3 versions and maybe 
5708  a 3.2.
5709  
5710  Thanks again!
5711  
5712  Jeff
5713  
5714  -------------------------------------------------------------------------
5715  
5716  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
5717  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
5718  Subject:  BOOST_TRY macros 
5719  Date: Thu, 6 May 2004 20:22:40 +0200 
5720  
5721      
5722  Ahoj Jano,
5723  
5724  V Boostu budou ted k dispozici makra 
5725  BOOST_TRY/BOOST_CATCH/BOOST_RETHROW.
5726  
5727  Joaqun MS Lpez Munoz je jako soucast multi_index container library da 
5728  do
5729  boost/detail adresare.
5730  
5731  Serialization library je take nejspis bude pouzivat. Bylo by pekne 
5732  kdyby
5733  mohly byt pouzit i v circular_buffer library.
5734  
5735  
5736  /Pavel
5737  
5738  
5739  
5740    Attachment     
5741   
5742   
5743   
5744   
5745  no_exceptions_support.hpp
5746  .hpp file
5747  
5748  
5749  
5750  -------------------------------------------------------------------------
5751  
5752  From: "Pavel Vozenilek" <pavel_vozenilek@hotmail.com>   
5753  To: "Jan Gaspar" <jano_gaspar@yahoo.com> 
5754  Subject: [circular_buffer] fix for BCB 6.4 
5755  Date: Sun, 8 Aug 2004 20:51:08 +0200 
5756  
5757      
5758  Ahoj Jano,
5759  
5760  Jeden maly fix pro 3.6.
5761  /Pavel
5762  
5763  ___________________________________________________________________
5764  1. adaptor.hpp:
5765  
5766  #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
5767      reference operator [] (size_type n) { return circular_buffer<T,
5768  Alloc>::operator[](n); }
5769      returned_value_type operator [] (size_type n) const { return
5770  circular_buffer<T, Alloc>::operator[](n); }
5771  #else
5772      using circular_buffer<T, Alloc>::operator[];
5773  #endif
5774  
5775  
5776  ==>>
5777  
5778  
5779  #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
5780      reference operator [] (size_type n) { return circular_buffer<T,
5781  Alloc>::operator[](n); }
5782      value_type operator [] (size_type n) const { return 
5783  circular_buffer<T,
5784  Alloc>::operator[](n); }
5785  #else
5786      using circular_buffer<T, Alloc>::operator[];
5787  #endif
5788  
5789  
5790  
5791  (returned_value_type ==>> value_type)
5792  ___________________________________________________________________
5793  EOF
5794  
5795  
5796  
5797  -------------------------------------------------------------------------
5798  
5799  From: "Hyrum Mortensen" <hymort@hotmail.com>   
5800  To: jano_gaspar@yahoo.com 
5801  Subject: circular_buffer 
5802  Date: Sat, 30 Oct 2004 16:58:33 +0000 
5803  
5804      
5805  Jan,
5806  
5807  I just downloaded your boost circular_buffer container code.  Could you 
5808  provide some examples to use this container in a threaded environment 
5809  (producer-consumer)?
5810  
5811  Thanks
5812  
5813  -------------------------------------------------------------------------
