<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title> Templateboost::circular_buffer&lt; T, Alloc &gt; class Reference</title>
		<link href="stylesheet.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<table ID="Table Header" border="1" bgcolor="#007F7F" cellpadding="2">
			<tr>
				<td bgcolor="#FFFFFF"><img src="../../../../c++boost.gif" width="277" height="86"></td>
				<td><a href="http://boost.org"><font face="Arial" color="FFFFFF"><big>Home</big></font></a></td>
				<td><a href="http://boost.org/libs/libraries.htm"><font face="Arial" color="FFFFFF"><big>Libraries</big></font></a></td>
				<td><a href="http://boost.org/people/people.htm"><font face="Arial" color="FFFFFF"><big>People</big></font></a></td>
				<td><a href="http://boost.org/more/faq.htm"><font face="Arial" color="FFFFFF"><big>FAQ</big></font></a></td>
				<td><a href="http://boost.org/more/index.htm"><font face="Arial" color="FFFFFF"><big>More</big></font></a></td>
			</tr>
		</table>
		<br>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>boost::circular_buffer&lt; T, Alloc &gt; Class Template Reference</h1>Circular buffer - a STL compliant container.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="base_8hpp-source.html">base.hpp</a>&gt;</code>
<p>
Inherits cb_iterator_registry.
<p>
Inherited by <a class="el" href="classboost_1_1circular__buffer__space__optimized.html">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a><code> [private]</code>.
<p>
<a href="classboost_1_1circular__buffer-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc::value_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w0">value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the elements stored in the circular buffer.  <a href="#w0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc::pointer&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w1">pointer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the element.  <a href="#w1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc::const_pointer&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w2">const_pointer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const pointer to the element.  <a href="#w2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc::reference&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to the element.  <a href="#w3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc::const_reference&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w4">const_reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const reference to the element.  <a href="#w4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc::difference_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w5">difference_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Distance type.  <a href="#w5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc::size_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size type.  <a href="#w6"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef Alloc&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the allocator used in the circular buffer.  <a href="#w7"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef cb_details::cb_iterator&lt;<br>
 <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt;,<br>
 cb_details::cb_const_traits&lt;<br>
 Alloc &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const (random access) iterator used to iterate through a circular buffer.  <a href="#w10"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef cb_details::cb_iterator&lt;<br>
 <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt;,<br>
 cb_details::cb_nonconst_traits&lt;<br>
 Alloc &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator (random access) used to iterate through a circular buffer.  <a href="#w11"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>&lt;<br>
 <a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const iterator used to iterate backwards through a circular buffer.  <a href="#w12"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>&lt;<br>
 <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator used to iterate backwards through a circular buffer.  <a href="#w13"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a0">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the allocator.  <a href="#a0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a1">get_allocator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the allocator.  <a href="#a1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a2">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the beginning of the circular buffer.  <a href="#a2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a3">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the end of the circular buffer.  <a href="#a3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a4">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the beginning of the circular buffer.  <a href="#a4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a5">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const iterator pointing to the end of the circular buffer.  <a href="#a5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a6">rbegin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reverse iterator pointing to the beginning of the reversed circular buffer.  <a href="#a6"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a7">rend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reverse iterator pointing to the end of the reversed circular buffer.  <a href="#a7"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a8">rbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const reverse iterator pointing to the beginning of the reversed circular buffer.  <a href="#a8"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a9">rend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const reverse iterator pointing to the end of the reversed circular buffer.  <a href="#a9"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a10">operator[]</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the element at the <code>index</code> position.  <a href="#a10"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>return_value_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a11">operator[]</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the element at the <code>index</code> position.  <a href="#a11"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a12">at</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the element at the <code>index</code> position.  <a href="#a12"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>return_value_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a13">at</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the element at the <code>index</code> position.  <a href="#a13"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a14">front</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first (leftmost) element.  <a href="#a14"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a15">back</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the last (rightmost) element.  <a href="#a15"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>return_value_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a16">front</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first (leftmost) element.  <a href="#a16"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>return_value_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a17">back</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the last (rightmost) element.  <a href="#a17"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w1">pointer</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a18">data</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to data stored in the circular buffer as a continuous array of values.  <a href="#a18"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a19">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of elements currently stored in the circular buffer.  <a href="#a19"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a20">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the largest possible size (or capacity) of the circular buffer.  <a href="#a20"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a21">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the circular buffer empty?  <a href="#a21"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a22">full</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the circular buffer full?  <a href="#a22"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a23">capacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the capacity of the circular buffer.  <a href="#a23"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a24">set_capacity</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> new_capacity, bool remove_front=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the capacity of the circular buffer.  <a href="#a24"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a25">resize</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> new_size, param_value_type item=T(), bool remove_front=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the size of the circular buffer.  <a href="#a25"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a26">circular_buffer</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> capacity, const <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> &amp;alloc=<a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an empty circular buffer with a given capacity.  <a href="#a26"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a27">circular_buffer</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> capacity, param_value_type item, const <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> &amp;alloc=<a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a full circular buffer with a given capacity and filled with copies of <code>item</code>.  <a href="#a27"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a28">circular_buffer</a> (const <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt; &amp;cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a28"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class InputIterator&gt; &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a29">circular_buffer</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> capacity, InputIterator first, InputIterator last, const <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> &amp;alloc=<a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a circular buffer with a copy of a range.  <a href="#a29"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a30">~circular_buffer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a30"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt; &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a31">operator=</a> (const <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt; &amp;cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#a31"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a32">assign</a> (<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> n, param_value_type item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign <code>n</code> items into the circular buffer.  <a href="#a32"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class InputIterator&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a33">assign</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a copy of range.  <a href="#a33"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a34">swap</a> (<a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a> &amp;cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the contents of two circular buffers.  <a href="#a34"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a35">push_back</a> (param_value_type item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new element at the end.  <a href="#a35"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a36">push_back</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new element with the default value at the end.  <a href="#a36"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a37">push_front</a> (param_value_type item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new element at the start.  <a href="#a37"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a38">push_front</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new element with the default value at the start.  <a href="#a38"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a39">pop_back</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the last (rightmost) element.  <a href="#a39"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a40">pop_front</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the first (leftmost) element.  <a href="#a40"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a41">insert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, param_value_type item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert the <code>item</code> before the given position.  <a href="#a41"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a42">insert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new element with the default value before the given position.  <a href="#a42"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a43">insert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, <a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> n, param_value_type item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert <code>n</code> copies of the item before the given position.  <a href="#a43"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class InputIterator&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a44">insert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, InputIterator first, InputIterator last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert the range <code>[first, last)</code> before the given position.  <a href="#a44"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a45">rinsert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, param_value_type item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an <code>item</code> before the given position.  <a href="#a45"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a46">rinsert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new element with the default value before the given position.  <a href="#a46"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a47">rinsert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, <a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> n, param_value_type item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert <code>n</code> copies of the item before the given position.  <a href="#a47"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class InputIterator&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a48">rinsert</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, InputIterator first, InputIterator last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert the range <code>[first, last)</code> before the given position.  <a href="#a48"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a49">erase</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the element at the given position.  <a href="#a49"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a50">erase</a> (<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> first, <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the range <code>[first, last)</code>.  <a href="#a50"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classboost_1_1circular__buffer.html#a51">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all the stored elements.  <a href="#a51"></a><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, class Alloc&gt;<br>
 class boost::circular_buffer&lt; T, Alloc &gt;</h3>

Circular buffer - a STL compliant container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>T</em>&nbsp;</td><td>The type of the elements stored in the circular buffer. </td></tr>
    <tr><td valign=top><em>Alloc</em>&nbsp;</td><td>The allocator type used for all internal memory management. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Author:</b></dt><dd><a href="mailto:jano_gaspar[at]yahoo.com">Jan Gaspar</a> </dd></dl>
<dl compact><dt><b>Version:</b></dt><dd>3.6 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2004</dd></dl>
For more information how to use the circular buffer see the <a href="../circular_buffer.html">documentation</a>. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="w7" doxytag="boost::circular_buffer::allocator_type" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of the allocator used in the circular buffer. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w7">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w10" doxytag="boost::circular_buffer::const_iterator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef cb_details::cb_iterator&lt; <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt;T, Alloc&gt;, cb_details::cb_const_traits&lt;Alloc&gt; &gt; <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Const (random access) iterator used to iterate through a circular buffer. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w9">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w2" doxytag="boost::circular_buffer::const_pointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc::const_pointer <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w2">const_pointer</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Const pointer to the element. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w2">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w4" doxytag="boost::circular_buffer::const_reference" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc::const_reference <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w4">const_reference</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Const reference to the element. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w4">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w12" doxytag="boost::circular_buffer::const_reverse_iterator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>&lt;<a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>&gt; <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Const iterator used to iterate backwards through a circular buffer. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w11">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w5" doxytag="boost::circular_buffer::difference_type" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc::difference_type <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w5">difference_type</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Distance type. 
<p>
A signed integral type used to represent the distance between two iterators. 
<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w6">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w11" doxytag="boost::circular_buffer::iterator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef cb_details::cb_iterator&lt; <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt;T, Alloc&gt;, cb_details::cb_nonconst_traits&lt;Alloc&gt; &gt; <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Iterator (random access) used to iterate through a circular buffer. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w10">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w1" doxytag="boost::circular_buffer::pointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc::pointer <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w1">pointer</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pointer to the element. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w1">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w3" doxytag="boost::circular_buffer::reference" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc::reference <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reference to the element. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w3">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w13" doxytag="boost::circular_buffer::reverse_iterator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>&lt;<a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&gt; <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Iterator used to iterate backwards through a circular buffer. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w12">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w6" doxytag="boost::circular_buffer::size_type" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc::size_type <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Size type. 
<p>
An unsigned integral type that can represent any nonnegative value of the container's distance type. 
<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w5">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="w0" doxytag="boost::circular_buffer::value_type" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef Alloc::value_type <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html#w0">value_type</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of the elements stored in the circular buffer. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#w0">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a26" doxytag="boost::circular_buffer::circular_buffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>alloc</em> = <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, explicit]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an empty circular buffer with a given capacity. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a23">capacity()</a> == capacity &amp;&amp; (*this).size == 0</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="boost::circular_buffer::circular_buffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>param_value_type&nbsp;</td>
          <td class="mdname" nowrap> <em>item</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>alloc</em> = <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a full circular buffer with a given capacity and filled with copies of <code>item</code>. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> == capacity &amp;&amp; (*this)[0] == (*this)[1] == ... == (*this).<a class="el" href="classboost_1_1circular__buffer.html#a15">back()</a> == item</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="boost::circular_buffer::circular_buffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy constructor. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>*this == cb</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="boost::circular_buffer::circular_buffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" colspan="4">
template&lt;class InputIterator&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>alloc</em> = <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a circular buffer with a copy of a range. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid range <code>[first, last)</code>. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a23">capacity()</a> == capacity</code><br>
 If the number of items to copy from the range <code>[first, last)</code> is greater than the specified <code>capacity</code> then only elements from the range <code>[last - capacity, last)</code> will be copied. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="boost::circular_buffer::~circular_buffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::~<a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a> </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a33" doxytag="boost::circular_buffer::assign" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" colspan="4">
template&lt;class InputIterator&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::assign </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign a copy of range. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid range <code>[first, last)</code>. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> == std::distance(first, last)</code><br>
 If the number of items to be assigned exceeds the capacity of the circular buffer the capacity is set to that number otherwise is stays unchanged. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a13">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="boost::circular_buffer::assign" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::assign </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>param_value_type&nbsp;</td>
          <td class="mdname" nowrap> <em>item</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign <code>n</code> items into the circular buffer. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> == n &amp;&amp; (*this)[0] == (*this)[1] == ... == (*this).<a class="el" href="classboost_1_1circular__buffer.html#a15">back()</a> == item</code><br>
 If the number of items to be assigned exceeds the capacity of the circular buffer the capacity is increased to <code>n</code> otherwise it stays unchanged. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a12">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="boost::circular_buffer::at" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> return_value_type <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::at </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the element at the <code>index</code> position. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>std::out_of_range</em>&nbsp;</td><td>thrown when the <code>index</code> is invalid. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="boost::circular_buffer::at" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::at </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the element at the <code>index</code> position. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>std::out_of_range</em>&nbsp;</td><td>thrown when the <code>index</code> is invalid. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="boost::circular_buffer::back" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> return_value_type <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::back </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the last (rightmost) element. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>!*(this).<a class="el" href="classboost_1_1circular__buffer.html#a21">empty()</a></code> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="boost::circular_buffer::back" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::back </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the last (rightmost) element. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>!*(this).<a class="el" href="classboost_1_1circular__buffer.html#a21">empty()</a></code> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="boost::circular_buffer::begin" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::begin </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a const iterator pointing to the beginning of the circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="boost::circular_buffer::begin" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::begin </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return an iterator pointing to the beginning of the circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="boost::circular_buffer::capacity" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::capacity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the capacity of the circular buffer. 
<p>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a5">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="boost::circular_buffer::clear" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::clear </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase all the stored elements. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> == 0 </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a31">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="boost::circular_buffer::data" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w1">pointer</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::data </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return pointer to data stored in the circular buffer as a continuous array of values. 
<p>
This method can be useful e.g. when passing the stored data into the legacy C API. <dl compact><dt><b>Postcondition:</b></dt><dd><code>&amp;(*this)[0] &lt; &amp;(*this)[1] &lt; ... &lt; &amp;(*this).<a class="el" href="classboost_1_1circular__buffer.html#a15">back()</a></code> </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if empty. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="boost::circular_buffer::empty" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bool <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::empty </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Is the circular buffer empty? 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><code>true</code> if there are no elements stored in the circular buffer. <p>
<code>false</code> otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="boost::circular_buffer::end" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w10">const_iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a const iterator pointing to the end of the circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="boost::circular_buffer::end" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return an iterator pointing to the end of the circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="boost::circular_buffer::erase" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::erase </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase the range <code>[first, last)</code>. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid range <code>[first, last)</code>. <p>
<code>size_type old_size = (*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a></code> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> == old_size - std::distance(first, last)</code><br>
 Removes the elements from the range <code>[first, last)</code>. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the first element remaining beyond the removed element or <code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a3">end()</a></code> if no such element exists. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a30">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="boost::circular_buffer::erase" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::erase </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pos</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase the element at the given position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid <code>pos</code> iterator. <p>
<code>size_type old_size = (*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a></code> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> == old_size - 1</code><br>
 Removes an element at the position <code>pos</code>. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the first element remaining beyond the removed element or <code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a3">end()</a></code> if no such element exists. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a29">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="boost::circular_buffer::front" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> return_value_type <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::front </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the first (leftmost) element. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>!*(this).<a class="el" href="classboost_1_1circular__buffer.html#a21">empty()</a></code> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="boost::circular_buffer::front" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::front </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the first (leftmost) element. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>!*(this).<a class="el" href="classboost_1_1circular__buffer.html#a21">empty()</a></code> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="boost::circular_buffer::full" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bool <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::full </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Is the circular buffer full? 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><code>true</code> if the number of elements stored in the circular buffer equals the capacity of the circular buffer. <p>
<code>false</code> otherwise. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a2">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="boost::circular_buffer::get_allocator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>&amp; <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the allocator. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This method was added in order to optimize obtaining of the allocator with a state, although use of stateful allocators in STL is discouraged. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="boost::circular_buffer::get_allocator" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the allocator. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="boost::circular_buffer::insert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" colspan="4">
template&lt;class InputIterator&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert the range <code>[first, last)</code> before the given position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid <code>pos</code> iterator and valid range <code>[first, last)</code>. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the beginning (left) of the circular buffer will be removed or not the whole range will be inserted or both. In case the whole range cannot be inserted it will be inserted just some elements from the end (right) of the range (see the example).<code><br>
 Example:<br>
 array to insert: int array[] = { 5, 6, 7, 8, 9 };<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, array, array + 5);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|5|6|7|8|9|3|4|)<br>
 RESULTING circular buffer |6|7|8|9|3|4| - capacity: 6, size: 6</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a24">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="boost::circular_buffer::insert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>param_value_type&nbsp;</td>
          <td class="mdname" nowrap> <em>item</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert <code>n</code> copies of the item before the given position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid <code>pos</code> iterator. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the beginning (left) of the circular buffer will be removed or not all <code>n</code> elements will be inserted or both.<code><br>
 Example:<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, (size_t)5, 6);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|6|6|6|6|6|3|4|)<br>
 RESULTING circular buffer |6|6|6|6|3|4| - capacity: 6, size: 6</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a23">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="boost::circular_buffer::insert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pos</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a new element with the default value before the given position. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code><a class="el" href="classboost_1_1circular__buffer.html#w0">value_type()</a></code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the first (leftmost) element will be removed. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the inserted element. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a22">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="boost::circular_buffer::insert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>param_value_type&nbsp;</td>
          <td class="mdname" nowrap> <em>item</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert the <code>item</code> before the given position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid <code>pos</code> iterator. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>The <code>item</code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the first (leftmost) element will be removed. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the inserted element. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a21">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="boost::circular_buffer::max_size" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::max_size </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the largest possible size (or capacity) of the circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="boost::circular_buffer::operator=" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt;T, Alloc&gt;&amp; <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assignment operator. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>*this == cb</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="boost::circular_buffer::operator[]" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> return_value_type <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::operator[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the element at the <code>index</code> position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>*(this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> &gt; index</code> </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a1">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="boost::circular_buffer::operator[]" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::operator[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the element at the <code>index</code> position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>*(this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> &gt; index</code> </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a0">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="boost::circular_buffer::pop_back" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::pop_back </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove the last (rightmost) element. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>!*(this).<a class="el" href="classboost_1_1circular__buffer.html#a21">empty()</a></code> <p>
<code>iterator it = ((*this).<a class="el" href="classboost_1_1circular__buffer.html#a3">end()</a> - 1)</code> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>((*this).<a class="el" href="classboost_1_1circular__buffer.html#a3">end()</a> - 1) != it</code> </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a19">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="boost::circular_buffer::pop_front" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::pop_front </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove the first (leftmost) element. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><code>!*(this).<a class="el" href="classboost_1_1circular__buffer.html#a21">empty()</a></code> <p>
<code>iterator it = (*this).<a class="el" href="classboost_1_1circular__buffer.html#a2">begin()</a></code> </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a2">begin()</a> != it</code> </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a20">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="boost::circular_buffer::push_back" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::push_back </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a new element with the default value at the end. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a15">back()</a> == <a class="el" href="classboost_1_1circular__buffer.html#w0">value_type()</a></code><br>
 If the circular buffer is full, the first (leftmost) element will be removed. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a16">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="boost::circular_buffer::push_back" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::push_back </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">param_value_type&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>item</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a new element at the end. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a15">back()</a> == item</code><br>
 If the circular buffer is full, the first (leftmost) element will be removed. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a15">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="boost::circular_buffer::push_front" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::push_front </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a new element with the default value at the start. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a14">front()</a> == <a class="el" href="classboost_1_1circular__buffer.html#w0">value_type()</a></code><br>
 If the circular buffer is full, the last (rightmost) element will be removed. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a18">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="boost::circular_buffer::push_front" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::push_front </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">param_value_type&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>item</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a new element at the start. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a14">front()</a> == item</code><br>
 If the circular buffer is full, the last (rightmost) element will be removed. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a17">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="boost::circular_buffer::rbegin" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rbegin </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a const reverse iterator pointing to the beginning of the reversed circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="boost::circular_buffer::rbegin" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rbegin </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a reverse iterator pointing to the beginning of the reversed circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="boost::circular_buffer::rend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a const reverse iterator pointing to the end of the reversed circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="boost::circular_buffer::rend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a reverse iterator pointing to the end of the reversed circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="boost::circular_buffer::resize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::resize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>param_value_type&nbsp;</td>
          <td class="mdname" nowrap> <em>item</em> = T(), </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>remove_front</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the size of the circular buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>new_size</em>&nbsp;</td><td>The new size. </td></tr>
    <tr><td valign=top><em>item</em>&nbsp;</td><td>See the postcondition. </td></tr>
    <tr><td valign=top><em>remove_front</em>&nbsp;</td><td>This parameter plays its role only if the current number of elements stored in the circular buffer is greater than the desired new capacity. If set to <code>true</code> then the first (leftmost) elements will be removed. If set to <code>false</code> then the last (leftmost) elements will be removed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> == new_size</code><br>
 If the new size is greater than the current size, the rest of the circular buffer is filled with copies of <code>item</code>. In case the resulting size exceeds the current capacity the capacity is set to <code>new_size</code>. If the new size is lower than the current size then <code>((*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> - new_size)</code> elements will be removed according to the <code>remove_front</code> parameter. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a8">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="boost::circular_buffer::rinsert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" colspan="4">
template&lt;class InputIterator&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rinsert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert the range <code>[first, last)</code> before the given position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid <code>pos</code> iterator and valid range <code>[first, last)</code>. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the end (right) of the circular buffer will be removed or not the whole range will be inserted or both. In case the whole range cannot be inserted it will be inserted just some elements from the beginning (left) of the range (see the example).<code><br>
 Example:<br>
 array to insert: int array[] = { 5, 6, 7, 8, 9 };<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, array, array + 5);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|5|6|7|8|9|3|4|)<br>
 RESULTING circular buffer |1|2|5|6|7|8| - capacity: 6, size: 6</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a28">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="boost::circular_buffer::rinsert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rinsert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>param_value_type&nbsp;</td>
          <td class="mdname" nowrap> <em>item</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert <code>n</code> copies of the item before the given position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid <code>pos</code> iterator. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>This operation preserves the capacity of the circular buffer. If the insertion would result in exceeding the capacity of the circular buffer then the necessary number of elements from the end (right) of the circular buffer will be removed or not all <code>n</code> elements will be inserted or both.<code><br>
 Example:<br>
 original circular buffer |1|2|3|4| | | - capacity: 6, size: 4<br>
 position ---------------------^<br>
 insert(position, (size_t)5, 6);<br>
 (If the operation won't preserve capacity, the buffer would look like this |1|2|6|6|6|6|6|3|4|)<br>
 RESULTING circular buffer |1|2|6|6|6|6| - capacity: 6, size: 6</code> </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a27">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="boost::circular_buffer::rinsert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rinsert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pos</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a new element with the default value before the given position. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code><a class="el" href="classboost_1_1circular__buffer.html#w0">value_type()</a></code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the last (rightmost) element will be removed. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the inserted element. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a26">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="boost::circular_buffer::rinsert" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::rinsert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w11">iterator</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>param_value_type&nbsp;</td>
          <td class="mdname" nowrap> <em>item</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an <code>item</code> before the given position. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>Valid <code>pos</code> iterator. </dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>The <code>item</code> will be inserted at the position <code>pos</code>.<br>
 If the circular buffer is full, the last element (rightmost) will be removed. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the inserted element. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::operator = (const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a25">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="boost::circular_buffer::set_capacity" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::set_capacity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>new_capacity</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>remove_front</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the capacity of the circular buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>new_capacity</em>&nbsp;</td><td>The new capacity. </td></tr>
    <tr><td valign=top><em>remove_front</em>&nbsp;</td><td>This parameter plays its role only if the current number of elements stored in the circular buffer is greater than the desired new capacity. If set to <code>true</code> then the first (leftmost) elements will be removed. If set to <code>false</code> then the last (leftmost) elements will be removed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>(*this).<a class="el" href="classboost_1_1circular__buffer.html#a23">capacity()</a> == new_capacity</code><br>
 If the current number of elements stored in the circular buffer is greater than the desired new capacity then <code>((*this).<a class="el" href="classboost_1_1circular__buffer.html#a19">size()</a> - new_capacity)</code> elements will be removed according to the <code>remove_front</code> parameter. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>An allocation error</em>&nbsp;</td><td>if memory is exhausted (<code>std::bad_alloc</code> if standard allocator is used). </td></tr>
    <tr><td valign=top><em>Whatever</em>&nbsp;</td><td>T::T(const T&amp;) throws. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>

<p>
Reimplemented in <a class="el" href="classboost_1_1circular__buffer__space__optimized.html#a7">boost::circular_buffer_space_optimized&lt; T, Alloc &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="boost::circular_buffer::size" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classboost_1_1circular__buffer.html#w6">size_type</a> <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::size </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of elements currently stored in the circular buffer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="boost::circular_buffer::swap" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T, class Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void <a class="el" href="classboost_1_1circular__buffer.html">boost::circular_buffer</a>&lt; T, Alloc &gt;::swap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classboost_1_1circular__buffer.html">circular_buffer</a>&lt; T, Alloc &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Swap the contents of two circular buffers. 
<p>
<dl compact><dt><b>Postcondition:</b></dt><dd><code>this</code> contains elements of <code>cb</code> and vice versa. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>For iterator invalidation see the <a href="../circular_buffer.html#invalidation">documentation</a>. </dd></dl>
    </td>
  </tr>
</table>
<hr>
<table id="Table Footer" width="100%" border="0">
	<tr>
		<td valign="top"><small>Copyright  2003-2004 <A href="mailto:jano_gaspar[at]yahoo.com">Jan 
					Gaspar</A></small></td>
		<td align="center"><img width="277" height="86" src="../../../../c++boost.gif"></td>
		<td align="right" valign="top"><small>Generated by <a href="http://www.doxygen.org">doxygen 
					1.3.5</a>.</small></td>
	</tr>
</table>
</body>
</html>
