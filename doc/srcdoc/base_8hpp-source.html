<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>base.hpp Source File</title>
		<link href="stylesheet.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<table ID="Table Header" border="1" bgcolor="#007F7F" cellpadding="2">
			<tr>
				<td bgcolor="#FFFFFF"><img src="../../../../c++boost.gif" width="277" height="86"></td>
				<td><a href="http://boost.org"><font face="Arial" color="FFFFFF"><big>Home</big></font></a></td>
				<td><a href="http://boost.org/libs/libraries.htm"><font face="Arial" color="FFFFFF"><big>Libraries</big></font></a></td>
				<td><a href="http://boost.org/people/people.htm"><font face="Arial" color="FFFFFF"><big>People</big></font></a></td>
				<td><a href="http://boost.org/more/faq.htm"><font face="Arial" color="FFFFFF"><big>FAQ</big></font></a></td>
				<td><a href="http://boost.org/more/index.htm"><font face="Arial" color="FFFFFF"><big>More</big></font></a></td>
			</tr>
		</table>
		<br>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>base.hpp</h1><div class="fragment"><pre>00001 <span class="comment">// Implementation of the base circular buffer.</span>
00002 
00003 <span class="comment">// Copyright (c) 2003-2004 Jan Gaspar</span>
00004 
00005 <span class="comment">// Use, modification, and distribution is subject to the Boost Software</span>
00006 <span class="comment">// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
00007 <span class="comment">// http://www.boost.org/LICENSE_1_0.txt)</span>
00008 
00009 <span class="preprocessor">#if !defined(BOOST_CIRCULAR_BUFFER_BASE_HPP)</span>
00010 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_CIRCULAR_BUFFER_BASE_HPP</span>
00011 <span class="preprocessor"></span>
00012 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1200</span>
00013 <span class="preprocessor"></span><span class="preprocessor">    #pragma once</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00015 <span class="preprocessor"></span>
00016 <span class="preprocessor">#include &lt;boost/call_traits.hpp&gt;</span>
00017 <span class="preprocessor">#include &lt;boost/concept_check.hpp&gt;</span>
00018 <span class="preprocessor">#include &lt;boost/throw_exception.hpp&gt;</span>
00019 <span class="preprocessor">#include &lt;boost/iterator/reverse_iterator.hpp&gt;</span>
00020 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00021 <span class="preprocessor">#if !defined(BOOST_NO_EXCEPTIONS)</span>
00022 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;stdexcept&gt;</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
00025 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;string.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="keyword">namespace </span>boost {
00029 
00042 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l00043"></a><a class="code" href="classboost_1_1circular__buffer.html">00043</a> <span class="keyword">class </span><a class="code" href="classboost_1_1circular__buffer.html">circular_buffer</a> : cb_details::cb_iterator_registry {
00044 
00045 <span class="comment">// Requirements</span>
00046     BOOST_CLASS_REQUIRE(T, boost, CopyConstructibleConcept);
00047 
00048 <span class="keyword">public</span>:
00049 <span class="comment">// Basic types</span>
00050 
<a name="l00052"></a><a class="code" href="classboost_1_1circular__buffer.html#w0">00052</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::value_type <a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>;
00053 
<a name="l00055"></a><a class="code" href="classboost_1_1circular__buffer.html#w1">00055</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::pointer <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a>;
00056 
<a name="l00058"></a><a class="code" href="classboost_1_1circular__buffer.html#w2">00058</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_pointer <a class="code" href="classboost_1_1circular__buffer.html#w2">const_pointer</a>;
00059 
<a name="l00061"></a><a class="code" href="classboost_1_1circular__buffer.html#w3">00061</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::reference <a class="code" href="classboost_1_1circular__buffer.html#w3">reference</a>;
00062 
<a name="l00064"></a><a class="code" href="classboost_1_1circular__buffer.html#w4">00064</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_reference <a class="code" href="classboost_1_1circular__buffer.html#w4">const_reference</a>;
00065 
00067 
<a name="l00070"></a><a class="code" href="classboost_1_1circular__buffer.html#w5">00070</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::difference_type <a class="code" href="classboost_1_1circular__buffer.html#w5">difference_type</a>;
00071 
00073 
<a name="l00076"></a><a class="code" href="classboost_1_1circular__buffer.html#w6">00076</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::size_type <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a>;
00077 
<a name="l00079"></a><a class="code" href="classboost_1_1circular__buffer.html#w7">00079</a>     <span class="keyword">typedef</span> Alloc <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>;
00080 
<a name="l00082"></a><a class="code" href="classboost_1_1circular__buffer.html#a0">00082</a>     <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> <a class="code" href="classboost_1_1circular__buffer.html#a0">get_allocator</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_alloc; }
00083 
00085 
<a name="l00089"></a><a class="code" href="classboost_1_1circular__buffer.html#a1">00089</a>     <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>&amp; <a class="code" href="classboost_1_1circular__buffer.html#a0">get_allocator</a>() { <span class="keywordflow">return</span> m_alloc; }
00090 
00091 <span class="comment">// Helper types</span>
00092 
00093     <span class="comment">// Define a type that represents the "best" way to pass the value_type to a method.</span>
00094     <span class="keyword">typedef</span> <span class="keyword">typename</span> call_traits&lt;value_type&gt;::param_type param_value_type;
00095 
00096     <span class="comment">// Define a type that represents the "best" way to return the value_type from a const method.</span>
00097     <span class="keyword">typedef</span> <span class="keyword">typename</span> call_traits&lt;value_type&gt;::param_type return_value_type;
00098 
00099 <span class="comment">// Iterators</span>
00100 
<a name="l00102"></a><a class="code" href="classboost_1_1circular__buffer.html#w10">00102</a>     <span class="keyword">typedef</span> cb_details::cb_iterator&lt; circular_buffer&lt;T, Alloc&gt;, cb_details::cb_const_traits&lt;Alloc&gt; &gt; <a class="code" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>;
00103 
<a name="l00105"></a><a class="code" href="classboost_1_1circular__buffer.html#w11">00105</a>     <span class="keyword">typedef</span> cb_details::cb_iterator&lt; circular_buffer&lt;T, Alloc&gt;, cb_details::cb_nonconst_traits&lt;Alloc&gt; &gt; <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>;
00106 
<a name="l00108"></a><a class="code" href="classboost_1_1circular__buffer.html#w12">00108</a>     <span class="keyword">typedef</span> <a class="code" href="classboost_1_1circular__buffer.html#w13">reverse_iterator&lt;const_iterator&gt;</a> <a class="code" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a>;
00109 
<a name="l00111"></a><a class="code" href="classboost_1_1circular__buffer.html#w13">00111</a>     <span class="keyword">typedef</span> <a class="code" href="classboost_1_1circular__buffer.html#w13">reverse_iterator&lt;iterator&gt;</a> <a class="code" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>;
00112 
00113 <span class="keyword">private</span>:
00114 <span class="comment">// Member variables</span>
00115 
00117     <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> m_buff;
00118 
00120     <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> m_end;
00121 
00123     <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> m_first;
00124 
00126     <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> m_last;
00127 
00129     <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> m_size;
00130 
00132     <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a> m_alloc;
00133 
00134 <span class="comment">// Friends</span>
00135 <span class="preprocessor">#if defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)</span>
00136 <span class="preprocessor"></span>    <span class="keyword">friend</span> <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>;
00137     <span class="keyword">friend</span> <a class="code" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>;
00138 <span class="preprocessor">#else</span>
00139 <span class="preprocessor"></span>    <span class="keyword">friend</span> <span class="keyword">struct </span><a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>;
00140     <span class="keyword">friend</span> <span class="keyword">struct </span><a class="code" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>;
00141 <span class="preprocessor">#endif</span>
00142 <span class="preprocessor"></span>
00143 <span class="keyword">public</span>:
00144 <span class="comment">// Element access</span>
00145 
<a name="l00147"></a><a class="code" href="classboost_1_1circular__buffer.html#a2">00147</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>() { <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>(<span class="keyword">this</span>, <a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>() ? 0 : m_first); }
00148 
<a name="l00150"></a><a class="code" href="classboost_1_1circular__buffer.html#a3">00150</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() { <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>(<span class="keyword">this</span>, 0); }
00151 
<a name="l00153"></a><a class="code" href="classboost_1_1circular__buffer.html#a4">00153</a>     <a class="code" href="classboost_1_1circular__buffer.html#w10">const_iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>(<span class="keyword">this</span>, <a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>() ? 0 : m_first); }
00154 
<a name="l00156"></a><a class="code" href="classboost_1_1circular__buffer.html#a5">00156</a>     <a class="code" href="classboost_1_1circular__buffer.html#w10">const_iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w10">const_iterator</a>(<span class="keyword">this</span>, 0); }
00157 
<a name="l00159"></a><a class="code" href="classboost_1_1circular__buffer.html#a6">00159</a>     <a class="code" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a6">rbegin</a>() { <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>(<a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>()); }
00160 
<a name="l00162"></a><a class="code" href="classboost_1_1circular__buffer.html#a7">00162</a>     <a class="code" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a7">rend</a>() { <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w13">reverse_iterator</a>(<a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>()); }
00163     
<a name="l00165"></a><a class="code" href="classboost_1_1circular__buffer.html#a8">00165</a>     <a class="code" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a6">rbegin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a>(<a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>()); }
00166 
<a name="l00168"></a><a class="code" href="classboost_1_1circular__buffer.html#a9">00168</a>     <a class="code" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a7">rend</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w12">const_reverse_iterator</a>(<a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>()); }
00169 
00171 
<a name="l00174"></a><a class="code" href="classboost_1_1circular__buffer.html#a10">00174</a>     <a class="code" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="code" href="classboost_1_1circular__buffer.html#a10">operator [] </a>(<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> index) {
00175         BOOST_CB_ASSERT(index &lt; <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>()); <span class="comment">// check for invalid index</span>
00176         <span class="keywordflow">return</span> *add(m_first, index);
00177     }
00178 
00180 
<a name="l00183"></a><a class="code" href="classboost_1_1circular__buffer.html#a11">00183</a>     return_value_type <a class="code" href="classboost_1_1circular__buffer.html#a10">operator [] </a>(<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> index)<span class="keyword"> const </span>{
00184         BOOST_CB_ASSERT(index &lt; <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>()); <span class="comment">// check for invalid index</span>
00185         <span class="keywordflow">return</span> *add(m_first, index);
00186     }
00187 
00189 
<a name="l00192"></a><a class="code" href="classboost_1_1circular__buffer.html#a12">00192</a>     <a class="code" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="code" href="classboost_1_1circular__buffer.html#a12">at</a>(<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> index) {
00193         check_position(index);
00194         <span class="keywordflow">return</span> (*this)[index];
00195     }
00196 
00198 
<a name="l00201"></a><a class="code" href="classboost_1_1circular__buffer.html#a13">00201</a>     return_value_type <a class="code" href="classboost_1_1circular__buffer.html#a12">at</a>(<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> index)<span class="keyword"> const </span>{
00202         check_position(index);
00203         <span class="keywordflow">return</span> (*this)[index];
00204     }
00205 
00207 
<a name="l00210"></a><a class="code" href="classboost_1_1circular__buffer.html#a14">00210</a>     <a class="code" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="code" href="classboost_1_1circular__buffer.html#a14">front</a>() {
00211         BOOST_CB_ASSERT(!<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>()); <span class="comment">// check for empty buffer (front element not available)</span>
00212         <span class="keywordflow">return</span> *m_first;
00213     }
00214 
00216 
<a name="l00219"></a><a class="code" href="classboost_1_1circular__buffer.html#a15">00219</a>     <a class="code" href="classboost_1_1circular__buffer.html#w3">reference</a> <a class="code" href="classboost_1_1circular__buffer.html#a15">back</a>() {
00220         BOOST_CB_ASSERT(!<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>()); <span class="comment">// check for empty buffer (back element not available)</span>
00221         <span class="keywordflow">return</span> *((m_last == m_buff ? m_end : m_last) - 1);
00222     }
00223 
00225 
<a name="l00228"></a><a class="code" href="classboost_1_1circular__buffer.html#a16">00228</a>     return_value_type <a class="code" href="classboost_1_1circular__buffer.html#a14">front</a>()<span class="keyword"> const </span>{
00229         BOOST_CB_ASSERT(!<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>()); <span class="comment">// check for empty buffer (front element not available)</span>
00230         <span class="keywordflow">return</span> *m_first;
00231     }
00232 
00234 
<a name="l00237"></a><a class="code" href="classboost_1_1circular__buffer.html#a17">00237</a>     return_value_type <a class="code" href="classboost_1_1circular__buffer.html#a15">back</a>()<span class="keyword"> const </span>{
00238         BOOST_CB_ASSERT(!<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>()); <span class="comment">// check for empty buffer (back element not available)</span>
00239         <span class="keywordflow">return</span> *((m_last == m_buff ? m_end : m_last) - 1);
00240     }
00241 
00243 
<a name="l00251"></a><a class="code" href="classboost_1_1circular__buffer.html#a18">00251</a>     <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> <a class="code" href="classboost_1_1circular__buffer.html#a18">data</a>() {
00252         <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>())
00253             <span class="keywordflow">return</span> 0;
00254         <span class="keywordflow">if</span> (m_first &lt; m_last || m_last == m_buff)
00255             <span class="keywordflow">return</span> m_first;
00256         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> constructed = 0;
00257         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> src = m_first;
00258         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> dest = m_buff;
00259         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> tmp = 0;
00260         BOOST_CB_TRY
00261         tmp = allocate(1);
00262         <span class="keywordflow">for</span> (<a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> first = m_first; dest &lt; src; src = first) {
00263             <span class="keywordflow">for</span> (<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> ii = 0; src &lt; m_end; ++src, ++dest, ++ii) {
00264                 <span class="keywordflow">if</span> (dest == first) {
00265                     first += ii;
00266                     <span class="keywordflow">break</span>;
00267                 }
00268                 <span class="keywordflow">if</span> (is_uninitialized(dest)) {
00269                     m_alloc.construct(dest, *src);
00270                     ++constructed;
00271                 } <span class="keywordflow">else</span> {
00272                     m_alloc.construct(tmp, *src);
00273                     BOOST_CB_TRY
00274                     replace(src, *dest);
00275                     BOOST_CB_UNWIND(
00276                         destroy_item(tmp);
00277                         tidy(src);
00278                     )
00279                     BOOST_CB_TRY
00280                     replace(dest, *tmp);
00281                     BOOST_CB_UNWIND(
00282                         destroy_item(tmp);
00283                         tidy(dest);
00284                     )
00285                     destroy_item(tmp);
00286                 }
00287             }
00288         }
00289         deallocate(tmp, 1);
00290         BOOST_CB_UNWIND(
00291             deallocate(tmp, 1);
00292             m_last += constructed;
00293             m_size += constructed;
00294         )
00295         <span class="keywordflow">for</span> (dest = m_buff + <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>(); dest &lt; m_end; ++dest)
00296             destroy_item(dest);
00297         m_first = m_buff;
00298         m_last = add(m_buff, <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>());
00299         <span class="keywordflow">return</span> m_buff;
00300     }
00301 
00302 <span class="comment">// Size and capacity</span>
00303 
<a name="l00305"></a><a class="code" href="classboost_1_1circular__buffer.html#a19">00305</a>     <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_size; }
00306 
<a name="l00308"></a><a class="code" href="classboost_1_1circular__buffer.html#a20">00308</a>     <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> <a class="code" href="classboost_1_1circular__buffer.html#a20">max_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_alloc.max_size(); }
00309     
00311 
<a name="l00315"></a><a class="code" href="classboost_1_1circular__buffer.html#a21">00315</a>     <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>() == 0; }
00316 
00318 
<a name="l00323"></a><a class="code" href="classboost_1_1circular__buffer.html#a22">00323</a>     <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>() == <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>(); }
00324 
<a name="l00326"></a><a class="code" href="classboost_1_1circular__buffer.html#a23">00326</a>     <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_end - m_buff; }
00327 
00329 
<a name="l00347"></a><a class="code" href="classboost_1_1circular__buffer.html#a24">00347</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a24">set_capacity</a>(<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> new_capacity, <span class="keywordtype">bool</span> remove_front = <span class="keyword">true</span>) {
00348         <span class="keywordflow">if</span> (new_capacity == <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>())
00349             <span class="keywordflow">return</span>;
00350         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> buff = allocate(new_capacity);
00351         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> new_size = std::min(new_capacity, <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>());
00352         BOOST_CB_TRY
00353         <span class="keywordflow">if</span> (remove_front)
00354             cb_details::uninitialized_copy(<a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() - new_size, <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>(), buff, m_alloc);
00355         <span class="keywordflow">else</span>
00356             cb_details::uninitialized_copy(<a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>(), <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>() + new_size, buff, m_alloc);
00357         BOOST_CB_UNWIND(deallocate(buff, new_capacity))
00358         destroy();
00359         m_size = new_size;
00360         m_buff = m_first = buff;
00361         m_end = m_buff + new_capacity;
00362         m_last = add(m_buff, <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>());
00363     }
00364 
00366 
<a name="l00387"></a><a class="code" href="classboost_1_1circular__buffer.html#a25">00387</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a25">resize</a>(<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> new_size, param_value_type item = T(), <span class="keywordtype">bool</span> remove_front = <span class="keyword">true</span>) {
00388         <span class="keywordflow">if</span> (new_size &gt; <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>()) {
00389             <span class="keywordflow">if</span> (new_size &gt; <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>())
00390                 <a class="code" href="classboost_1_1circular__buffer.html#a24">set_capacity</a>(new_size);
00391             <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(<a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>(), new_size - <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>(), item);
00392         } <span class="keywordflow">else</span> {
00393             <span class="keywordflow">if</span> (remove_front)
00394                 <a class="code" href="classboost_1_1circular__buffer.html#a49">erase</a>(<a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>(), <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() - new_size);
00395             <span class="keywordflow">else</span>
00396                 <a class="code" href="classboost_1_1circular__buffer.html#a49">erase</a>(<a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>() + new_size, <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>());
00397         }
00398     }
00399 
00400 <span class="comment">// Construction/Destruction</span>
00401 
00403 
<a name="l00407"></a><a class="code" href="classboost_1_1circular__buffer.html#a26">00407</a>     <span class="keyword">explicit</span> <a class="code" href="classboost_1_1circular__buffer.html#a26">circular_buffer</a>(
00408         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> capacity,
00409         <span class="keyword">const</span> <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>&amp; alloc = <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>())
00410     : m_size(0), m_alloc(alloc) {
00411         m_first = m_last = m_buff = allocate(capacity);
00412         m_end = m_buff + capacity;
00413     }
00414 
00416 
<a name="l00421"></a><a class="code" href="classboost_1_1circular__buffer.html#a27">00421</a>     <a class="code" href="classboost_1_1circular__buffer.html#a26">circular_buffer</a>(
00422         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> capacity,
00423         param_value_type item,
00424         <span class="keyword">const</span> <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>&amp; alloc = <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>())
00425     : m_size(capacity), m_alloc(alloc) {
00426         m_first = m_last = m_buff = allocate(capacity);
00427         m_end = m_buff + capacity;
00428         BOOST_CB_TRY
00429         cb_details::uninitialized_fill_n(m_buff, <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>(), item, m_alloc);
00430         BOOST_CB_UNWIND(deallocate(m_buff, capacity))
00431     }
00432 
00434 
<a name="l00439"></a><a class="code" href="classboost_1_1circular__buffer.html#a28">00439</a>     <a class="code" href="classboost_1_1circular__buffer.html#a26">circular_buffer</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1circular__buffer.html">circular_buffer&lt;T, Alloc&gt;</a>&amp; cb)
00440     : m_size(cb.size()), m_alloc(cb.get_allocator()) {
00441         m_first = m_last = m_buff = allocate(cb.capacity());
00442         BOOST_CB_TRY
00443         m_end = cb_details::uninitialized_copy(cb.begin(), cb.end(), m_buff, m_alloc);
00444         BOOST_CB_UNWIND(deallocate(m_buff, cb.capacity()))
00445     }
00446 
00448 
00458     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00459"></a><a class="code" href="classboost_1_1circular__buffer.html#a29">00459</a>     <a class="code" href="classboost_1_1circular__buffer.html#a26">circular_buffer</a>(
00460         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> capacity,
00461         InputIterator first,
00462         InputIterator last,
00463         <span class="keyword">const</span> <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>&amp; alloc = <a class="code" href="classboost_1_1circular__buffer.html#w7">allocator_type</a>())
00464     : m_alloc(alloc) {
00465         BOOST_CB_IS_CONVERTIBLE(InputIterator, <a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>);
00466         BOOST_CB_ASSERT(std::distance(first, last) &gt;= 0); <span class="comment">// check for wrong range</span>
00467         m_first = m_buff = allocate(capacity);
00468         m_end = m_buff + capacity;
00469         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> diff = std::distance(first, last);
00470         <span class="keywordflow">if</span> (diff &gt; capacity) {
00471             std::advance(first, diff - capacity);
00472             m_size = capacity;
00473             m_last = m_buff;
00474         } <span class="keywordflow">else</span> {
00475             m_size = diff;
00476             <span class="keywordflow">if</span> (diff == capacity)
00477                 m_last = m_buff;
00478             <span class="keywordflow">else</span>
00479                 m_last = m_buff + <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>();
00480         }
00481         BOOST_CB_TRY
00482         cb_details::uninitialized_copy(first, last, m_buff, m_alloc);
00483         BOOST_CB_UNWIND(deallocate(m_buff, capacity))
00484     }
00485 
<a name="l00487"></a><a class="code" href="classboost_1_1circular__buffer.html#a30">00487</a>     <a class="code" href="classboost_1_1circular__buffer.html#a30">~circular_buffer</a>() { destroy(); }
00488 
00489 <span class="keyword">private</span>:
00490 <span class="comment">// Helper functors</span>
00491 
00492     <span class="comment">// Functor for assigning n items.</span>
00493     <span class="keyword">struct </span>assign_n {
00494         <a class="code" href="classboost_1_1circular__buffer.html">size_type</a> m_n;
00495         param_value_type m_item;
00496         allocator_type&amp; m_alloc;
00497         <span class="keyword">explicit</span> assign_n(<a class="code" href="classboost_1_1circular__buffer.html">size_type</a> n, param_value_type item, allocator_type&amp; alloc) : m_n(n), m_item(item), m_alloc(alloc) {}
00498         <span class="keywordtype">void</span> operator () (pointer p)<span class="keyword"> const </span>{
00499             cb_details::uninitialized_fill_n(p, m_n, m_item, m_alloc);
00500         }
00501     <span class="keyword">private</span>:
00502         assign_n&amp; <a class="code" href="classboost_1_1circular__buffer.html#a31">operator = </a>(<span class="keyword">const</span> assign_n&amp;); <span class="comment">// do not generate</span>
00503     };
00504 
00505     <span class="comment">// Functor for assigning range of items.</span>
00506     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
00507     <span class="keyword">struct </span>assign_range {
00508         InputIterator m_first;
00509         InputIterator m_last;
00510         allocator_type&amp; m_alloc;
00511         <span class="keyword">explicit</span> assign_range(InputIterator first, InputIterator last, allocator_type&amp; alloc) : m_first(first), m_last(last), m_alloc(alloc) {}
00512         <span class="keywordtype">void</span> operator () (pointer p)<span class="keyword"> const </span>{
00513             cb_details::uninitialized_copy(m_first, m_last, p, m_alloc);
00514         }
00515     <span class="keyword">private</span>:
00516         assign_range&amp; <a class="code" href="classboost_1_1circular__buffer.html#a31">operator = </a>(<span class="keyword">const</span> assign_range&amp;); <span class="comment">// do not generate</span>
00517     };
00518 
00519 <span class="keyword">public</span>:
00520 <span class="comment">// Assign methods</span>
00521 
00523 
<a name="l00529"></a><a class="code" href="classboost_1_1circular__buffer.html#a31">00529</a>     <a class="code" href="classboost_1_1circular__buffer.html">circular_buffer&lt;T, Alloc&gt;</a>&amp; <a class="code" href="classboost_1_1circular__buffer.html#a31">operator = </a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1circular__buffer.html">circular_buffer&lt;T, Alloc&gt;</a>&amp; cb) {
00530         <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;cb)
00531             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00532         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> buff = allocate(cb.<a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>());
00533         BOOST_CB_TRY
00534         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> last = cb_details::uninitialized_copy(cb.<a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>(), cb.<a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>(), buff, m_alloc);
00535         destroy();
00536         m_size = cb.<a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>();
00537         m_first = m_buff = buff;
00538         m_end = m_buff + cb.<a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>();
00539         m_last = <a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>() ? m_buff : last;
00540         BOOST_CB_UNWIND(deallocate(buff, cb.<a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>()))
00541         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00542     }
00543 
00545 
<a name="l00555"></a><a class="code" href="classboost_1_1circular__buffer.html#a32">00555</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a32">assign</a>(<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> n, param_value_type item) { do_assign(n, assign_n(n, item, m_alloc)); }
00556     
00558 
00568     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00569"></a><a class="code" href="classboost_1_1circular__buffer.html#a33">00569</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a32">assign</a>(InputIterator first, InputIterator last) {
00570         <a class="code" href="classboost_1_1circular__buffer.html#a32">assign</a>(first, last, cb_details::cb_iterator_category_traits&lt;InputIterator&gt;::tag());
00571     }
00572 
00574 
<a name="l00578"></a><a class="code" href="classboost_1_1circular__buffer.html#a34">00578</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a34">swap</a>(<a class="code" href="classboost_1_1circular__buffer.html">circular_buffer</a>&amp; cb) {
00579         std::swap(m_alloc, cb.<a class="code" href="classboost_1_1circular__buffer.html#r5">m_alloc</a>); <span class="comment">// in general this is not necessary,</span>
00580                                         <span class="comment">// because allocators should not have state</span>
00581         std::swap(m_buff, cb.<a class="code" href="classboost_1_1circular__buffer.html#r0">m_buff</a>);
00582         std::swap(m_end, cb.<a class="code" href="classboost_1_1circular__buffer.html#r1">m_end</a>);
00583         std::swap(m_first, cb.<a class="code" href="classboost_1_1circular__buffer.html#r2">m_first</a>);
00584         std::swap(m_last, cb.<a class="code" href="classboost_1_1circular__buffer.html#r3">m_last</a>);
00585         std::swap(m_size, cb.<a class="code" href="classboost_1_1circular__buffer.html#r4">m_size</a>);
00586 <span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
00587 <span class="preprocessor"></span>        invalidate_all_iterators();
00588         cb.invalidate_all_iterators();
00589 <span class="preprocessor">#endif</span>
00590 <span class="preprocessor"></span>    }
00591 
00592 <span class="comment">// push and pop</span>
00593 
00595 
<a name="l00601"></a><a class="code" href="classboost_1_1circular__buffer.html#a35">00601</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a36">push_back</a>(param_value_type item) {
00602         <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()) {
00603             <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>())
00604                 <span class="keywordflow">return</span>;
00605             replace_last(item);
00606             increment(m_last);
00607             m_first = m_last;
00608         } <span class="keywordflow">else</span> {
00609             m_alloc.construct(m_last, item);
00610             increment(m_last);
00611             ++m_size;
00612         }
00613     }
00614 
00616 
<a name="l00622"></a><a class="code" href="classboost_1_1circular__buffer.html#a36">00622</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a36">push_back</a>() { <a class="code" href="classboost_1_1circular__buffer.html#a36">push_back</a>(<a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>()); }
00623 
00625 
<a name="l00631"></a><a class="code" href="classboost_1_1circular__buffer.html#a37">00631</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a38">push_front</a>(param_value_type item) {
00632         <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()) {
00633             <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>())
00634                 <span class="keywordflow">return</span>;
00635             replace_first(item);
00636             m_last = m_first;
00637         } <span class="keywordflow">else</span> {
00638             decrement(m_first);
00639             BOOST_CB_TRY
00640             m_alloc.construct(m_first, item);
00641             BOOST_CB_UNWIND(increment(m_first))
00642             ++m_size;
00643         }
00644     }
00645 
00647 
<a name="l00653"></a><a class="code" href="classboost_1_1circular__buffer.html#a38">00653</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a38">push_front</a>() { <a class="code" href="classboost_1_1circular__buffer.html#a38">push_front</a>(<a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>()); }
00654 
00656 
<a name="l00662"></a><a class="code" href="classboost_1_1circular__buffer.html#a39">00662</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a39">pop_back</a>() {
00663         BOOST_CB_ASSERT(!<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>()); <span class="comment">// check for empty buffer (back element not available)</span>
00664         decrement(m_last);
00665         destroy_item(m_last);
00666         --m_size;
00667     }
00668 
00670 
<a name="l00676"></a><a class="code" href="classboost_1_1circular__buffer.html#a40">00676</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a40">pop_front</a>() {
00677         BOOST_CB_ASSERT(!<a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>()); <span class="comment">// check for empty buffer (front element not available)</span>
00678         destroy_item(m_first);
00679         increment(m_first);
00680         --m_size;
00681     }
00682 
00683 <span class="keyword">private</span>:
00684 <span class="comment">// Helper wrappers</span>
00685 
00686     <span class="comment">// Iterator dereference wrapper.</span>
00687     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
00688     <span class="keyword">struct </span>iterator_wrapper {
00689         <span class="keyword">mutable</span> InputIterator m_it;
00690         <span class="keyword">explicit</span> iterator_wrapper(InputIterator it) : m_it(it) {}
00691         InputIterator get_reference()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_it++; }
00692     };
00693 
00694     <span class="comment">// Item dereference wrapper.</span>
00695     <span class="keyword">struct </span>item_wrapper {
00696         const_pointer m_item;
00697         <span class="keyword">explicit</span> item_wrapper(param_value_type item) : m_item(&amp;item) {}
00698         const_pointer get_reference()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_item; }
00699     };
00700 
00701 <span class="keyword">public</span>:
00702 <span class="comment">// Insert</span>
00703 
00705 
<a name="l00714"></a><a class="code" href="classboost_1_1circular__buffer.html#a41">00714</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, param_value_type item) {
00715         BOOST_CB_ASSERT(pos.is_valid()); <span class="comment">// check for uninitialized or invalidated iterator</span>
00716         <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>() &amp;&amp; pos == <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>())
00717             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>();
00718         <span class="keywordflow">if</span> (pos.m_it == 0) {
00719             <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>())
00720                 replace_last(item);
00721             <span class="keywordflow">else</span>
00722                 m_alloc.construct(m_last, item);
00723             pos.m_it = m_last;
00724         } <span class="keywordflow">else</span> {
00725             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> src = m_last;
00726             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> dest = m_last;
00727             BOOST_CB_TRY
00728             <span class="keywordflow">while</span> (src != pos.m_it) {
00729                 decrement(src);
00730                 <span class="keywordflow">if</span> (dest == m_last &amp;&amp; !<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>())
00731                     m_alloc.construct(dest, *src);
00732                 <span class="keywordflow">else</span>
00733                     replace(dest, *src);
00734                 decrement(dest);
00735             }
00736             replace(pos.m_it, item);
00737             BOOST_CB_UNWIND(
00738                 <span class="keywordflow">if</span> (dest == m_last) {
00739                     <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()) {
00740                         increment(m_first);
00741                         --m_size;
00742                     }
00743                 } <span class="keywordflow">else</span> {
00744                     <span class="keywordflow">if</span> (!<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()) {
00745                         increment(m_last);
00746                         ++m_size;
00747                     }
00748                     tidy(dest);
00749                 }
00750             )
00751         }
00752         increment(m_last);
00753         <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>())
00754             m_first = m_last;
00755         <span class="keywordflow">else</span>
00756             ++m_size;
00757         <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>(<span class="keyword">this</span>, pos.m_it);
00758     }
00759 
00761 
<a name="l00769"></a><a class="code" href="classboost_1_1circular__buffer.html#a42">00769</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos) { <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(pos, <a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>()); }
00770 
00772 
<a name="l00790"></a><a class="code" href="classboost_1_1circular__buffer.html#a43">00790</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> n, param_value_type item) {
00791         BOOST_CB_ASSERT(pos.is_valid()); <span class="comment">// check for uninitialized or invalidated iterator</span>
00792         <span class="keywordflow">if</span> (n == 0)
00793             <span class="keywordflow">return</span>;
00794         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> copy = <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>() - (<a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() - pos);
00795         <span class="keywordflow">if</span> (copy == 0)
00796             <span class="keywordflow">return</span>;
00797         <span class="keywordflow">if</span> (n &gt; copy)
00798             n = copy;
00799         insert_n_item(pos, n, item_wrapper(item));
00800     }
00801 
00803 
00824     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00825"></a><a class="code" href="classboost_1_1circular__buffer.html#a44">00825</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, InputIterator first, InputIterator last) {
00826         BOOST_CB_ASSERT(pos.is_valid()); <span class="comment">// check for uninitialized or invalidated iterator</span>
00827         <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(pos, first, last, cb_details::cb_iterator_category_traits&lt;InputIterator&gt;::tag());
00828     }
00829 
00831 
<a name="l00840"></a><a class="code" href="classboost_1_1circular__buffer.html#a45">00840</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, param_value_type item) {
00841         BOOST_CB_ASSERT(pos.is_valid()); <span class="comment">// check for uninitialized or invalidated iterator</span>
00842         <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>() &amp;&amp; pos == <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>())
00843             <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>();
00844         <span class="keywordflow">if</span> (pos == <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>()) {
00845             <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()) {
00846                 replace_first(item);
00847             } <span class="keywordflow">else</span> {
00848                 decrement(m_first);
00849                 BOOST_CB_TRY
00850                 m_alloc.construct(m_first, item);
00851                 BOOST_CB_UNWIND(increment(m_first))
00852             }
00853         } <span class="keywordflow">else</span> {
00854             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> src = m_first;
00855             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> dest = m_first;
00856             decrement(dest);
00857             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> it = map_pointer(pos.m_it);
00858             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> first = m_first;
00859             decrement(first);
00860             BOOST_CB_TRY
00861             <span class="keywordflow">while</span> (src != it) {
00862                 <span class="keywordflow">if</span> (dest == first &amp;&amp; !<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>())
00863                     m_alloc.construct(dest, *src);
00864                 <span class="keywordflow">else</span>
00865                     replace(dest, *src);
00866                 increment(src);
00867                 increment(dest);
00868             }
00869             replace((--pos).m_it, item);
00870             BOOST_CB_UNWIND(
00871                 <span class="keywordflow">if</span> (dest == first) {
00872                     <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()) {
00873                         decrement(m_last);
00874                         --m_size;
00875                     }
00876                 } <span class="keywordflow">else</span> {
00877                     <span class="keywordflow">if</span> (!<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>()) {
00878                         m_first = first;
00879                         ++m_size;
00880                     }
00881                     tidy(dest);
00882                 }
00883             )
00884             decrement(m_first);
00885         }
00886         <span class="keywordflow">if</span> (<a class="code" href="classboost_1_1circular__buffer.html#a22">full</a>())
00887             m_last = m_first;
00888         <span class="keywordflow">else</span>
00889             ++m_size;
00890         <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>(<span class="keyword">this</span>, pos.m_it);
00891     }
00892 
00894 
<a name="l00902"></a><a class="code" href="classboost_1_1circular__buffer.html#a46">00902</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos) { <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(pos, <a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>()); }
00903 
00905 
<a name="l00923"></a><a class="code" href="classboost_1_1circular__buffer.html#a47">00923</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> n, param_value_type item) {
00924         BOOST_CB_ASSERT(pos.is_valid()); <span class="comment">// check for uninitialized or invalidated iterator</span>
00925         rinsert_n_item(pos, n, item_wrapper(item));
00926     }
00927 
00929 
00950     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00951"></a><a class="code" href="classboost_1_1circular__buffer.html#a48">00951</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos, InputIterator first, InputIterator last) {
00952         BOOST_CB_ASSERT(pos.is_valid()); <span class="comment">// check for uninitialized or invalidated iterator</span>
00953         <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(pos, first, last, cb_details::cb_iterator_category_traits&lt;InputIterator&gt;::tag());
00954     }
00955 
00956 <span class="comment">// Erase</span>
00957 
00959 
<a name="l00968"></a><a class="code" href="classboost_1_1circular__buffer.html#a49">00968</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a49">erase</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> pos) {
00969         BOOST_CB_ASSERT(pos.is_valid()); <span class="comment">// check for uninitialized or invalidated iterator</span>
00970         BOOST_CB_ASSERT(pos.m_it != 0);  <span class="comment">// check for iterator pointing to end()</span>
00971         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> next = pos.m_it;
00972         increment(next);
00973         <span class="keywordflow">for</span> (<a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> p = pos.m_it; next != m_last; p = next, increment(next))
00974             replace(p, *next);
00975         decrement(m_last);
00976         destroy_item(m_last);
00977         --m_size;
00978 <span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
00979 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>() ? <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() : <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>(<span class="keyword">this</span>, pos.m_it);
00980 <span class="preprocessor">#else</span>
00981 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>() ? <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() : pos;
00982 <span class="preprocessor">#endif</span>
00983 <span class="preprocessor"></span>    }
00984 
00986 
<a name="l00995"></a><a class="code" href="classboost_1_1circular__buffer.html#a50">00995</a>     <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> <a class="code" href="classboost_1_1circular__buffer.html#a49">erase</a>(<a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> first, <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a> last) {
00996         BOOST_CB_ASSERT(first.is_valid());            <span class="comment">// check for uninitialized or invalidated iterator</span>
00997         BOOST_CB_ASSERT(last.is_valid());             <span class="comment">// check for uninitialized or invalidated iterator</span>
00998         BOOST_CB_ASSERT(first.m_buff == last.m_buff); <span class="comment">// check for iterators of different containers</span>
00999         BOOST_CB_ASSERT(first &lt;= last);               <span class="comment">// check for wrong range</span>
01000         <span class="keywordflow">if</span> (first == last)
01001             <span class="keywordflow">return</span> first;
01002         <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> tmp = first.m_it;
01003         <a class="code" href="classboost_1_1circular__buffer.html#w5">difference_type</a> diff = last - first;
01004         <span class="keywordflow">while</span> (last.m_it != 0)
01005             replace((first++).m_it, *last++);
01006         <span class="keywordflow">while</span> (first.m_it != 0)
01007             destroy_item((first++).m_it);
01008         m_last = sub(m_last, diff);
01009         m_size -= diff;
01010         <span class="keywordflow">return</span> <a class="code" href="classboost_1_1circular__buffer.html#a21">empty</a>() ? <a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() : <a class="code" href="classboost_1_1circular__buffer.html#w11">iterator</a>(<span class="keyword">this</span>, tmp);
01011     }
01012 
01014 
<a name="l01018"></a><a class="code" href="classboost_1_1circular__buffer.html#a51">01018</a>     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a51">clear</a>() {
01019         destroy_content();
01020         m_first = m_last = m_buff;
01021         m_size = 0;
01022     }
01023 
01024 <span class="keyword">private</span>:
01025 <span class="comment">// Debug support</span>
01026 
01027 <span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
01028 <span class="preprocessor"></span>    
01029     <span class="comment">// Predicate determining if the condition for iterator invalidation has been met.</span>
01030     <span class="keyword">struct </span>is_invalid_condition {
01031         pointer m_p;
01032         <span class="keyword">explicit</span> is_invalid_condition(pointer p) : m_p(p) {}
01033         <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> cb_details::cb_iterator_base* p)<span class="keyword"> const </span>{
01034             <span class="keywordflow">return</span> ((iterator*)p)-&gt;m_it == m_p;
01035         }
01036     };
01037 
01038 <span class="preprocessor">#endif // #if BOOST_CB_ENABLE_DEBUG</span>
01039 <span class="preprocessor"></span>
01040 <span class="comment">// Helper methods</span>
01041 
01043     <span class="keywordtype">void</span> check_position(size_type index)<span class="keyword"> const </span>{
01044         <span class="keywordflow">if</span> (index &gt;= <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>())
01045             throw_exception(std::out_of_range(<span class="stringliteral">"circular_buffer"</span>));
01046     }
01047 
01049     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>er0&gt;
01050     <span class="keywordtype">void</span> increment(Pointer0&amp; p)<span class="keyword"> const </span>{
01051         <span class="keywordflow">if</span> (++p == m_end)
01052             p = m_buff;
01053     }
01054 
01056     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>er0&gt;
01057     <span class="keywordtype">void</span> decrement(Pointer0&amp; p)<span class="keyword"> const </span>{
01058         <span class="keywordflow">if</span> (p == m_buff)
01059             p = m_end;
01060         --p;
01061     }
01062 
01064     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>er0&gt;
01065     Pointer0 add(Pointer0 p, difference_type n)<span class="keyword"> const </span>{
01066         <span class="keywordflow">return</span> p + (n &lt; (m_end - p) ? n : n - <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>());
01067     }
01068 
01070     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Po<span class="keywordtype">int</span>er0&gt;
01071     Pointer0 sub(Pointer0 p, difference_type n)<span class="keyword"> const </span>{
01072         <span class="keywordflow">return</span> p - (n &gt; (p - m_buff) ? n - <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>() : n);
01073     }
01074 
01076     <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> map_pointer(pointer p)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> p == 0 ? m_last : p; }
01077 
01079     <span class="keywordtype">bool</span> is_uninitialized(const_pointer p)<span class="keyword"> const </span>{
01080         <span class="keywordflow">return</span> p &gt;= m_last &amp;&amp; (m_first &lt; m_last || p &lt; m_first);
01081     }
01082 
01084 
01087     <span class="keywordtype">void</span> create_or_replace(pointer pos, param_value_type item) {
01088         <span class="keywordflow">if</span> (is_uninitialized(pos))
01089             m_alloc.construct(pos, item);
01090         <span class="keywordflow">else</span>
01091             replace(pos, item);
01092     }
01093 
01095 
01098     <span class="keywordtype">void</span> destroy_created(pointer pos) {
01099         <span class="keywordflow">if</span> (is_uninitialized(pos))
01100             destroy_item(pos);
01101     }
01102 
01104     <span class="keywordtype">void</span> replace(pointer pos, param_value_type item) {
01105         replace(pos, item, cb_details::cb_replace_category_traits&lt;value_type&gt;::tag()); <span class="comment">// invoke optimized operation for given type</span>
01106 <span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
01107 <span class="preprocessor"></span>        invalidate_iterators(is_invalid_condition(pos));
01108 <span class="preprocessor">#endif</span>
01109 <span class="preprocessor"></span>    }
01110 
01112     <span class="keywordtype">void</span> replace(pointer pos, param_value_type item, cb_details::cb_destroy_tag) {
01113         m_alloc.destroy(pos);
01114         m_alloc.construct(pos, item);
01115     }
01116 
01118     <span class="keywordtype">void</span> replace(pointer pos, param_value_type item, cb_details::cb_assign_tag) {
01119         *pos = item;
01120     }
01121 
01123     <span class="keywordtype">void</span> replace_first(param_value_type item) {
01124         decrement(m_first);
01125         BOOST_CB_TRY
01126         replace(m_first, item);
01127         BOOST_CB_UNWIND(
01128             increment(m_first);
01129             decrement(m_last);
01130             --m_size;
01131         )
01132     }
01133 
01135     <span class="keywordtype">void</span> replace_last(param_value_type item) {
01136         BOOST_CB_TRY
01137         replace(m_last, item);
01138         BOOST_CB_UNWIND(
01139             decrement(m_last);
01140             --m_size;
01141         )
01142     }
01143 
01145     <span class="keywordtype">void</span> tidy(pointer p) {
01146         <span class="keywordflow">for</span> (; m_first != p; increment(m_first), --m_size)
01147             destroy_item(m_first);
01148         increment(m_first);
01149         --m_size;
01150     }
01151 
01153     <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> allocate(size_type n) {
01154         <span class="keywordflow">if</span> (n &gt; <a class="code" href="classboost_1_1circular__buffer.html#a20">max_size</a>())
01155             throw_exception(std::length_error(<span class="stringliteral">"circular_buffer"</span>));
01156 <span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
01157 <span class="preprocessor"></span>        <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> p = (n == 0) ? 0 : m_alloc.allocate(n, 0);
01158         ::memset(p, cb_details::CB_Unitialized, <span class="keyword">sizeof</span>(<a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>) * n);
01159         <span class="keywordflow">return</span> p;
01160 <span class="preprocessor">#else</span>
01161 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (n == 0) ? 0 : m_alloc.allocate(n, 0);
01162 <span class="preprocessor">#endif</span>
01163 <span class="preprocessor"></span>    }
01164 
01166     <span class="keywordtype">void</span> deallocate(pointer p, size_type n) {
01167         <span class="keywordflow">if</span> (p != 0)
01168             m_alloc.deallocate(p, n);
01169     }
01170 
01172     <span class="keywordtype">void</span> destroy_item(pointer p) {
01173         m_alloc.destroy(p);
01174 <span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
01175 <span class="preprocessor"></span>        invalidate_iterators(is_invalid_condition(p));
01176         ::memset(p, cb_details::CB_Unitialized, <span class="keyword">sizeof</span>(<a class="code" href="classboost_1_1circular__buffer.html#w0">value_type</a>));
01177 <span class="preprocessor">#endif</span>
01178 <span class="preprocessor"></span>    }
01179 
01181     <span class="keywordtype">void</span> destroy_content() {
01182         <span class="keywordflow">for</span> (<a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> ii = 0; ii &lt; <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>(); ++ii, increment(m_first))
01183             destroy_item(m_first);
01184     }
01185 
01187     <span class="keywordtype">void</span> destroy() {
01188         destroy_content();
01189         deallocate(m_buff, <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>());
01190 <span class="preprocessor">#if BOOST_CB_ENABLE_DEBUG</span>
01191 <span class="preprocessor"></span>        invalidate_all_iterators(); <span class="comment">// invalidate iterators pointing to end()</span>
01192         m_buff = 0;
01193         m_first = 0;
01194         m_last = 0;
01195         m_end = 0;
01196 <span class="preprocessor">#endif</span>
01197 <span class="preprocessor"></span>    }
01198 
01200     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
01201     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a32">assign</a>(InputIterator n, InputIterator item, cb_details::cb_int_iterator_tag) {
01202         <a class="code" href="classboost_1_1circular__buffer.html#a32">assign</a>((size_type)n, item);
01203     }
01204 
01206     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
01207     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a32">assign</a>(InputIterator first, InputIterator last, std::input_iterator_tag) {
01208         BOOST_CB_IS_CONVERTIBLE(InputIterator, value_type);
01209         BOOST_CB_ASSERT(std::distance(first, last) &gt;= 0); <span class="comment">// check for wrong range</span>
01210         do_assign(std::distance(first, last), assign_range&lt;InputIterator&gt;(first, last, m_alloc));
01211     }
01212 
01214     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Functor&gt;
01215     <span class="keywordtype">void</span> do_assign(size_type n, <span class="keyword">const</span> Functor&amp; fnc) {
01216         <span class="keywordflow">if</span> (n &gt; <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>()) {
01217             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> buff = allocate(n);
01218             BOOST_CB_TRY
01219             fnc(buff);
01220             BOOST_CB_UNWIND(deallocate(buff, n))
01221             destroy();
01222             m_buff = buff;
01223             m_end = m_buff + n;
01224         } <span class="keywordflow">else</span> {
01225             destroy_content();
01226             BOOST_CB_TRY
01227             fnc(m_buff);
01228             BOOST_CB_UNWIND(m_size = 0)
01229         }
01230         m_size = n;
01231         m_first = m_buff;
01232         m_last = add(m_buff, <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>());
01233     }
01234 
01236     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
01237     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(iterator pos, InputIterator n, InputIterator item, cb_details::cb_int_iterator_tag) {
01238         <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(pos, (size_type)n, item);
01239     }
01240 
01242     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
01243     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a41">insert</a>(iterator pos, InputIterator first, InputIterator last, std::input_iterator_tag) {
01244         BOOST_CB_IS_CONVERTIBLE(InputIterator, value_type);
01245         BOOST_CB_ASSERT(std::distance(first, last) &gt;= 0); <span class="comment">// check for wrong range</span>
01246         <a class="code" href="classboost_1_1circular__buffer.html#w5">difference_type</a> n = std::distance(first, last);
01247         <span class="keywordflow">if</span> (n == 0)
01248             <span class="keywordflow">return</span>;
01249         <a class="code" href="classboost_1_1circular__buffer.html#w5">difference_type</a> copy = <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>() - (<a class="code" href="classboost_1_1circular__buffer.html#a3">end</a>() - pos);
01250         <span class="keywordflow">if</span> (copy == 0)
01251             <span class="keywordflow">return</span>;
01252         <span class="keywordflow">if</span> (n &gt; copy) {
01253             std::advance(first, n - copy);
01254             n = copy;
01255         }
01256         insert_n_item(pos, n, iterator_wrapper&lt;InputIterator&gt;(first));
01257     }
01258 
01260     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Wrapper&gt;
01261     <span class="keywordtype">void</span> insert_n_item(iterator pos, size_type n, <span class="keyword">const</span> Wrapper&amp; wrapper) {
01262         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> construct = <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>() - <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>();
01263         <span class="keywordflow">if</span> (construct &gt; n)
01264             construct = n;
01265         <span class="keywordflow">if</span> (pos.m_it == 0) {
01266             <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> ii = 0;
01267             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> p = m_last;
01268             BOOST_CB_TRY
01269             <span class="keywordflow">for</span> (; ii &lt; construct; ++ii, increment(p))
01270                 m_alloc.construct(p, *wrapper.get_reference());
01271             <span class="keywordflow">for</span> (;ii &lt; n; ++ii, increment(p))
01272                 replace(p, *wrapper.get_reference());
01273             BOOST_CB_UNWIND(
01274                 size_type constructed = std::min(ii, construct);
01275                 m_last = add(m_last, constructed);
01276                 m_size += constructed;
01277                 <span class="keywordflow">if</span> (ii &gt;= construct)
01278                     tidy(p);
01279             )
01280         } <span class="keywordflow">else</span> {
01281             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> src = m_last;
01282             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> dest = add(m_last, n - 1);
01283             <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> ii = 0;
01284             BOOST_CB_TRY
01285             <span class="keywordflow">while</span> (src != pos.m_it) {
01286                 decrement(src);
01287                 create_or_replace(dest, *src);
01288                 decrement(dest);
01289             }
01290             <span class="keywordflow">for</span> (dest = pos.m_it; ii &lt; n; ++ii, increment(dest))
01291                 create_or_replace(dest, *wrapper.get_reference());
01292             BOOST_CB_UNWIND(
01293                 <span class="keywordflow">for</span> (pointer p1 = m_last, p2 = add(m_last, n - 1); p1 != src; decrement(p2)) {
01294                     decrement(p1);
01295                     destroy_created(p2);
01296                 }
01297                 <span class="keywordflow">for</span> (n = 0, src = pos.m_it; n &lt; ii; ++n, increment(src))
01298                     destroy_created(src);
01299                 <span class="keywordflow">if</span> (!is_uninitialized(dest))
01300                     tidy(dest);
01301             )
01302         }
01303         m_last = add(m_last, n);
01304         m_first = add(m_first, n - construct);
01305         m_size += construct;
01306     }
01307 
01309     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
01310     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(iterator pos, InputIterator n, InputIterator item, cb_details::cb_int_iterator_tag) {
01311         <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(pos, (size_type)n, item);
01312     }
01313 
01315     <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
01316     <span class="keywordtype">void</span> <a class="code" href="classboost_1_1circular__buffer.html#a45">rinsert</a>(iterator pos, InputIterator first, InputIterator last, std::input_iterator_tag) {
01317         BOOST_CB_IS_CONVERTIBLE(InputIterator, value_type);
01318         BOOST_CB_ASSERT(std::distance(first, last) &gt;= 0); <span class="comment">// check for wrong range</span>
01319         rinsert_n_item(pos, std::distance(first, last), iterator_wrapper&lt;InputIterator&gt;(first));
01320     }
01321 
01323     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Wrapper&gt;
01324     <span class="keywordtype">void</span> rinsert_n_item(iterator pos, size_type n, <span class="keyword">const</span> Wrapper&amp; wrapper) {
01325         <span class="keywordflow">if</span> (n == 0)
01326             <span class="keywordflow">return</span>;
01327         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> copy = <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>() - (pos - <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>());
01328         <span class="keywordflow">if</span> (copy == 0)
01329             <span class="keywordflow">return</span>;
01330         <span class="keywordflow">if</span> (n &gt; copy)
01331             n = copy;
01332         <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> construct = <a class="code" href="classboost_1_1circular__buffer.html#a23">capacity</a>() - <a class="code" href="classboost_1_1circular__buffer.html#a19">size</a>();
01333         <span class="keywordflow">if</span> (construct &gt; n)
01334             construct = n;
01335         <span class="keywordflow">if</span> (pos == <a class="code" href="classboost_1_1circular__buffer.html#a2">begin</a>()) {
01336             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> p = sub(map_pointer(pos.m_it), n);
01337             <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> ii = n;
01338             BOOST_CB_TRY
01339             <span class="keywordflow">for</span> (;ii &gt; construct; --ii, increment(p))
01340                 replace(p, *wrapper.get_reference());
01341             <span class="keywordflow">for</span> (; ii &gt; 0; --ii, increment(p))
01342                 m_alloc.construct(p, *wrapper.get_reference());
01343             BOOST_CB_UNWIND(
01344                 size_type unwind = ii &lt; construct ? construct - ii : 0;
01345                 pointer tmp = sub(map_pointer(pos.m_it), construct);
01346                 for (n = 0; n &lt; unwind; ++n, increment(tmp))
01347                     destroy_item(tmp);
01348                 <span class="keywordflow">if</span> (ii &gt; construct)
01349                     tidy(p);
01350             )
01351         } <span class="keywordflow">else</span> {
01352             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> src = m_first;
01353             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> dest = sub(m_first, n);
01354             <a class="code" href="classboost_1_1circular__buffer.html#w1">pointer</a> p = map_pointer(pos.m_it);
01355             <a class="code" href="classboost_1_1circular__buffer.html#w6">size_type</a> ii = 0;
01356             BOOST_CB_TRY
01357             <span class="keywordflow">while</span> (src != p) {
01358                 create_or_replace(dest, *src);
01359                 increment(src);
01360                 increment(dest);
01361             }
01362             dest = sub(p, n);
01363             <span class="keywordflow">for</span> (; ii &lt; n; ++ii, increment(dest))
01364                 create_or_replace(dest, *wrapper.get_reference());
01365             BOOST_CB_UNWIND(
01366                 <span class="keywordflow">for</span> (pointer p1 = m_first, p2 = sub(m_first, n); p1 != src; increment(p1), increment(p2))
01367                     destroy_created(p2);
01368                 p = sub(p, n);
01369                 <span class="keywordflow">for</span> (n = 0; n &lt; ii; ++n, increment(p))
01370                     destroy_created(p);
01371                 <span class="keywordflow">if</span> (!is_uninitialized(dest))
01372                     tidy(dest);
01373             )
01374         }
01375         m_first = sub(m_first, n);
01376         m_last = sub(m_last, n - construct);
01377         m_size += construct;
01378     }
01379 };
01380 
01381 <span class="comment">// Non-member functions</span>
01382 
01384 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
01385 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; lhs,
01386                          <span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; rhs) {
01387     <span class="keywordflow">return</span> lhs.size() == rhs.size() &amp;&amp;
01388         std::equal(lhs.begin(), lhs.end(), rhs.begin());
01389 }
01390 
01392 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
01393 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (const circular_buffer&lt;T, Alloc&gt;&amp; lhs,
01394                         <span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; rhs) {
01395     <span class="keywordflow">return</span> std::lexicographical_compare(
01396         lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
01397 }
01398 
01399 <span class="preprocessor">#if !defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING) || defined(BOOST_MSVC)</span>
01400 <span class="preprocessor"></span>
01402 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
01403 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; lhs,
01404                          <span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; rhs) {
01405     <span class="keywordflow">return</span> !(lhs == rhs);
01406 }
01407 
01409 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
01410 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; lhs,
01411                         <span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; rhs) {
01412     <span class="keywordflow">return</span> rhs &lt; lhs;
01413 }
01414 
01416 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
01417 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt;= (const circular_buffer&lt;T, Alloc&gt;&amp; lhs,
01418                          <span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; rhs) {
01419     <span class="keywordflow">return</span> !(rhs &lt; lhs);
01420 }
01421 
01423 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
01424 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt;= (<span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; lhs,
01425                          <span class="keyword">const</span> circular_buffer&lt;T, Alloc&gt;&amp; rhs) {
01426     <span class="keywordflow">return</span> !(lhs &lt; rhs);
01427 }
01428 
01430 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
01431 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(circular_buffer&lt;T, Alloc&gt;&amp; lhs, circular_buffer&lt;T, Alloc&gt;&amp; rhs) {
01432     lhs.swap(rhs);
01433 }
01434 
01435 <span class="preprocessor">#endif // #if !defined(BOOST_NO_FUNCTION_TEMPLATE_ORDERING) || defined(BOOST_MSVC)</span>
01436 <span class="preprocessor"></span>
01437 } <span class="comment">// namespace boost</span>
01438 
01439 <span class="preprocessor">#endif // #if !defined(BOOST_CIRCULAR_BUFFER_BASE_HPP)</span>
</pre></div><hr>
<table id="Table Footer" width="100%" border="0">
	<tr>
		<td valign="top"><small>Copyright  2003-2004 <A href="mailto:jano_gaspar[at]yahoo.com">Jan 
					Gaspar</A></small></td>
		<td align="center"><img width="277" height="86" src="../../../../c++boost.gif"></td>
		<td align="right" valign="top"><small>Generated by <a href="http://www.doxygen.org">doxygen 
					1.3.5</a>.</small></td>
	</tr>
</table>
</body>
</html>
